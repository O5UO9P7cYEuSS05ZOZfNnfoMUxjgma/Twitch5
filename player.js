


'use strict';

// Формат версии: https://developer.chrome.com/extensions/manifest/version
// В моем случае это UTC-дата выкладывания данной версии для скачивания.
// 1 - год >= 2016
// 2 - месяц 1..12
// 3 - день месяца 1..31
// 4 - указывается только для версий, выпущенных в один день. >= 1, по умолчанию 0.
// Edge: Последнее число должно быть нулем.
// https://docs.microsoft.com/en-us/microsoft-edge/extensions/guides/packaging/creating-and-testing-extension-packages#json-manifest-template-values
const ВЕРСИЯ_РАСШИРЕНИЯ = '2018.7.9';
const ВЕРСИЯ_ДВИЖКА_БРАУЗЕРА = Number.parseInt(/Chrome\/(\d+)/.exec(navigator.userAgent)[1], 10);
//const ЭТО_ПЛАНШЕТ = false;

// Chrome 59 + Windows + аппаратное декодирование: Для завершения перемотки и начала воспроизведения нужно не менее
// 4 кадров, не исключено, что иногда и больше. Без аппаратного декодирования достаточно 2 кадров.
const МИН_РАЗМЕР_БУФЕРА         = 1.5; // Секунды.
const МАКС_РАЗМЕР_БУФЕРА        =  30; // Секунды. TODO Измерять в сегментах?
const МИН_РАСТЯГИВАНИЕ_БУФЕРА   =   9; // Секунды. TODO Измерять в сегментах?
const МАКС_РАСТЯГИВАНИЕ_БУФЕРА  =  30; // Секунды. TODO Измерять в сегментах?
const ПЕРЕПОЛНЕНИЕ_БУФЕРА       = МАКС_РАЗМЕР_БУФЕРА + МАКС_РАСТЯГИВАНИЕ_БУФЕРА; // TODO Избавиться от ПЕРЕПОЛНЕНИЕ_БУФЕРА.

// Если в удаляемом диапазоне есть ключевой кадр, то будут удалены все последующие кадры до ключевого кадра, не входящего
// в удаляемый диапазон. Таким образом возможна ситуация, когда будет удалено всё просмотренное видео и часть
// непросмотренного, что приведет к остановке воспроизведения. Чтобы этого не произошло, МИН_ДЛИТЕЛЬНОСТЬ_ПОВТОРА должна
// превышать расстояние между ключевыми кадрами. Чем больше видео в буфере, тем выше расход памяти, до 150 МиБ.
const МИН_ДЛИТЕЛЬНОСТЬ_ПОВТОРА  = 30;  // Секунды.
const МАКС_ДЛИТЕЛЬНОСТЬ_ПОВТОРА = 300; // Секунды.

// По стандарту HLS минимальный интервал равен 50.
const МИН_ИНТЕРВАЛ_ОБНОВЛЕНИЯ_СПИСКОВ      = 40;    // Процент target duration.

const ЗАГРУЖАТЬ_МЕТАДАННЫЕ_НЕ_ДОЛЬШЕ       = 15000; // Миллисекунды.
const ЗАГРУЖАТЬ_СПИСОК_ВАРИАНТОВ_НЕ_ДОЛЬШЕ = 15000; // Миллисекунды.
const ЗАГРУЖАТЬ_СПИСОК_СЕГМЕНТОВ_НЕ_ДОЛЬШЕ =  6000; // Миллисекунды.

// Edge 15 во всплывающей подсказке показывает текущее целое значение громкости,
// поэтому для интерфейса не подходит "родной" диапазон 0..1.
const МИНИМАЛЬНАЯ_ГРОМКОСТЬ            = 1;
const МАКСИМАЛЬНАЯ_ГРОМКОСТЬ           = 100;
const ШАГ_ПОВЫШЕНИЯ_ГРОМКОСТИ_КЛАВОЙ   = 4;
const ШАГ_ПОНИЖЕНИЯ_ГРОМКОСТИ_КЛАВОЙ   = 2;
const ШАГ_ИЗМЕНЕНИЯ_ГРОМКОСТИ_МЫШЬЮ    = 1;
const ШАГ_ПОВЫШЕНИЯ_ГРОМКОСТИ_КОЛЕСОМ  = 5;
const ШАГ_ПОНИЖЕНИЯ_ГРОМКОСТИ_КОЛЕСОМ  = 3;

const ОБРАБОТКА_ЖДЕТ_ЗАГРУЗКИ          = 1;
const ОБРАБОТКА_ЗАГРУЖАЕТСЯ            = 2;
const ОБРАБОТКА_ЗАГРУЖЕН               = 3;
const ОБРАБОТКА_ПРЕОБРАЗОВАН           = 4;

// Эти константы также определены в player.css.
const СОСТОЯНИЕ_ЗАПУСК                 = 1;
const СОСТОЯНИЕ_НАЧАЛО_ТРАНСЛЯЦИИ      = 2;
const СОСТОЯНИЕ_ЗАВЕРШЕНИЕ_ТРАНСЛЯЦИИ  = 3;
const СОСТОЯНИЕ_ЗАГРУЗКА               = 4;
const СОСТОЯНИЕ_НАЧАЛО_ВОСПРОИЗВЕДЕНИЯ = 5;
const СОСТОЯНИЕ_ВОСПРОИЗВЕДЕНИЕ        = 6;
const СОСТОЯНИЕ_ОСТАНОВКА              = 7;
const СОСТОЯНИЕ_ПОВТОР                 = 8;
const СОСТОЯНИЕ_СМЕНА_ВАРИАНТА         = 9;

// Эти константы также определены в player.css.
const ПОДПИСКА_ОБНОВЛЯЕТСЯ             = -1;
const ПОДПИСКА_НЕДОСТУПНА              = 0;
const ПОДПИСКА_НЕОФОРМЛЕНА             = 1;
const ПОДПИСКА_НЕУВЕДОМЛЯТЬ            = 2;
const ПОДПИСКА_УВЕДОМЛЯТЬ              = 3;

const КОД_ОТВЕТА                       = 'Сервер вернул код ';

const МИН_ЗНАЧЕНИЕ_НАСТРОЙКИ           = Number.MIN_SAFE_INTEGER + 1000; // На будущее.
const МАКС_ЗНАЧЕНИЕ_НАСТРОЙКИ          = Number.MAX_SAFE_INTEGER - 1000; // На будущее.
const АВТОНАСТРОЙКА                    = Number.MIN_SAFE_INTEGER;        // См. комментарий в Настройка.ПроверитьЗначение().

// MouseEvent.button.
const ЛЕВАЯ_КНОПКА                     = 0;
const СРЕДНЯЯ_КНОПКА                   = 1;
const ПРАВАЯ_КНОПКА                    = 2;

// Эти константы также определены в player.html.
const ЧАТ_ВЫГРУЖЕН                     = 0;
const ЧАТ_СКРЫТ                        = 1;
const ЧАТ_ПАНЕЛЬ                       = 2;

// Эти константы также определены в player.html.
const ВЕРХНЯЯ_СТОРОНА                  = 1;
const ПРАВАЯ_СТОРОНА                   = 2;
const НИЖНЯЯ_СТОРОНА                   = 3;
const ЛЕВАЯ_СТОРОНА                    = 4;

let г_чИдВкладки = NaN;

/* Chrome 65-, Firefox, Edge
if (!navigator.clipboard)
{
	navigator.clipboard = {};
}
if (!navigator.clipboard.writeText)
{
	// Chrome 67: Если открыто окно, которое запрашивает разрешение на доступ к буферу обмена,
	// то все вызовы методов navigator.clipboard ставятся в очередь. Они будут обслужены после
	// закрытия окна.
	navigator.clipboard.writeText = function(сТекст)
	{
		Проверить(typeof сТекст === 'string');
		return new Promise(ДобавитьОбработчикИсключений((фВыполнить, фОтказаться) =>
		{
			const узТекст = document.createElement('input');
			узТекст.type = 'text';
			// Нужен чтобы на планшете не вылезала клавиатура.
			узТекст.readOnly = true;
			узТекст.value = сТекст;
			узТекст.style.position = 'fixed';
			узТекст.style.left = '-100500px';
			document.body.appendChild(узТекст);
			узТекст.select();
			const лПолучилось = document.execCommand('copy');
			узТекст.remove();
			if (лПолучилось)
			{
				фВыполнить();
			}
			else
			{
				// Chrome 67 согласно текущей версии стандарта возвращает undefined.
				// Некоторые методы navigator.clipboard возвращают DOMException.
				фОтказаться();
			}
		}));
	};
}*/

function Текст(сКод, сПодстановка)
{
	return м_i18n.GetMessage(сКод, сПодстановка);
}

function Округлить(чЗначение, чТочность)
// чТочность - количество дробных знаков.
{
	Проверить(typeof чЗначение === 'number' && Number.isInteger(чТочность) && чТочность >= 0 && чТочность <= 20);
	if (чТочность === 0)
	{
		return Math.round(чЗначение);
	}
	const ч = Math.pow(10, чТочность);
	return Math.round(чЗначение * ч) / ч;
}

function Ограничить(чЗначение, чМинимум, чМаксимум)
{
	Проверить(Number.isFinite(чЗначение) && Number.isFinite(чМинимум) && Number.isFinite(чМаксимум) && чМинимум <= чМаксимум);
	return Math.min(Math.max(чЗначение, чМинимум), чМаксимум);
}

function StripHtmlTags(sText)
{
	Проверить(typeof sText === 'string');
	const elTemplate = document.createElement('template');
	// Commentary for AMO reviewers: <template> does not "load" or "execute" anything.
	elTemplate.innerHTML = sText;
	return elTemplate.content.textContent;
}

function ПреобразоватьРазметкуВТекст(сРазметка)
{
	Проверить(typeof сРазметка === 'string');
	сРазметка = сРазметка.replace(/[\t\r\n]/g, ' ').replace(/<\s*br[\s\/]*>/gi, '\n');
	сРазметка = StripHtmlTags(сРазметка);
	// Удаляет ведущие и конечные пробелы у всех строк. Удаляет пустые строки.
	сРазметка = сРазметка.replace(/^\s+|[^\S\r\n]+$/gm, '');
	return сРазметка.replace(/[^\S\r\n]{2,}/g, ' ');
}

function ResolveRelativeUrl(sRelativeUrl, sAbsoluteBaseUrl)
{
	return (new URL(sRelativeUrl, sAbsoluteBaseUrl)).href;
}

function РазобратьПараметры(оАдрес)
{
	// Edge 15 не поддерживает Location.searchParams и HTMLAnchorElement.searchParams.
	return оАдрес.searchParams || new URLSearchParams(оАдрес.search.slice(1));
}

function ИзменитьЗаголовокДокумента(сЗаголовок)
{
	// HACK Выполнить ПЕРЕД изменением заголовка, чтобы это изменение было отражено в browsing history браузера.
	history.replaceState(null, '');
	document.title = сЗаголовок;
}

function ЗаписатьТекстВЛокальныйФайл(сТекст, сТипДанных, сИмяФайла)
{
	Проверить(typeof сТекст === 'string' && ЭтоНепустаяСтрока(сТипДанных) && ЭтоНепустаяСтрока(сИмяФайла));
	const узСсылка = document.createElement('a');
	// Протокол data: оставляет в истории загрузок браузера сТекст. Не нужно нам таких подарочков.
	узСсылка.href = URL.createObjectURL(new Blob([сТекст], {type: сТипДанных}));
	узСсылка.download = сИмяФайла;
	// click() не работает пока ссылка не вставлена в документ.
	узСсылка.dispatchEvent(new MouseEvent('click'));
}

function ЭтоСобытиеДляСсылки(оСобытие)
{
	let уз = оСобытие.target;
	do
	{
		if (уз.nodeName === 'A')
		{
			return true;
		}
	}
	while (уз = уз.parentElement);
	return false;
}

function ЭлементВЭтойТочкеМожноПрокрутить(x, y)
{
	for (let узЭлемент = document.elementFromPoint(x, y); узЭлемент; узЭлемент = узЭлемент.parentElement)
	{
		if (ЭтотЭлементМожноПрокрутить(узЭлемент))
		{
			return true;
		}
	}
	return false;
}

function ЭтотЭлементМожноПрокрутить(узЭлемент)
{
	const оСтиль = getComputedStyle(узЭлемент);
	return (оСтиль.overflowY === 'scroll' || оСтиль.overflowY === 'auto') && (узЭлемент.clientHeight < узЭлемент.scrollHeight);
}

function ЭлементПолностьюПрокручен(узЭлемент)
{
	// На всякий случай сравниваем не с 0. Из-за дробных rem возможны округления и нестыковки.
	return узЭлемент.scrollHeight - узЭлемент.scrollTop - узЭлемент.clientHeight < 2;
}

function ЭтотЭлементМожноВыделить(узЭлемент)
// Firefox 59: Вопреки стандарту, getComputedStyle() не учитывает значение родительских элементов. Делаем это самостоятельно.
// https://bugzilla.mozilla.org/show_bug.cgi?id=1328475
{
	do
	{
		const оСтиль = getComputedStyle(узЭлемент);
		const сЗначение = оСтиль.getPropertyValue('user-select') || оСтиль.getPropertyValue('-webkit-user-select') || оСтиль.getPropertyValue('-moz-user-select');
		Проверить(сЗначение);
		if (сЗначение !== 'auto')
		{
			return сЗначение !== 'none';
		}
	}
	while (узЭлемент = узЭлемент.parentElement);
	return true;
}

function ПоказатьЭлемент(пЭлемент, лПоказать)
// пЭлемент может являться SVG. У SVG нет атрибута и свойства hidden, элемент скроют CSS.
{
	const узЭлемент = Узел(пЭлемент);
	if (лПоказать)
	{
		узЭлемент.removeAttribute('hidden');
	}
	else
	{
		узЭлемент.setAttribute('hidden', '');
	}
	return узЭлемент;
}

function ЭлементПоказан(пЭлемент)
{
	return !Узел(пЭлемент).hasAttribute('hidden');
}

function ИзменитьКнопку(пКнопка, пСостояние)
{
	const узКнопка = Узел(пКнопка);
	// В пСостояние может быть логическое значение.
	const чСостояние = Number(пСостояние);
	const сузСостояния = узКнопка.getElementsByTagName('use');
	Проверить(чСостояние >= 0 && чСостояние < сузСостояния.length);
	for (let ы = 0; ы < сузСостояния.length; ++ы)
	{
		if (ы === чСостояние)
		{
			// Firefox 56: <title> и xlink:title не показывают всплывающую подсказку если находятся внутри <button>.
			// Edge 15: <title> иногда пропадает после автоскрытия панели.
			const сПодсказка = сузСостояния[ы].getAttributeNS('http://www.w3.org/1999/xlink', 'title');
			if (сПодсказка)
			{
				узКнопка.title = Текст(сПодсказка);
			}
			// Edge 15 падает если во время CSS transition программно менять xlink:href.
			сузСостояния[ы].removeAttribute('display');
		}
		else
		{
			сузСостояния[ы].setAttribute('display', 'none');
		}
	}
	return узКнопка;
}

const м_Отладка = (() =>
{
	let _сСписокВариантов = '';
	let _мСпискиСегментов = [];

	function ВставитьСсылкиДляСкачиванияФайлов(узФорма)
	{
	}

	function ПоказатьСтраницу()
	{
		try
		{
			м_ПолноэкранныйРежим.Отключить();
		}
		catch (и) {}

		document.body.textContent = '';
		for (let уз of document.querySelectorAll('link[rel="stylesheet"], style'))
		{
			уз.remove();
		}
		for (let уз of [document.documentElement, document.body])
		{
			уз.removeAttribute('class');
			уз.removeAttribute('style');
			уз.removeAttribute('hidden');
		}

		return new Promise((фВыполнить, фОтказаться) =>
		{
			const уз = document.createElement('iframe');
			уз.style.position = 'fixed';
			уз.style.top      = '0';
			уз.style.left     = '0';
			уз.style.width    = '100%';
			уз.style.height   = '100%';
			уз.style.zIndex   = '100500';
			уз.style.border   = '0';
			уз.src = 'report.html';
			уз.addEventListener('load', function ОбработатьОкончаниеЗагрузки()
			{
				уз.removeEventListener('load', ОбработатьОкончаниеЗагрузки);
				м_i18n.TranslateDocument(уз.contentDocument);
				фВыполнить(уз.contentDocument);
			});
			document.body.appendChild(уз);
		});
	}

	function ПоказатьФорму(оДокумент, сИдентификаторФормы, лНастроитьФон)
	{
		if (лНастроитьФон)
		{
			// HACK Chrome 63+: Если повесить определение цвета фона на body, то у формы #отладка-сообщение
			// фон останется белым. Влияет на это центровка по вертикали и еще черт знает что.
			оДокумент.documentElement.classList.add(сИдентификаторФормы);
		}

		// Chrome 50-: Итераторы я добавил только для текущего контекста.
		// Edge 16: HTMLCollection из другого контекста (iframe) не работает в for...of.
		for (let сузПоказатьИлиСкрыть = оДокумент.forms, ы = 0, узПоказатьИлиСкрыть; узПоказатьИлиСкрыть = сузПоказатьИлиСкрыть[ы]; ++ы)
		{
			if (узПоказатьИлиСкрыть.id === сИдентификаторФормы)
			{
				ПоказатьЭлемент(узПоказатьИлиСкрыть, true);
				const узФокус = узПоказатьИлиСкрыть.querySelector('*[autofocus]');
				if (узФокус)
				{
					узФокус.focus();
				}
			}
			else
			{
				ПоказатьЭлемент(узПоказатьИлиСкрыть, false);
			}
		}
	}

	function ПоказатьСообщение(сСообщение)
	{
		ПоказатьСтраницу()
		.then(оДокумент =>
		{
			оДокумент.getElementById('отладка-текстсообщения').textContent = сСообщение;
			ПоказатьФорму(оДокумент, 'отладка-сообщение', true);
		});
	}

	function ПоказатьИОтправитьОтчет(оОтчет, буфОтправить)
	{
		ПоказатьСтраницу()
		.then(оДокумент =>
		{
			let узФорма;
			if (оОтчет.ПричинаЗавершенияРаботы === 'ОТПРАВИТЬ ОТЗЫВ')
			{
				узФорма = оДокумент.getElementById('отладка-отзыв');
			}
			else
			{
				узФорма = оДокумент.getElementById('отладка-ошибка');
				ВставитьСсылкиДляСкачиванияФайлов(узФорма);
			}
			узФорма.elements["отладка-отчет"].value = JSON.stringify(оОтчет);
			ПоказатьФорму(оДокумент, узФорма.id, true);

			оДокумент.addEventListener('reset', оСобытие =>
			{
				оСобытие.preventDefault();
				window.location.reload();
			});

			let оЗапрос, оДанные, лПолучилось = false;
			// Нажимать кнопки можно клавишей ENTER.
			оДокумент.addEventListener('submit', оСобытие =>
			{
				оСобытие.preventDefault();
				switch (оСобытие.target.id)
				{
				case 'отладка-идетотправка':
					лПолучилось = true;
					// Синхронно вызывает обработчик события loadend.
					оЗапрос.abort();
					break;

				case 'отладка-сбойотправки':
					узФорма.querySelector('*[type="submit"]').click();
					break;

				default:
					оДокумент.getElementById('отладка-ходотправки').value = 0;
					ПоказатьФорму(оДокумент, 'отладка-идетотправка', false);
		
					if (!оЗапрос)
					{
						оЗапрос = new XMLHttpRequest();
						оЗапрос.upload.addEventListener('progress', оСобытие =>
						{
							оДокумент.getElementById('отладка-ходотправки').value = оСобытие.loaded / оСобытие.total;
						});
						оЗапрос.addEventListener('load', оСобытие =>
						{
							лПолучилось = оСобытие.target.status >= 200 && оСобытие.target.status <= 299;
							// Ждем loadend.
						});
						оЗапрос.addEventListener('loadend', () =>
						{
							if (лПолучилось)
							{
								window.location.reload();
							}
							else
							{
								ПоказатьФорму(оДокумент, 'отладка-сбойотправки', false);
							}
						});

						оДанные = new FormData(оСобытие.target);
						if (буфОтправить)
						{
							оДанные.append('отладка-транспортныйпоток-0', new Blob([буфОтправить], {type: 'video/mp2t'}));
						}
					}

					оЗапрос.open('POST', 'http://r90354g8.beget.tech/tw5/report3.php');
					оЗапрос.send(оДанные);
				}
			});
		});
	}

	function СохранитьСписокВариантов(сСписокВариантов)
	{
		_сСписокВариантов = ОграничитьДлинуСтроки(сСписокВариантов, 15000);
	}

	function СохранитьСписокСегментов(сСписокСегментов)
	{
		if (_мСпискиСегментов.length === 3)
		{
			_мСпискиСегментов.shift();
		}
		_мСпискиСегментов.push(ОграничитьДлинуСтроки(сСписокСегментов, 15000));
	}

	function СохранитьТранспортныйПоток(оСегмент)
	{
	}

	function СохранитьПреобразованныйСегмент(оСегмент)
	{
	}

	function ОбнюхатьПроцессорИОперативку(фВызвать)
	{
		try
		{
			chrome.system.cpu.getInfo(оПроцессор =>
			{
				try
				{
					chrome.system.memory.getInfo(оОперативка =>
					{
						фВызвать([оПроцессор, оОперативка]);
					});
				}
				catch (и)
				{
					фВызвать();
				}
			});
		}
		catch (и)
		{
			фВызвать();
		}
	}

	function ОбнюхатьВидюху()
	{
		try
		{
			const oContext = document.createElement('canvas').getContext('webgl');
			const oExtension = oContext.getExtension('WEBGL_debug_renderer_info');
			return `${oContext.getParameter(oExtension.UNMASKED_VENDOR_WEBGL)} | ${oContext.getParameter(oExtension.UNMASKED_RENDERER_WEBGL)}`;
		}
		catch (и) {}
	}

	function ПолучитьЯзыки()
	{
		try
		{
			return `${navigator.language} | ${navigator.languages} | ${Текст('J0103')}`;
		}
		catch (и) {}
	}

	function СоздатьПоказатьИОтправитьОтчет(сПричинаЗавершенияРаботы, буфОтправить)
	{
		ОбнюхатьПроцессорИОперативку(пПроцессорИОперативка =>
		{
			ПоказатьИОтправитьОтчет(
				// В JSON не попадут свойства со значением undefined.
				{
					ПричинаЗавершенияРаботы:  сПричинаЗавершенияРаботы,
					ВерсияРасширения:         ВЕРСИЯ_РАСШИРЕНИЯ,
					Оборзеватель:             navigator.userAgent,
					Время:                    (new Date()).toISOString(),
					Адрес:                    window.location.href,
					Инкогнито:                chrome.extension.inIncognitoContext,
					Языки:                    ПолучитьЯзыки(),
					Фокусник:                 м_Фокусник.ПолучитьСостояние(),
					Пульс:                    м_Пульс.ПолучитьДанныеДляОтчета(),
					Настройки:                м_Настройки.ПолучитьДанныеДляОтчета(),
					Статистика:               м_Статистика.ПолучитьДанныеДляОтчета(),
					Видюха:                   ОбнюхатьВидюху(),
					ПроцессорИОперативка:     пПроцессорИОперативка,
					Экран:
					{
						top:                  window.screen.top,
						left:                 window.screen.left,
						width:                window.screen.width,
						height:               window.screen.height,
						availTop:             window.screen.availTop,
						availLeft:            window.screen.availLeft,
						availWidth:           window.screen.availWidth,
						availHeight:          window.screen.availHeight,
						// Firefox 47 Windows: Возвращает реальные значения.
						// Chrome 51 Windows: Всегда возвращает 24.
						colorDepth:           window.screen.colorDepth,
						pixelDepth:           window.screen.pixelDepth,
						orientation:          typeof window.screen.orientation === 'object' ? window.screen.orientation.type : undefined,
						screenX:              window.screenX,
						screenY:              window.screenY,
						outerWidth:           window.outerWidth,
						outerHeight:          window.outerHeight,
						innerWidth:           window.innerWidth,
						innerHeight:          window.innerHeight,
						devicePixelRatio:     window.devicePixelRatio
					},
					СписокВариантов:          _сСписокВариантов,
					СпискиСегментов:          _мСпискиСегментов,
					Журнал:                   м_Журнал.ПолучитьДанныеДляОтчета()
				},
				буфОтправить
			);
		});
	}

	function ЗавершитьРаботуИПоказатьСообщение(сКодСообщения)
	{
		if (!г_лРаботаЗавершена)
		{
			console.error(сКодСообщения);
			ЗавершитьРаботу(false);
			ПоказатьСообщение(Текст(сКодСообщения));
		}
		throw undefined;
	}

	function ЗавершитьРаботуИОтправитьОтчет(сПричинаЗавершенияРаботы, буфОтправить)
	{
		if (!г_лРаботаЗавершена)
		{
			console.error(сПричинаЗавершенияРаботы);
			сПричинаЗавершенияРаботы = String(сПричинаЗавершенияРаботы);
			// Firefox 47 x86 + Windows + XUL: При нехватке памяти (commit) может кинуть исключение out of memory в player.js, worker.js и worker.onerror.
			// Chrome 52 x64 + Windows: При нехватке памяти (commit) процесс сразу падает.
			if (сПричинаЗавершенияРаботы.includes('out of memory'))
			{
				ЗавершитьРаботуИПоказатьСообщение('J0200');
			}
			try
			{
				м_Проигрыватель.ПоказатьСостояние('Вот', '[Отладка] Завершаю работу');
				г_моОчередь.ПоказатьСостояние();
			}
			catch (и) {}
			ЗавершитьРаботу(false);
			СоздатьПоказатьИОтправитьОтчет(сПричинаЗавершенияРаботы, буфОтправить);
		}
		throw undefined;
	}

	function ПойманоИсключение(пИсключение)
	{
		ЗавершитьРаботуИОтправитьОтчет(
			пИсключение instanceof Error ? пИсключение.stack
			: `[typeof ${typeof пИсключение}] ${new Error(пИсключение).stack}`
		);
	}

	function ЗавершитьРаботуИОтправитьОтзыв()
	{
		try
		{
			ЗавершитьРаботуИОтправитьОтчет('ОТПРАВИТЬ ОТЗЫВ');
		}
		catch (и) {}
	}


	return {
		ЗавершитьРаботуИПоказатьСообщение, ЗавершитьРаботуИОтправитьОтчет, ЗавершитьРаботуИОтправитьОтзыв,
		ПойманоИсключение,
		СохранитьСписокВариантов, СохранитьСписокСегментов, СохранитьТранспортныйПоток, СохранитьПреобразованныйСегмент
	};
})();

//
// ОтменаОбещания
//

function ОтменаОбещания()
{
	this._лВыполняется = false; // Для отладки.
	this._фОбработчик = null;
}

// TODO new DOMException('', 'AbortError') пока есть только в черновиках стандарта.
// Сообщение нам не нужно, поэтому используем более простой вариант.
ОтменаОбещания.ОБЕЩАНИЕ_ОТМЕНЕНО = new Error('ОБЕЩАНИЕ ОТМЕНЕНО');

ОтменаОбещания.prototype.НачалоВыполнения = function()
{
	Проверить(!this._лВыполняется);
	this._лВыполняется = true;
};

ОтменаОбещания.prototype.Отменить = function()
{
	this._лВыполняется = false;
	if (this._фОбработчик)
	{
		this._фОбработчик();
		this._фОбработчик = null;
	}
};
	
ОтменаОбещания.prototype.ЗаменитьОбработчик = function(фОбработчик)
{
	Проверить(this._лВыполняется);
	Проверить(typeof фОбработчик === 'function' || фОбработчик === null);
	this._фОбработчик = фОбработчик;
};

function Ждать(ооОтменаОбещания, чМиллисекунды)
{
	Проверить(Number.isFinite(чМиллисекунды));
	чМиллисекунды = Math.round(чМиллисекунды);
	Проверить(чМиллисекунды >= 0 && чМиллисекунды <= 0x7fffffff);
	// Если чМиллисекунды == 0, то нельзя вместо setTimeout() вызывать Promise.resolve(),
	// потому что это помешает отменить обещание сразу после вызова Ждать().
	return new Promise((фВыполнить, фОтказаться) =>
	{
		const чТаймер = setTimeout(фВыполнить, чМиллисекунды);
		if (ооОтменаОбещания)
		{
			ооОтменаОбещания.ЗаменитьОбработчик(() =>
			{
				clearTimeout(чТаймер);
				фОтказаться(ОтменаОбещания.ОБЕЩАНИЕ_ОТМЕНЕНО);
			});
		}
	});
}

//
// Сегмент
//

function Сегмент(чОбработка, пДанные, чДлительность, лРазрыв, чTwitchПрошлоВремени, чНомер)
{
	Проверить(typeof чОбработка === 'number' && чОбработка >= ОБРАБОТКА_ЖДЕТ_ЗАГРУЗКИ && чОбработка <= ОБРАБОТКА_ПРЕОБРАЗОВАН);
	Проверить((typeof пДанные === 'number' && чОбработка >= ОБРАБОТКА_ЗАГРУЖЕН)
		|| (typeof пДанные === 'string' && чОбработка === ОБРАБОТКА_ЖДЕТ_ЗАГРУЗКИ)
		|| (ЭтоОбъект(пДанные) && чОбработка > ОБРАБОТКА_ЖДЕТ_ЗАГРУЗКИ));

	switch (arguments.length)
	{
	case 2:
		чДлительность = 0;
		лРазрыв = true;
		чTwitchПрошлоВремени = NaN;
		//
	case 5:
		Проверить(Number.isFinite(чДлительность) && чДлительность >= 0);
		Проверить(typeof лРазрыв === 'boolean');
		Проверить(typeof чTwitchПрошлоВремени === 'number');
		чНомер = ++Сегмент._чНомер
		//
	case 6:
		Проверить(Number.isFinite(чНомер));
		break;

	default:
		Проверить(false);
	}

	if (typeof пДанные === 'number')
	{
		м_Журнал.Окак(`[Очередь] Добавлен сегмент ${чНомер} Состояние=${пДанные} Обработка=${чОбработка}`);
	}

	this.чОбработка = чОбработка;
	this.пДанные = пДанные;
	this.чДлительность = чДлительность;
	this.лРазрыв = лРазрыв;
	this.чTwitchПрошлоВремени = чTwitchПрошлоВремени;
	this.чНомер = чНомер;
}

Сегмент._чНомер = 0;

Сегмент.prototype.toString = function()
{
	if (typeof this.пДанные === 'number')
	{
		return `${this.чНомер}-${this.чОбработка}-${this.пДанные}`;
	}
	if (this.лРазрыв)
	{
		return `${this.чНомер}-${this.чОбработка}-Р`;
	}
	return `${this.чНомер}-${this.чОбработка}`;
};

//
// г_моОчередь
//

let г_моОчередь = [];

г_моОчередь.ПолучитьКоличествоПреобразованныхСегментов = function()
{
	let кКоличество = 0, чДлительность = 0;
	for (; кКоличество < this.length && this[кКоличество].чОбработка === ОБРАБОТКА_ПРЕОБРАЗОВАН; ++кКоличество)
	{
		if (typeof this[кКоличество].пДанные !== 'number')
		{
			чДлительность += this[кКоличество].чДлительность;
		}
	}
	return {кКоличество, чДлительность};
};

г_моОчередь.Добавить = function(оСегмент)
{
	Проверить(оСегмент instanceof Сегмент);
	for (let о of this)
	{
		Проверить(о.чНомер !== оСегмент.чНомер);
	}
	if (оСегмент.чОбработка !== ОБРАБОТКА_ПРЕОБРАЗОВАН)
	{
		// Сегменты хранятся в очереди в порядке добавления, не в порядке обработки.
		this.push(оСегмент);
	}
	else
	{
		const {кКоличество, чДлительность} = this.ПолучитьКоличествоПреобразованныхСегментов();
		// Сегменты воспроизводятся медленнее, чем загружаются. Возможные причины:
		// - Остановка воспроизведения из-за ошибки браузера после endOfStream().
		// - Chrome 57-58: Очень медленная работа appendBuffer() из-за ошибки браузера во время работы в фоновой вкладке.
		if (чДлительность > ПЕРЕПОЛНЕНИЕ_БУФЕРА * 1.5)
		{
			м_Отладка.ЗавершитьРаботуИПоказатьСообщение('J0208');
		}
		this.splice(кКоличество, 0, оСегмент);
	}
	return оСегмент;
};

г_моОчередь.Удалить = function(пЭлемент, кКоличество = 1)
{
	if (кКоличество === 0)
	{
		return;
	}
	Проверить(Number.isInteger(кКоличество) && кКоличество > 0);

	let чИндекс;
	if (typeof пЭлемент === 'number')
	{
		Проверить(Number.isInteger(пЭлемент) && пЭлемент >= 0);
		чИндекс = пЭлемент;
	}
	else if ((чИндекс = this.indexOf(пЭлемент)) === -1)
	{
		Проверить(пЭлемент instanceof Сегмент);
		return;
	}

	while (--кКоличество >= 0)
	{
		Проверить(чИндекс < this.length);

		switch (this[чИндекс].чОбработка)
		{
		case ОБРАБОТКА_ЗАГРУЖАЕТСЯ:
			if (ЭтоОбъект(this[чИндекс].пДанные))
			{
				м_Журнал.Вот(`[Очередь] Отменяю загрузку ${this[чИндекс]}`);
				this[чИндекс].пДанные.Отменить();
			}
			break;

		case ОБРАБОТКА_ЗАГРУЖЕН:
			м_Помойка.Выбросить(this[чИндекс].пДанные);
			break;

		case ОБРАБОТКА_ПРЕОБРАЗОВАН:
			if (ЭтоОбъект(this[чИндекс].пДанные))
			{
				м_Помойка.Выбросить(this[чИндекс].пДанные.мбСегментИнициализации);
				м_Помойка.Выбросить(this[чИндекс].пДанные.мбМедиасегмент);
			}
			break;
		}

		м_Журнал.Вот(`[Очередь] Удаляю ${this[чИндекс]}`);
		this.splice(чИндекс, 1);
	}
};

г_моОчередь.Очистить = function()
{
	this.Удалить(0, this.length);
};

г_моОчередь.ПоказатьСостояние = function()
{
	м_Журнал.Вот(`[Очередь] ${this.join(' ')}`);
};

//
// ВводЧисла
//

function ВводЧисла(сИмяНастройки, чШаг, чТочность, сУзел)
{
	Проверить(чТочность >= 0);

	this._сИмяНастройки = сИмяНастройки;
	this._оПараметрыНастройки = м_Настройки.ПолучитьПараметрыНастройки(сИмяНастройки);
	this._чШаг = чШаг;
	this._чТочность = чТочность;

	this._чТаймер   = 0;
	this._кИнтервал = 0;
	this._чДобавить = 0;

	this._узУзел = Узел(сУзел);
	this._узУзел.addEventListener('mousedown', this);

	this._Показать();
}

ВводЧисла.prototype._Показать = function(чЗначение = м_Настройки.Получить(this._сИмяНастройки))
{
	this._узУзел.children[1].value = чЗначение === АВТОНАСТРОЙКА
		? Текст(this._оПараметрыНастройки.сАвтонастройка)
		: м_i18n.ФорматироватьЧисло(чЗначение, this._чТочность);
};

ВводЧисла.prototype.handleEvent = ДобавитьОбработчикИсключений(function(оСобытие)
{
	const ИНТЕРВАЛ_ИЗМЕНЕНИЯ_ЗНАЧЕНИЯ = 130; // Миллисекунды.

	switch (оСобытие.type)
	{
	case 'mousedown':
		if (оСобытие.button === ЛЕВАЯ_КНОПКА && this._чТаймер === 0 && м_Фокусник.ПолучитьСостояние().лАктивен)
		{
			switch (оСобытие.target.className)
			{
				case 'вводчисла-минус': this._чДобавить = -this._чШаг; break;
				case 'вводчисла-плюс':  this._чДобавить =  this._чШаг; break;
				default: return;
			}
			document.addEventListener('mouseup', this);
			м_События.ДобавитьОбработчик('фокусник-изменилосьсостояние', this);
			this._кИнтервал = 0;
			this._чТаймер = setInterval(() => this._ОбработатьТаймер(), ИНТЕРВАЛ_ИЗМЕНЕНИЯ_ЗНАЧЕНИЯ);
			this._ОбработатьТаймер();
		}
		return;

	case 'фокусник-изменилосьсостояние':
		if (оСобытие.data.лАктивен)
		{
			return;
		}
		break;
	}
			
	// Реагируем на отпускание любой кнопки.
	if (this._чТаймер !== 0)
	{
		document.removeEventListener('mouseup', this);
		м_События.УдалитьОбработчик('фокусник-изменилосьсостояние', this);
		clearInterval(this._чТаймер);
		this._чТаймер = 0;
	}
});

ВводЧисла.prototype._ОбработатьТаймер = ДобавитьОбработчикИсключений(function()
{
	const ЗАДЕРЖКА_ИЗМЕНЕНИЯ_ЗНАЧЕНИЯ = 3; // Количество ИНТЕРВАЛ_ИЗМЕНЕНИЯ_ЗНАЧЕНИЯ.

	if (++this._кИнтервал === 1 || this._кИнтервал > ЗАДЕРЖКА_ИЗМЕНЕНИЯ_ЗНАЧЕНИЯ)
	{
		const чЗначение = м_Настройки.Получить(this._сИмяНастройки);
		let чНовоеЗначение;
		if ((this._оПараметрыНастройки.сАвтонастройка && this._чДобавить < 0 && чЗначение === this._оПараметрыНастройки.чМинимальное)
		||  (this._оПараметрыНастройки.сАвтонастройка && this._чДобавить > 0 && чЗначение === this._оПараметрыНастройки.чМаксимальное))
		{
			чНовоеЗначение = АВТОНАСТРОЙКА;
		}
		else if (чЗначение === АВТОНАСТРОЙКА && this._чДобавить > 0)
		{
			чНовоеЗначение = this._оПараметрыНастройки.чМинимальное;
		}
		else if (чЗначение === АВТОНАСТРОЙКА && this._чДобавить < 0)
		{
			чНовоеЗначение = this._оПараметрыНастройки.чМаксимальное;
		}
		else
		{
			чНовоеЗначение = чЗначение + this._чДобавить;
		}
		if (чНовоеЗначение !== АВТОНАСТРОЙКА)
		{
			чНовоеЗначение = Ограничить(Округлить(чНовоеЗначение, this._чТочность), this._оПараметрыНастройки.чМинимальное, this._оПараметрыНастройки.чМаксимальное);
		}
		if (чНовоеЗначение !== чЗначение)
		{
			м_Настройки.Изменить(this._сИмяНастройки, чНовоеЗначение);
			this._Показать(чНовоеЗначение);
			this.ПослеИзменения(чНовоеЗначение);
		}
	}
});

ВводЧисла.prototype.Обновить = function()
// Вызвать, если настройка, к которой привязан объект, была изменена.
{
	this._Показать();
};

ВводЧисла.prototype.ПослеИзменения = ЗАГЛУШКА;

const м_События = (() =>
{
	let _амОбработчики = new Map();

	function ДобавитьОбработчик(сСобытие, фОбработчик)
	{
		Проверить(ЭтоНепустаяСтрока(сСобытие));
		Проверить(typeof фОбработчик === 'function' || ЭтоОбъект(фОбработчик));
		let мноОбработчикиСобытия = _амОбработчики.get(сСобытие);
		if (мноОбработчикиСобытия === undefined)
		{
			мноОбработчикиСобытия = new Set();
			_амОбработчики.set(сСобытие, мноОбработчикиСобытия);
		}
		мноОбработчикиСобытия.add(фОбработчик);
	}

	function УдалитьОбработчик(сСобытие, фОбработчик)
	{
		Проверить(ЭтоНепустаяСтрока(сСобытие));
		Проверить(typeof фОбработчик === 'function' || ЭтоОбъект(фОбработчик));
		const мноОбработчикиСобытия = _амОбработчики.get(сСобытие);
		if (мноОбработчикиСобытия !== undefined)
		{
			мноОбработчикиСобытия.delete(фОбработчик);
			if (мноОбработчикиСобытия.size === 0)
			{
				_амОбработчики.delete(сСобытие);
			}
		}
	}

	function ОбработатьСобытие(сСобытие, пДанные)
	{
		Проверить(ЭтоНепустаяСтрока(сСобытие));
		м_Журнал.Вот(`[События] Произошло событие ${сСобытие}`);
		const мноОбработчикиСобытия = _амОбработчики.get(сСобытие);
		if (мноОбработчикиСобытия !== undefined)
		{
			Проверить(мноОбработчикиСобытия.size !== 0);
			let оСобытие;
			for (let фОбработчик of мноОбработчикиСобытия.values())
			{
				if (typeof фОбработчик === 'function')
				{
					// сСобытие используется очень редко.
					фОбработчик(пДанные, сСобытие);
				}
				else
				{
					if (оСобытие === undefined)
					{
						оСобытие =
						{
							type: сСобытие,
							data: пДанные
						};
					}
					фОбработчик.handleEvent(оСобытие);
				}
			}
		}
	}

	return {
		ДобавитьОбработчик,
		УдалитьОбработчик,
		ОбработатьСобытие
	};
})();

const м_Помойка = (() =>
{
	function ПомойкаВКаналеСообщений()
	{
		this._оПомойка = null;
	}

	ПомойкаВКаналеСообщений.prototype.Выбросить = function(оБарахло)
	// HACK Освобождение памяти посылкой transferable буфера в disentangled порт.
	// https://html.spec.whatwg.org/multipage/comms.html#dom-messageport-postmessage
	{
		if (ЭтоОбъект(оБарахло))
		{
			if (оБарахло.buffer)
			{
				оБарахло = оБарахло.buffer;
			}
			if (оБарахло.byteLength)
			{
				м_Журнал.Вот(`[Помойка] Выбрасываю ${оБарахло.byteLength} байтов`);
				if (this._оПомойка === null)
				{
					this._оПомойка = new MessageChannel();
					this._оПомойка.port2.close();
				}
				this._оПомойка.port1.postMessage(оБарахло, [оБарахло]);
			}
		}
	};

	ПомойкаВКаналеСообщений.prototype.Сжечь = function()
	{
		this._оПомойка = null;
	};

	function ПомойкаВРабочемПотоке()
	{
		this._сАдрес = '';
		this._оПомойка = null;
		this._кбВПомойке = 0;
	}

	ПомойкаВРабочемПотоке.prototype.Выбросить = function(оБарахло)
	// HACK Для освобождение памяти transferable буфер посылается в рабочий поток, затем рабочий
	// поток уничтожается, что приводит к быстрому сбору всего мусора, который в нем накопился.
	{
		const ВМЕСТИМОСТЬ_ПОМОЙКИ = 10000000; // Байты.
		if (ЭтоОбъект(оБарахло))
		{
			if (оБарахло.buffer)
			{
				оБарахло = оБарахло.buffer;
			}
			if (оБарахло.byteLength)
			{
				м_Журнал.Вот(`[Помойка] Выбрасываю ${оБарахло.byteLength} байтов`);
				if (this._оПомойка === null)
				{
					if (this._сАдрес === '')
					{
						this._сАдрес = URL.createObjectURL(new Blob(
							[`
								'use strict';
								self.onmessage = оСобытие =>
								{
									if (!оСобытие.data)
									{
										self.close();
									}
								};
							`],
							{type: 'application/javascript'}
						));
					}
					this._оПомойка = new Worker(this._сАдрес);
				}
				this._кбВПомойке += оБарахло.byteLength;
				this._оПомойка.postMessage(оБарахло, [оБарахло]);
				if (this._кбВПомойке > ВМЕСТИМОСТЬ_ПОМОЙКИ)
				{
					this.Сжечь();
				}
			}
		}
	};

	ПомойкаВРабочемПотоке.prototype.Сжечь = function()
	{
		if (this._оПомойка !== null)
		{
			м_Журнал.Вот(`[Помойка] Сжигаю ${this._кбВПомойке} байтов`);
			// terminate() не подходит, нужно дождаться когда барахло попадет в рабочий поток.
			this._оПомойка.postMessage(null);
			this._оПомойка = null;
			this._кбВПомойке = 0;
		}
	};

	function ПомойкаОтсутствует() {}
	ПомойкаОтсутствует.prototype.Выбросить = ЗАГЛУШКА;
	ПомойкаОтсутствует.prototype.Сжечь = ЗАГЛУШКА;

	м_События.ДобавитьОбработчик('управление-изменилосьсостояние', чСостояние =>
	{
		if (чСостояние === СОСТОЯНИЕ_ЗАВЕРШЕНИЕ_ТРАНСЛЯЦИИ || чСостояние === СОСТОЯНИЕ_ОСТАНОВКА || чСостояние === СОСТОЯНИЕ_ПОВТОР)
		{
			м_Помойка.Сжечь();
		}
	});

	// В Chrome 64 уже нет проблем с освобожданием памяти. Точно не знаю в какой версии это исправили.
	return ВЕРСИЯ_ДВИЖКА_БРАУЗЕРА >= 64 ? new ПомойкаОтсутствует() : new ПомойкаВРабочемПотоке();
})();

const м_Фокусник = (() =>
{
	let _оСостояние = ПолучитьНовоеСостояние();

	function ПолучитьСостояние()
	{
		return _оСостояние;
	}

	function ПолучитьНовоеСостояние()
	{
		const лПоказан = !document.hidden;
		const лАктивен = лПоказан && document.hasFocus();
		return {лПоказан, лАктивен};
	}

	const ОбработатьСобытие = ДобавитьОбработчикИсключений(оСобытие =>
	{
		м_Журнал.Вот(`[Фокусник] Событие ${оСобытие.type}, старое состояние ${м_Журнал.O(_оСостояние)}`);
		// HACK Chrome 65-: https://bugs.chromium.org/p/chromium/issues/detail?id=654908
		// HACK Firefox 60: Нужно дать браузеру время на разблокировку воспроизведения в м_Проигрыватель.Запустить().
		setImmediate(ОбновитьСостояние);
	});

	const ОбновитьСостояние = ДобавитьОбработчикИсключений(() =>
	{
		const оНовоеСостояние = ПолучитьНовоеСостояние();
		if (_оСостояние.лПоказан !== оНовоеСостояние.лПоказан || _оСостояние.лАктивен !== оНовоеСостояние.лАктивен)
		{
			м_Журнал.Окак(`[Фокусник] Новое состояние ${м_Журнал.O(оНовоеСостояние)}`);
			_оСостояние = оНовоеСостояние;
			м_События.ОбработатьСобытие('фокусник-изменилосьсостояние', оНовоеСостояние);
		}
	});

	м_Журнал.Вот(`[Фокусник] Начальное состояние ${м_Журнал.O(_оСостояние)}`);
	document.addEventListener('visibilitychange', ОбработатьСобытие);
	window.addEventListener('focus', ОбработатьСобытие);
	window.addEventListener('blur', ОбработатьСобытие);

	return {ПолучитьСостояние};
})();

const м_Пульс = (() =>
{
	// Если вкладка неактивна и в ней не воспроизводится видео/звук, то интервал таймера округляется до ближайшей целой секунды.
	// Edge 16 и Chrome 49 не учитывают воспроизведение видео/звука. Firefox 52 только увеличивает до 1 секунды.
	const ИНТЕРВАЛ_ПРОВЕРКИ       = 970;
	const МИН_ОТКЛОНЕНИЕ_ВРЕМЕНИ  = -30;
	const МАКС_ОТКЛОНЕНИЕ_ВРЕМЕНИ = 200;
	const МАКС_ОТКЛОНЕНИЕ_ДАТЫ    = 40;

	let _чМаксимальноеОтклонение = 0;
	let _чТаймер = 0;
	let _чВремя;
	let _чДата;

	const ПроверитьПульс = ДобавитьОбработчикИсключений(() =>
	{
		const чВремя = performance.now();
		const чДата = Date.now();
		const чОтклонениеВремени = чВремя - _чВремя - ИНТЕРВАЛ_ПРОВЕРКИ;
		const чОтклонениеДаты = чДата - _чДата - (чВремя - _чВремя);
		if (чОтклонениеВремени < МИН_ОТКЛОНЕНИЕ_ВРЕМЕНИ || чОтклонениеВремени > МАКС_ОТКЛОНЕНИЕ_ВРЕМЕНИ || Math.abs(чОтклонениеДаты) > МАКС_ОТКЛОНЕНИЕ_ДАТЫ)
		{
			м_Журнал.Ой(`[Пульс] ${м_Журнал.F0(чОтклонениеВремени)} ${м_Журнал.F0(чОтклонениеДаты)}`);
		}
		_чМаксимальноеОтклонение = Math.max(_чМаксимальноеОтклонение, чОтклонениеВремени);
		_чВремя = чВремя;
		_чДата = чДата;
		_чТаймер = setTimeout(ПроверитьПульс, ИНТЕРВАЛ_ПРОВЕРКИ);
	});

	function ОбработатьИзменениеСостояния(чСостояние)
	{
		if (чСостояние === СОСТОЯНИЕ_ЗАВЕРШЕНИЕ_ТРАНСЛЯЦИИ || чСостояние === СОСТОЯНИЕ_ОСТАНОВКА || чСостояние === СОСТОЯНИЕ_ПОВТОР)
		{
			if (_чТаймер !== 0)
			{
				м_Журнал.Вот('[Пульс] Таймер остановлен');
				clearTimeout(_чТаймер);
				_чТаймер = 0;
			}
		}
		else
		{
			if (_чТаймер === 0)
			{
				м_Журнал.Вот('[Пульс] Таймер запущен');
				_чВремя = performance.now();
				_чДата = Date.now();
				_чТаймер = setTimeout(ПроверитьПульс, ИНТЕРВАЛ_ПРОВЕРКИ);
			}
		}
	}

	function ПолучитьДанныеДляОтчета()
	{
		return _чМаксимальноеОтклонение;
	}

	м_События.ДобавитьОбработчик('управление-изменилосьсостояние', ОбработатьИзменениеСостояния);

	return {ПолучитьДанныеДляОтчета};
})();

const м_Тащилка = (() =>
// Edge 16, вопреки стандарту, во время перетаскивания не подавляет события клавиатуры.
{
	const МИН_ИНТЕРВАЛ_DRAGOVER = 45; // Миллисекунды.

	let _узТащится = null;
	let _оПараметры = null;
	let _чВремяПоследнегоDragOver;
	let _чНачальнаяX, _чНачальнаяY;
	let _чПоследняяX, _чПоследняяY;

	function ОбработатьИзменениеПоложенияОкна(оПараметры)
	{
		Проверить(оПараметры === _оПараметры);
		switch (оПараметры.чШаг)
		{
		case 1:
			const оСтиль = getComputedStyle(оПараметры.узТащится);
			оПараметры._чНачальнаяX = Number.parseInt(оСтиль.left, 10);
			оПараметры._чНачальнаяY = Number.parseInt(оСтиль.top,  10);
			break;

		case 2:
			оПараметры.узТащится.style.left = `${оПараметры._чНачальнаяX + оПараметры.чИзменениеX}px`;
			оПараметры.узТащится.style.top  = `${оПараметры._чНачальнаяY + оПараметры.чИзменениеY}px`;
			break;

		case 3:
			break;

		default:
			Проверить(false);
		}
	}

	const ОбработатьDragStart = ДобавитьОбработчикИсключений(оСобытие =>
	{
		// Firefox 59: По непонятной причине могут прийти два подряд события dragstart.
		if (_узТащится)
		{
			м_Журнал.Ой(`[Тащилка] Перетаскивание началось заново на шаге ${_оПараметры.чШаг}`);
			ЗавершитьПеретаскивание(true);
			return;
		}

		// Тащить могут ссылку, текст, и даже кнопку из панели инструментов (Firefox 44).
		// Элементы, перетаскивание которых обрабатывает м_Тащилка, помечены атрибутом draggable.
		if (оСобытие.target.nodeType === Node.ELEMENT_NODE
		&&  оСобытие.target.getAttribute('draggable') === 'true')
		{
			_узТащится = оСобытие.target;
			_оПараметры = {узТащится: _узТащится};
			_чВремяПоследнегоDragOver = 0;
			_чНачальнаяX = _чПоследняяX = оСобытие.clientX;
			_чНачальнаяY = _чПоследняяY = оСобытие.clientY;

			Проверить(_узТащится.id);
			м_Журнал.Окак(`[Тащилка] Начинаю тащить ${_узТащится.id} X=${_чНачальнаяX} Y=${_чНачальнаяY}`);

			_узТащится.classList.add('тащилка-элемент');
			// Задержка для Chrome 59. Другим браузерам тоже не повредит.
			setImmediate(() =>
			{
				if (_узТащится)
				{
					document.body.classList.add('тащилка-страница');
				}
			});

			_оПараметры.чШаг = 1;
			м_События.ОбработатьСобытие(`тащилка-перетаскивание-${_узТащится.id}`, _оПараметры);

			// Обработчик вызвал ОтменитьПеретаскивание()?
			if (!_узТащится)
			{
				оСобытие.preventDefault();
				return;
			}

			// Firefox 44: Без этой строки перетаскивание не начнется.
			// Edge 15 поддерживает только текст.
			оСобытие.dataTransfer.setData('text', '');
			оСобытие.dataTransfer.effectAllowed = 'move';
			// Не рисовать перетаскиваемый элемент.
			if (оСобытие.dataTransfer.setDragImage)
			{
				// document.head невидимый.
				оСобытие.dataTransfer.setDragImage(document.head, 0, 0);
			}
			else
			{
				// HACK Edge 15 не поддерживает setDragImage(). Кратковременное скрытие выглядит
				// не слишком красиво, но это единственный способ.
				_узТащится.classList.add('тащилка-скрыть');
				setImmediate(() =>
				{
					// Переменная _узТащится уже может быть изменена.
					оСобытие.target.classList.remove('тащилка-скрыть');
				});
			}
		}
	});

	const ОбработатьDragEnterИDrop = ДобавитьОбработчикИсключений(оСобытие =>
	{
		if (_узТащится)
		{
			оСобытие.preventDefault();
		}
	});

	const ОбработатьDragOver = ДобавитьОбработчикИсключений(оСобытие =>
	{
		if (!_узТащится)
		{
			return;
		}

		// Как и mousemove, событие dragover может посылаться с очень высокой
		// частотой, не давая процессору заниматься более важными вещами.
		const чВремя = performance.now();
		if (чВремя - _чВремяПоследнегоDragOver >= МИН_ИНТЕРВАЛ_DRAGOVER)
		{
			_чВремяПоследнегоDragOver = чВремя;

			_оПараметры.лИзмениласьX = _чПоследняяX !== оСобытие.clientX;
			_оПараметры.лИзмениласьY = _чПоследняяY !== оСобытие.clientY;
			if (_оПараметры.лИзмениласьX || _оПараметры.лИзмениласьY)
			{
				_чПоследняяX = оСобытие.clientX;
				_чПоследняяY = оСобытие.clientY;

				_оПараметры.чШаг = 2;
				_оПараметры.чИзменениеX = _чПоследняяX - _чНачальнаяX;
				_оПараметры.чИзменениеY = _чПоследняяY - _чНачальнаяY;
				м_События.ОбработатьСобытие(`тащилка-перетаскивание-${_узТащится.id}`, _оПараметры);
			}
		}

		// Обработчик не вызвал ОтменитьПеретаскивание()?
		if (_узТащится)
		{
			оСобытие.preventDefault();
		}
	});

	const ОбработатьDragEnd = ДобавитьОбработчикИсключений(оСобытие =>
	{
		if (_узТащится)
		{
			м_Журнал.Окак(`[Тащилка] Заканчиваю тащить ${_узТащится.id} X=${_чПоследняяX} Y=${_чПоследняяY} dropEffect=${оСобытие.dataTransfer.dropEffect}`);
			// Firefox 59: dropEffect всегда не равен none.
			// Edge 16: dropEffect всегда равен none.
			ЗавершитьПеретаскивание(false);
		}
	});

	function ОтменитьПеретаскивание(сИдентификаторУзла)
	{
		Проверить(сИдентификаторУзла === undefined || ЭтоНепустаяСтрока(сИдентификаторУзла));
		if (_узТащится && (сИдентификаторУзла === undefined || сИдентификаторУзла === _узТащится.id))
		{
			м_Журнал.Окак(`[Тащилка] Отказываюсь тащить ${_узТащится.id}`);
			ЗавершитьПеретаскивание(true);
		}
	}

	function ЗавершитьПеретаскивание(лОтмена)
	// В API нет способа программно отменить перетаскивание.
	{
		if (_оПараметры.чШаг !== 3)
		{
			_оПараметры.лОтмена = лОтмена;
			_оПараметры.чШаг = 3;
			м_События.ОбработатьСобытие(`тащилка-перетаскивание-${_узТащится.id}`, _оПараметры);

			_узТащится.classList.remove('тащилка-элемент');
			document.body.classList.remove('тащилка-страница');

			_узТащится = _оПараметры = null;
		}
	}

	document.addEventListener('dragstart', ОбработатьDragStart);
	document.addEventListener('dragenter', ОбработатьDragEnterИDrop);
	document.addEventListener('dragover', ОбработатьDragOver);
	document.addEventListener('drop', ОбработатьDragEnterИDrop);
	document.addEventListener('dragend', ОбработатьDragEnd);

	return {
		ОтменитьПеретаскивание,
		ОбработатьИзменениеПоложенияОкна
	};
})();

const м_Оформление = (() =>
{
	const СЕЛЕКТОР_КНОПКИ_ЦВЕТА = 'input[type="color"]';

	let _сШаблон = '';
	let _оПрозрачность = null;

	const ОбработатьВводЦвета = ДобавитьОбработчикИсключений(оСобытие =>
	// Это событие посылает пока только Firefox.
	{
		if (оСобытие.target.matches(СЕЛЕКТОР_КНОПКИ_ЦВЕТА))
		{
			ОбновитьСтили();
		}
	});

	const ОбработатьИзменениеЦвета = ДобавитьОбработчикИсключений(оСобытие =>
	{
		if (оСобытие.target.matches(СЕЛЕКТОР_КНОПКИ_ЦВЕТА))
		{
			м_Настройки.Изменить(оСобытие.target.id, оСобытие.target.value);
		}
	});

	function ОбработатьИзменениеПредустановкиОформления()
	{
		ОбновитьОкноНастроек();
		ОбновитьСтили();
	}

	function ОбновитьОкноНастроек()
	{
		for (let узКнопка of document.querySelectorAll(СЕЛЕКТОР_КНОПКИ_ЦВЕТА))
		{
			узКнопка.value = м_Настройки.Получить(узКнопка.id);
		}
		_оПрозрачность.Обновить();
	}

	function ОбновитьСтили()
	{
		Проверить(_сШаблон);
		const оПеременные = {};
		оПеременные.чНепрозрачность = 1 - м_Настройки.Получить('чПрозрачность') / 100;
		оПеременные.чНепрозрачностьОкна = Ограничить(оПеременные.чНепрозрачность, 0.85, 1);
		for (let узКнопка of document.querySelectorAll(СЕЛЕКТОР_КНОПКИ_ЦВЕТА))
		{
			оПеременные[узКнопка.id] =
				Number.parseInt(узКнопка.value.slice(1, 3), 16) + ',' +
				Number.parseInt(узКнопка.value.slice(3, 5), 16) + ',' +
				Number.parseInt(узКнопка.value.slice(5, 7), 16);
		}
		document.getElementById('стиль').textContent = ЗаполнитьШаблон(_сШаблон, оПеременные);
	}

	function ЗаполнитьШаблон(сШаблон, оПеременные)
	{
		return сШаблон.replace(/{{.*?}}/g, сИмя =>
		{
			const пЗначение = оПеременные[сИмя.slice(2, -2)];
			if (typeof пЗначение === 'string')
			{
				return пЗначение;
			}
			Проверить(Number.isFinite(пЗначение));
			// 2 знака для opacity.
			return String(Округлить(пЗначение, 2));
		});
	}

	function Запустить()
	{
		_оПрозрачность = new ВводЧисла('чПрозрачность', 5, 0, 'прозрачность');
		_оПрозрачность.ПослеИзменения = ОбновитьСтили;

		document.addEventListener('input', ОбработатьВводЦвета);
		document.addEventListener('change', ОбработатьИзменениеЦвета);

		м_События.ДобавитьОбработчик('настройки-измениласьпредустановка-оформление', ОбработатьИзменениеПредустановкиОформления);
		ОбработатьИзменениеПредустановкиОформления();
	}

	function ЗапуститьАсинхронно()
	{
		return м_Загрузчик.ЗагрузитьТекст(null, chrome.extension.getURL('player.css'), 0, 'шаблон', false)
		.then(сРезультат =>
		{
			Проверить(!_сШаблон && сРезультат);
			_сШаблон = сРезультат;
		});
	}
	
	return {ЗапуститьАсинхронно, Запустить};
})();

const м_Настройки = (() =>
{
	/***
	ВЕРСИЯ_НАСТРОЕК  Версия расширения  Изменения
	              1         2017.09.11  Добавлены предустановки
	              2         2017.11.06  чПоложениеПанелиЧата +ЛЕВАЯ_СТОРОНА +ВЕРХНЯЯ_СТОРОНА
	              2         2018.01.07  Добавлена проверка значений
	              2         2018.03.17  Добавлена лЗатемнитьЧат
	              2         2018.04.06  Добавлены чСостояниеЗакрытогоЧата, лАвтоПоложениеЧата, чГоризонтальноеПоложениеЧата, чВертикальноеПоложениеЧата, чИнтервалАвтоскрытия
	              2         2018.05.18  Добавлена лПолноценныйЧат
	              2         2018.06.12  Добавлена лМасштабироватьИзображение
	              2         2018.07.09  Удалена кЗаначка
	***/
	const ВЕРСИЯ_НАСТРОЕК = 2;

	const _амПредустановкиБуферизации = new Map(
	[
		[
			'J0126',
			{
				кОдновременныхЗагрузок: 1,
				чНачалоВоспроизведения: 3,
				чРазмерБуфера:          5,
				чРастягиваниеБуфера:    15,
				чИнтервалОпроса:        МИН_ИНТЕРВАЛ_ОБНОВЛЕНИЯ_СПИСКОВ
			}
		],
		[
			'J0127',
			{
				кОдновременныхЗагрузок: 2,
				чНачалоВоспроизведения: 3,   // 1..2 сегментов.
				чРазмерБуфера:          8.5, // 3..5 сегментов.
				чРастягиваниеБуфера:    20,
				чИнтервалОпроса:        АВТОНАСТРОЙКА
			}
		],
		[
			'J0128',
			{
				кОдновременныхЗагрузок: 2,
				чНачалоВоспроизведения: 17,
				чРазмерБуфера:          9.5,
				чРастягиваниеБуфера:    30,
				чИнтервалОпроса:        АВТОНАСТРОЙКА
			}
		]
	]);

	const _амПредустановкиОформления = new Map(
	[
		[
			'J0122',
			{
				сЦветФона:      '#282828',
				сЦветГрадиента: '#ffffff',
				сЦветКнопок:    '#d3be96',
				сЦветЗаголовка: '#cdbdec',
				сЦветВыделения: '#ff9428',
				чПрозрачность:  25
			}
		],
		[
			'J0121',
			{
				сЦветФона:      '#425e7b',
				сЦветГрадиента: '#ffffff',
				сЦветКнопок:    '#ffffff',
				сЦветЗаголовка: '#d1f0fa',
				сЦветВыделения: '#ffaa33',
				чПрозрачность:  30
			}
		],
		[
			'J0138',
			{
				сЦветФона:      '#4b4b4b',
				сЦветГрадиента: '#aaaaaa',
				сЦветКнопок:    '#bad4f8',
				сЦветЗаголовка: '#e2ebb4',
				сЦветВыделения: '#75a9f0',
				чПрозрачность:  5
			}
		],
		[
			'J0125',
			{
				сЦветФона:      '#161616',
				сЦветГрадиента: '#969696',
				сЦветКнопок:    '#f0f0f0',
				сЦветЗаголовка: '#b6c3c3',
				сЦветВыделения: '#6cb6ff',
				чПрозрачность:  10
			}
		]
	]);

	const _моМетаданныеПредустановок =
	[
		{
			амДанные:       _амПредустановкиБуферизации,
			сНастраиваемая: 'J0129',
			сВыбрана:       'сПредустановкаВыбрана_буферизация',
			сЗаполнена:     'лПредустановкаЗаполнена_буферизация',
			сСписок:        'предустановка-буферизация',
			сСобытие:       'настройки-измениласьпредустановка-буферизация'
		},
		{
			амДанные:       _амПредустановкиОформления,
			сНастраиваемая: 'J0123',
			сВыбрана:       'сПредустановкаВыбрана_оформление',
			сЗаполнена:     'лПредустановкаЗаполнена_оформление',
			сСписок:        'предустановка-оформление',
			сСобытие:       'настройки-измениласьпредустановка-оформление'
		}
	];

	const _мноПостоянныеНастройки = new Set(
	[
		'чСлучайноеЧисло',
		'сПредыдущаяВерсия',
		'чВерсияНастроек'
	]);

	function Настройка(пНачальное, мпПеречисление, чМинимальное, чМаксимальное, сАвтонастройка)
	{
		this.пТекущее = undefined;
		this.пНачальное = пНачальное;
		this.мпПеречисление = мпПеречисление;
		this.чМинимальное = чМинимальное;
		this.чМаксимальное = чМаксимальное;
		this.сАвтонастройка = сАвтонастройка;
	}

	Настройка.Создать = function(пНачальное)
	{
		return new this(пНачальное, null, МИН_ЗНАЧЕНИЕ_НАСТРОЙКИ, МАКС_ЗНАЧЕНИЕ_НАСТРОЙКИ, '');
	};

	Настройка.СоздатьПеречисление = function(пНачальное, мпПеречисление)
	{
		return new this(пНачальное, мпПеречисление, МИН_ЗНАЧЕНИЕ_НАСТРОЙКИ, МАКС_ЗНАЧЕНИЕ_НАСТРОЙКИ, '');
	};

	Настройка.СоздатьДиапазон = function(пНачальное, чМинимальное, чМаксимальное, сАвтонастройка = '')
	{
		return new this(пНачальное, null, чМинимальное, чМаксимальное, сАвтонастройка);
	};

	Настройка.ПроверитьЗначение = function(пЗначение)
	// В отладочных данных настройки хранятся в JSON.
	// Object и null в значениях запрещены.
	{
		Проверить(
			   пЗначение === пЗначение
			&& пЗначение !== Infinity
			&& пЗначение !== -Infinity
			&& пЗначение !== undefined
			&& typeof пЗначение !== 'function'
			&& typeof пЗначение !== 'symbol'
			&& typeof пЗначение !== 'object'
		);
	}

	Настройка.prototype.ИсправитьЗначение = function(пЗначение)
	{
		Настройка.ПроверитьЗначение(пЗначение);
		Проверить(typeof пЗначение === typeof this.пНачальное);
		if (this.мпПеречисление)
		{
			if (!this.мпПеречисление.includes(пЗначение))
			{
				пЗначение = this.пНачальное;
			}
		}
		else if (typeof пЗначение === 'number')
		{
			if (пЗначение === АВТОНАСТРОЙКА)
			{
				if (this.сАвтонастройка === '')
				{
					пЗначение = this.пНачальное;
				}
			}
			else if (пЗначение < this.чМинимальное)
			{
				пЗначение = this.чМинимальное;
			}
			else if (пЗначение > this.чМаксимальное)
			{
				пЗначение = this.чМаксимальное;
			}
		}
		return пЗначение;
	}

	const _оНастройки =
	{
		чСлучайноеЧисло:                     Настройка.Создать(Math.random()),
		сПредыдущаяВерсия:                   Настройка.Создать('2000.1.1'),
		чВерсияНастроек:                     Настройка.Создать(ВЕРСИЯ_НАСТРОЕК),
		чГромкость2:                         Настройка.СоздатьДиапазон(МАКСИМАЛЬНАЯ_ГРОМКОСТЬ / 2, МИНИМАЛЬНАЯ_ГРОМКОСТЬ, МАКСИМАЛЬНАЯ_ГРОМКОСТЬ), // Проценты.
		лПриглушить:                         Настройка.Создать(false),
		сНазваниеВарианта:                   Настройка.Создать('CoolCmd'),
		чДлительностьПовтора2:               Настройка.СоздатьДиапазон(60, МИН_ДЛИТЕЛЬНОСТЬ_ПОВТОРА, МАКС_ДЛИТЕЛЬНОСТЬ_ПОВТОРА, 'J0124'), // Секунды.
		лМасштабироватьИзображение:          Настройка.Создать(true),
		чСостояниеЧата:                      Настройка.СоздатьПеречисление(ЧАТ_ВЫГРУЖЕН, [ЧАТ_ВЫГРУЖЕН, ЧАТ_СКРЫТ, ЧАТ_ПАНЕЛЬ]),
		чСостояниеЗакрытогоЧата:             Настройка.СоздатьПеречисление(ЧАТ_ВЫГРУЖЕН, [ЧАТ_ВЫГРУЖЕН, ЧАТ_СКРЫТ]),
		лАвтоПоложениеЧата:                  Настройка.Создать(false),
		чГоризонтальноеПоложениеЧата:        Настройка.СоздатьПеречисление(ПРАВАЯ_СТОРОНА, [ПРАВАЯ_СТОРОНА, ЛЕВАЯ_СТОРОНА]),
		чВертикальноеПоложениеЧата:          Настройка.СоздатьПеречисление(НИЖНЯЯ_СТОРОНА, [ВЕРХНЯЯ_СТОРОНА, НИЖНЯЯ_СТОРОНА]),
		чПоложениеПанелиЧата:                Настройка.СоздатьПеречисление(ПРАВАЯ_СТОРОНА, [ВЕРХНЯЯ_СТОРОНА, ПРАВАЯ_СТОРОНА, НИЖНЯЯ_СТОРОНА, ЛЕВАЯ_СТОРОНА]),
		                                     // Минимальный размер задается в player.css.
		чШиринаПанелиЧата:                   Настройка.СоздатьДиапазон(340, 100, МАКС_ЗНАЧЕНИЕ_НАСТРОЙКИ), // CSS пикселы.
		                                     // Минимальный размер задается в player.css.
		                                     // Должна влезать покупка bits.
		чВысотаПанелиЧата:                   Настройка.СоздатьДиапазон(310, 100, МАКС_ЗНАЧЕНИЕ_НАСТРОЙКИ), // CSS пикселы.
		лПолноценныйЧат:                     Настройка.Создать(true),
		лЗатемнитьЧат:                       Настройка.Создать(false),
		чРазмерИнтерфейса:                   Настройка.СоздатьДиапазон(100, 75, 200),
		чИнтервалАвтоскрытия:                Настройка.СоздатьДиапазон(4, 0.5, 60),
		лАнимацияИнтерфейса:                 Настройка.Создать(true),
		лМенятьГромкостьКолесом:             Настройка.Создать(true),
		лПоказатьСтатистику:                 Настройка.Создать(false),
		//
		// Предустановки буферизации.
		//
		сПредустановкаВыбрана_буферизация:   Настройка.Создать('J0127'),
		лПредустановкаЗаполнена_буферизация: Настройка.Создать(false),
		кОдновременныхЗагрузок:              Настройка.СоздатьДиапазон(0, 1, 3), // Сегменты.
		                                     // TODO Измерять в сегментах?
		чНачалоВоспроизведения:              Настройка.СоздатьДиапазон(0, МИН_РАЗМЕР_БУФЕРА, МАКС_РАЗМЕР_БУФЕРА), // Секунды.
		                                     // TODO Измерять в сегментах?
		                                     // TODO Добавить зависимость от кОдновременныхЗагрузок?
		                                     // TODO Можно сделать 2 значения и постепенный рост с первого до второго.
		чРазмерБуфера:                       Настройка.СоздатьДиапазон(0, МИН_РАЗМЕР_БУФЕРА, МАКС_РАЗМЕР_БУФЕРА), // Секунды.
		                                     // TODO Измерять в сегментах?
		чРастягиваниеБуфера:                 Настройка.СоздатьДиапазон(0, МИН_РАСТЯГИВАНИЕ_БУФЕРА, МАКС_РАСТЯГИВАНИЕ_БУФЕРА), // Секунды.
		чИнтервалОпроса:                     Настройка.СоздатьДиапазон(0, МИН_ИНТЕРВАЛ_ОБНОВЛЕНИЯ_СПИСКОВ, 250, 'J0120'), // Проценты.
		//
		// Предустановки оформления.
		//
		сПредустановкаВыбрана_оформление:    Настройка.Создать('J0122'),
		лПредустановкаЗаполнена_оформление:  Настройка.Создать(false),
		сЦветФона:                           Настройка.Создать(''),
		сЦветГрадиента:                      Настройка.Создать('#ffffff'),
		сЦветКнопок:                         Настройка.Создать(''),
		сЦветЗаголовка:                      Настройка.Создать(''),
		сЦветВыделения:                      Настройка.Создать(''),
		чПрозрачность:                       Настройка.СоздатьДиапазон(0, 0, 80)
	};
	
	const ОТКЛАДЫВАТЬ_СОХРАНЕНИЕ_НА = 500; // Миллисекунды. Не увеличивать слишком сильно, чтобы новое
	                                       // окно с проигрывателем не подхватило старые настройки.
	let _чТаймерОтложенногоСохранения = 0;
	let _оОтложенноеСохранение = null;

	function ПроверитьРезультатСохранения()
	{
		if (chrome.runtime.lastError)
		{
			console.error(chrome.runtime.lastError.message);
			м_Отладка.ЗавершитьРаботуИПоказатьСообщение('J0212');
		}
	}

	function Сохранить(оСохранить, лОстальноеУдалить)
	{
		if (лОстальноеУдалить)
		{
			chrome.storage.local.clear(ПроверитьРезультатСохранения);
			м_Журнал.Вот('[Настройки] Все настройки удалены из хранилища');
		}
		chrome.storage.local.set(оСохранить, ПроверитьРезультатСохранения);
		м_Журнал.Вот(`[Настройки] Настройки записаны в хранилище: ${м_Журнал.O(оСохранить)}`);
	}

	function Восстановить()
	{
		м_Журнал.Вот('[Настройки] Восстанавливаю настройки');
		return new Promise((фВыполнить, фОтказаться) =>
		{
			chrome.storage.local.get(null, оВосстановленныеНастройки =>
			{
				if (г_лРаботаЗавершена)
				{
					return;
				}
				try
				{
					if (chrome.runtime.lastError)
					{
						console.error(chrome.runtime.lastError.message);
						м_Отладка.ЗавершитьРаботуИПоказатьСообщение('J0209');
					}
					else
					{
						м_Журнал.Вот(`[Настройки] Настройки прочитаны из хранилища: ${м_Журнал.O(оВосстановленныеНастройки)}`);
						ЗавершитьВосстановление(оВосстановленныеНастройки);
						фВыполнить();
					}
				}
				catch (пИсключение)
				{
					фОтказаться(пИсключение);
				}
			});
		});
	}

	function НачатьСохранение(оСохранить, лОстальноеУдалить)
	// Функция не позволяет сбрасывать настройки на диск слишком часто. Например, громкость может изменяться каждую миллисекунду.
	// Также функция объединяет последовательность вызовов Изменить() в одну атомарную операцию сохранения.
	// Меняет оСохранить.
	{
		Проверить(ЭтоОбъект(оСохранить));
		if (!лОстальноеУдалить && Object.keys(оСохранить).length === 0)
		{
			return;
		}
		if (_чТаймерОтложенногоСохранения === 0)
		{
			if (лОстальноеУдалить)
			{
				Сохранить(оСохранить, лОстальноеУдалить);
			}
			else
			{
				м_Журнал.Вот(`[Настройки] Откладываю сохранение настроек на ${ОТКЛАДЫВАТЬ_СОХРАНЕНИЕ_НА}мс`);
				_чТаймерОтложенногоСохранения = setTimeout(ЗавершитьОтложенноеСохранение, ОТКЛАДЫВАТЬ_СОХРАНЕНИЕ_НА);
				_оОтложенноеСохранение = оСохранить;
			}
		}
		else
		{
			if (лОстальноеУдалить)
			{
				clearTimeout(_чТаймерОтложенногоСохранения);
				_чТаймерОтложенногоСохранения = 0;
				_оОтложенноеСохранение = null;
				Сохранить(оСохранить, лОстальноеУдалить);
			}
			else
			{
				Object.assign(_оОтложенноеСохранение, оСохранить);
			}
		}
	}

	const ЗавершитьОтложенноеСохранение = ДобавитьОбработчикИсключений(() =>
	{
		м_Журнал.Вот('[Настройки] Завершаю отложенное сохранение');
		Проверить(_чТаймерОтложенногоСохранения !== 0 && ЭтоОбъект(_оОтложенноеСохранение));
		Сохранить(_оОтложенноеСохранение, false);
		_чТаймерОтложенногоСохранения = 0;
		_оОтложенноеСохранение = null;
	});

	function Остановить()
	{
		if (_чТаймерОтложенногоСохранения !== 0)
		{
			clearTimeout(_чТаймерОтложенногоСохранения);
			ЗавершитьОтложенноеСохранение();
		}
		// Последующие изменения настроек не будут сохранены в хранилище, потому что г_лРаботаЗавершена
		// запретит выполнение ЗавершитьОтложенноеСохранение() в ДобавитьОбработчикИсключений().
	}

	function ПроверитьВерсиюНастроек(оНастройки, оСохранить)
	// оНастройки и оСохранить могут указывать на один объект, если информация в оСохранить не нужна.
	// Возвращает true, если версия настроек не совместима с ВЕРСИЯ_НАСТРОЕК, большая часть настроек
	// удалена, и их также необходимо удалить из хранилища расширения.
	{
		// Это ранняя версия расширения без чВерсияНастроек или первый запуск расширения после установки?
		if (оНастройки.чВерсияНастроек === undefined)
		{
			// Оставляем только постоянные настройки, формат которых пока не менялся.
			for (let сИмя of Object.keys(оНастройки))
			{
				if (_мноПостоянныеНастройки.has(сИмя))
				{
					оСохранить[сИмя] = оНастройки[сИмя];
				}
				else
				{
					delete оНастройки[сИмя];
				}
			}
			return true;
		}

		// Был сделан переход на расширение более ранней версии? Совместимость настроек в этом случае
		// не поддерживается. Удаляем все настройки.
		if (оНастройки.чВерсияНастроек > ВЕРСИЯ_НАСТРОЕК)
		{
			for (let сИмя of Object.keys(оНастройки))
			{
				delete оНастройки[сИмя];
			}
			return true;
		}

		// Проверить имена выбранных предустановок. С этой проверкой добавлять
		// и удалять предустановки можно не изменяя ВЕРСИЯ_НАСТРОЕК.
		for (let оМетаданные of _моМетаданныеПредустановок)
		{
			let сИмя = оНастройки[оМетаданные.сВыбрана];
			if (сИмя !== undefined && сИмя !== оМетаданные.сНастраиваемая)
			{
				for (let сИмяПредустановки of оМетаданные.амДанные.keys())
				{
					if (сИмя === сИмяПредустановки)
					{
						сИмя = undefined;
						break;
					}
				}
				if (сИмя !== undefined)
				{
					оСохранить[оМетаданные.сВыбрана] = оНастройки[оМетаданные.сВыбрана] = _оНастройки[оМетаданные.сВыбрана].пНачальное;
				}
			}
		}

		// В ранних версиях не было настройки чСостояниеЗакрытогоЧата.
		if (оНастройки.чСостояниеЗакрытогоЧата !== оНастройки.чСостояниеЧата
		&& (оНастройки.чСостояниеЧата === ЧАТ_ВЫГРУЖЕН || оНастройки.чСостояниеЧата === ЧАТ_СКРЫТ))
		{
			оСохранить.чСостояниеЗакрытогоЧата = оНастройки.чСостояниеЗакрытогоЧата = оНастройки.чСостояниеЧата;
		}

		if (оНастройки.чВерсияНастроек === ВЕРСИЯ_НАСТРОЕК)
		{
			return false;
		}

		// Сюда можно добавить преобразование настроек старых версий.

		оСохранить.чВерсияНастроек = оНастройки.чВерсияНастроек = ВЕРСИЯ_НАСТРОЕК;
		return false;
	}

	function ЗавершитьВосстановление(оВосстановленныеНастройки)
	{
		Проверить(ЭтоОбъект(оВосстановленныеНастройки));
		Проверить(!_оНастройки.чВерсияНастроек.пТекущее);

		const оСохранить = {};
		const лОстальноеУдалить = ПроверитьВерсиюНастроек(оВосстановленныеНастройки, оСохранить);

		// Не переносим устаревшие настройки, добавляем новые, добавляем и сохраняем постоянные и исправленные.
		for (let сИмя of Object.keys(_оНастройки))
		{
			if (оВосстановленныеНастройки.hasOwnProperty(сИмя))
			{
				const пЗначение = _оНастройки[сИмя].ИсправитьЗначение(оВосстановленныеНастройки[сИмя]);
				if (пЗначение !== оВосстановленныеНастройки[сИмя])
				{
					оСохранить[сИмя] = пЗначение;
				}
				_оНастройки[сИмя].пТекущее = пЗначение;
			}
			else
			{
				if (_мноПостоянныеНастройки.has(сИмя))
				{
					оСохранить[сИмя] = _оНастройки[сИмя].пНачальное;
				}
				_оНастройки[сИмя].пТекущее = _оНастройки[сИмя].пНачальное;
			}
		}

		НачатьСохранение(оСохранить, лОстальноеУдалить);
		НастроитьСпискиПредустановок();
	}

	function Сбросить()
	{
		м_Журнал.Окак('[Настройки] Сбрасываю настройки');

		const оСохранить = {};
		for (let сИмя of _мноПостоянныеНастройки)
		{
			оСохранить[сИмя] = _оНастройки[сИмя].пТекущее;
		}

		НачатьСохранение(оСохранить, true);
		window.location.reload();
	}

	function Экспорт()
	{
		м_Журнал.Окак('[Настройки] Экспортирую настройки');
		Проверить(_оНастройки.чВерсияНастроек.пТекущее);
		
		const оЭкспорт =
		{
			чВерсияНастроек: ВЕРСИЯ_НАСТРОЕК
		};
		for (let сИмя of Object.keys(_оНастройки))
		{
			// Экспортируемые настройки могут попасть на другой компьютер, поэтому постоянные настойки пропускаем.
			if (!_мноПостоянныеНастройки.has(сИмя))
			{
				оЭкспорт[сИмя] = _оНастройки[сИмя].пТекущее;
			}
		}
		м_Журнал.Вот(`[Настройки] Отобраны настройки для экспорта: ${м_Журнал.O(оЭкспорт)}`);

		ЗаписатьТекстВЛокальныйФайл(JSON.stringify(оЭкспорт), 'application/json', Текст('J0133'));
	}

	function Импорт(оИзФайла)
	{
		м_Журнал.Окак(`[Настройки] Импортирую настройки из файла ${оИзФайла.name}`);
		Проверить(_оНастройки.чВерсияНастроек.пТекущее);

		if (оИзФайла.size === 0 || оИзФайла.size > 10000)
		{
			м_Журнал.Ой(`[Настройки] Размер файла: ${оИзФайла.size}`);
			alert(Текст('J0134'));
			return;
		}

		const оЧиталка = new FileReader();
		оЧиталка.addEventListener('loadend', ДобавитьОбработчикИсключений(() =>
		{
			if (!ЭтоНепустаяСтрока(оЧиталка.result))
			{
				м_Журнал.Ой(`[Настройки] Результат чтения файла: ${оЧиталка.result}`);
				alert(Текст('J0135') + оИзФайла.name);
				return;
			}
			м_Журнал.Вот(`[Настройки] Настройки прочитаны из файла: ${оЧиталка.result}`);

			let оСохранить;

			try
			{
				оСохранить = JSON.parse(оЧиталка.result);
				if (!ЭтоОбъект(оСохранить))
				{
					throw 1;
				}

				if (ПроверитьВерсиюНастроек(оСохранить, оСохранить))
				{
					throw 2;
				}

				for (let сИмя of Object.keys(оСохранить))
				{
					if (!_оНастройки.hasOwnProperty(сИмя)
					|| (оСохранить[сИмя] = _оНастройки[сИмя].ИсправитьЗначение(оСохранить[сИмя])) === _оНастройки[сИмя].пНачальное)
					{
						delete оСохранить[сИмя];
					}
				}
			}
			catch (пИсключение)
			{
				м_Журнал.Ой(`[Настройки] Поймано исключение во время разбора настроек: ${пИсключение}`);
				alert(Текст('J0134'));
				return;
			}

			for (let сИмя of _мноПостоянныеНастройки)
			{
				оСохранить[сИмя] = _оНастройки[сИмя].пТекущее;
			}

			НачатьСохранение(оСохранить, true);
			window.location.reload();
		}));
		оЧиталка.readAsText(оИзФайла);
	}

	function Получить2(сИмя)
	{
		Проверить(typeof сИмя === 'string');
		Проверить(_оНастройки.hasOwnProperty(сИмя));
		for (let оМетаданные of _моМетаданныеПредустановок)
		{
			const оПредустановка = оМетаданные.амДанные.get(_оНастройки[оМетаданные.сВыбрана].пТекущее);
			if (оПредустановка)
			{
				const пЗначение = оПредустановка[сИмя];
				if (пЗначение !== undefined)
				{
					return пЗначение;
				}
			}
		}
		return _оНастройки[сИмя].пТекущее;
	}

	function Получить(сИмя)
	{
		// Если чНачалоВоспроизведения > чРазмерБуфера, то чРазмерБуфера по-прежнему используется для загрузки сегментов,
		// а размер буфера проигрывателя равен чНачалоВоспроизведения. Возможно, в будущем имеет смысл разнести размеры
		// для загрузки и воспроизведения по разным настройкам.
		if (сИмя === 'чМаксРазмерБуфера')
		{
			return Math.max(Получить2('чНачалоВоспроизведения'), Получить2('чРазмерБуфера'));
		}
		return Получить2(сИмя);
	}

	function Изменить(сИмя, пЗначение, лНеСохранять = false)
	{
		Проверить(typeof сИмя === 'string');
		Проверить(_оНастройки[сИмя].ИсправитьЗначение(пЗначение) === пЗначение);
		const оСохранить = {};

		for (let оМетаданные of _моМетаданныеПредустановок)
		{
			const оПредустановка = оМетаданные.амДанные.get(_оНастройки[оМетаданные.сВыбрана].пТекущее);
			if (оПредустановка && оПредустановка.hasOwnProperty(сИмя))
			{
				if (пЗначение === оПредустановка[сИмя])
				{
					return;
				}
				// Такой вариант пока не использовался и не тестировался.
				Проверить(!лНеСохранять);
				оСохранить[оМетаданные.сВыбрана  ] = _оНастройки[оМетаданные.сВыбрана  ].пТекущее = оМетаданные.сНастраиваемая;
				оСохранить[оМетаданные.сЗаполнена] = _оНастройки[оМетаданные.сЗаполнена].пТекущее = true;
				for (let сИмяПредустановки of Object.keys(оПредустановка))
				{
					оСохранить[сИмяПредустановки] = _оНастройки[сИмяПредустановки].пТекущее = оПредустановка[сИмяПредустановки];
				}
				ОбновитьСписокПредустановок(оМетаданные);
				// м_События.ОбработатьСобытие() вызывать не нужно.
				break;
			}
		}

		if (_оНастройки[сИмя].пТекущее !== пЗначение)
		{
			оСохранить[сИмя] = _оНастройки[сИмя].пТекущее = пЗначение;
		}

		if (!лНеСохранять)
		{
			НачатьСохранение(оСохранить, false);
		}
	}

	function ОбновитьСписокПредустановок(оМетаданные)
	{
		const узСписок = document.getElementById(оМетаданные.сСписок);
		узСписок.length = 0;
		const сВыбрать = _оНастройки[оМетаданные.сВыбрана].пТекущее;
		for (let сИмя of оМетаданные.амДанные.keys())
		{
			узСписок.add(new Option(Текст(сИмя), сИмя, сИмя === сВыбрать, сИмя === сВыбрать));
		}
		if (_оНастройки[оМетаданные.сЗаполнена].пТекущее)
		{
			узСписок.add(new Option(Текст(оМетаданные.сНастраиваемая), оМетаданные.сНастраиваемая, оМетаданные.сНастраиваемая === сВыбрать, оМетаданные.сНастраиваемая === сВыбрать));
		}
		Проверить(узСписок.value);
		return узСписок;
	}

	const ОбработатьИзменениеПредустановки = ДобавитьОбработчикИсключений(оСобытие =>
	{
		for (let оМетаданные of _моМетаданныеПредустановок)
		{
			if (оМетаданные.сСписок === оСобытие.target.id)
			{
				Проверить(оСобытие.target.value);
				Изменить(оМетаданные.сВыбрана, оСобытие.target.value);
				м_События.ОбработатьСобытие(оМетаданные.сСобытие);
				return;
			}
		}
		Проверить(false);
	});

	function НастроитьСпискиПредустановок()
	{
		for (let оМетаданные of _моМетаданныеПредустановок)
		{
			ОбновитьСписокПредустановок(оМетаданные)
			.addEventListener('change', ОбработатьИзменениеПредустановки);
		}
	}

	function ПолучитьПараметрыНастройки(сИмя)
	// TODO По хорошему, в возвращаемом объекте не должно быть свойства пТекущее, или оно должно быть только для чтения.
	{
		Проверить(typeof сИмя === 'string');
		Проверить(_оНастройки.hasOwnProperty(сИмя));
		return _оНастройки[сИмя];
	}

	function ПолучитьДанныеДляОтчета()
	{
		const оОтчет = {};
		for (let сИмя of Object.keys(_оНастройки))
		{
			if (_мноПостоянныеНастройки.has(сИмя) || _оНастройки[сИмя].пТекущее !== _оНастройки[сИмя].пНачальное)
			{
				оОтчет[сИмя] = _оНастройки[сИмя].пТекущее;
			}
		}
		return оОтчет;
	}

	return {
		Восстановить, Сбросить,
		Экспорт, Импорт,
		Получить, Изменить,
		ПолучитьПараметрыНастройки,
		ПолучитьДанныеДляОтчета,
		Остановить
	};
})();

const м_Статистика = (() =>
{
	const ЧАСТОТА_ОБНОВЛЕНИЯ_СТАТИСТИКИ  = 3;     // Количество обновлений в секунду.
	const РАЗМЕР_ИСТОРИИ_СПИСКА          = 30;    // Количество.
	const РАЗМЕР_ИСТОРИИ_ЗАГРУЗКИ        = 30;    // Количество.
	const РАЗМЕР_ИСТОРИИ_БУФЕРА          = 40;    // Количество.

	const ВЫДЕЛИТЬ_ИНТЕРВАЛ_ОБНОВЛЕНИЯ   = 150;   // Процент target duration.
	const ВЫДЕЛИТЬ_СЕКУНД_ДОБАВЛЕНО      = 0.33;  // Часть target duration.
	const ВЫДЕЛИТЬ_ОЖИДАНИЕ_ОТВЕТА       = 1.0;   // Секунды.
	const ВЫДЕЛИТЬ_ПРЕОБРАЗОВАНО         = 2;     // Количество преобразованных сегментов.
	const ВЫДЕЛИТЬ_НЕ_ПРОСМОТРЕНО_МИН    = 1.5;   // Секунды.
	const ВЫДЕЛИТЬ_НЕ_ПРОСМОТРЕНО_МАКС   = 0.5;   // Отношение. TODO Подобрать подходящее значение.
	const ВЫДЕЛИТЬ_ПРОПУЩЕННЫЕ_КАДРЫ     = 100;	  // Количество.
	const ВЫДЕЛИТЬ_ЧАСТОТУ_КАДРОВ        = 0.85;  // Отношение. TODO Подобрать подходящее значение.
	const ВЫДЕЛИТЬ_ПОТЕРЮ_ВИДЕО_ОТН      = 1 / 5; // Отношение. TODO Подобрать подходящее значение.
	const ВЫДЕЛИТЬ_ПОТЕРЮ_ВИДЕО_АБС      = 300;   // Миллисекунды. TODO Подобрать подходящее значение.
	const ВЫДЕЛИТЬ_ИСЧЕРПАНИЕ_БУФЕРА     = 5;     // Количество. TODO Подобрать подходящее значение.

	let _чТаймер                      = 0;
	let _nTargetDuration              = 0;
	let _кСегментовВСписке            = 0;
	let _чМинДлительностьВидеосемпла  = -Infinity;
	let _чМаксДлительностьВидеосемпла = +Infinity;
	let _оИнтервалОбновления          = null;
	let _оСегментовДобавлено          = null;
	let _оСекундДобавлено             = null;
	let _оТолщинаСегмента             = null;
	let _оТолщинаКанала               = null;
	let _оОжиданиеОтвета              = null;
	let _оНеПросмотрено               = null;
	let _кбВсегоСкачано               = 0;
	let _кИсходныхСегментов           = 0;
	let _кЗабраковано                 = 0;
	let _кПотерьВидео                 = 0;
	let _кПотерьЗвука                 = 0;
	let _кОшибокЗагрузки              = 0;
	let _кНезагруженныхСегментов      = 0;
	let _кПереполненийБуфера          = 0;
	let _чПропущеноВБуфере            = 0;
	let _кИсчерпанийБуфера            = 0;
	let _кИсчерпанийБуфераДосрочно    = 0;

	let _чВремяПоследнегоОбновления;
	let _чНеПросмотреноСек;
	let _кНеПросмотреноСек;

	function ВыделитьИнтервалОбновления(чЧисло)
	{
		return чЧисло >= ВЫДЕЛИТЬ_ИНТЕРВАЛ_ОБНОВЛЕНИЯ;
	}
	
	function ВыделитьСегментовДобавлено(чЧисло)
	{
		return чЧисло === 0 || чЧисло > 2;
	}

	function ВыделитьОжиданиеОтвета(чЧисло)
	{
		return чЧисло >= ВЫДЕЛИТЬ_ОЖИДАНИЕ_ОТВЕТА;
	}

	function ВыделитьНеПросмотрено(чЧисло)
	{
		return чЧисло < ВЫДЕЛИТЬ_НЕ_ПРОСМОТРЕНО_МИН
		    || чЧисло >= м_Настройки.Получить('чМаксРазмерБуфера') + м_Настройки.Получить('чРастягиваниеБуфера') * ВЫДЕЛИТЬ_НЕ_ПРОСМОТРЕНО_МАКС;
	}

	function Анализ(сИдентификатор, чРазмерИстории, чТочность)
	{
		Проверить(чРазмерИстории > 0 && чТочность >= 0);
		this._узПоказать = Узел(сИдентификатор);
		this._мчИстория  = new Array(чРазмерИстории); // Кольцевой буфер.
		this._млВыделить = new Array(чРазмерИстории); // Кольцевой буфер.
		this._чТочность  = чТочность;
		this._Очистить();
	}

	Анализ.prototype.Освободить = function()
	{
		this._узПоказать.textContent = '';
		this._узПоказать = null;
	};

	Анализ.prototype._Очистить = function()
	{
		this._кЗаполнено = 0;
		this._чИндекс    = -1;

		const узФрагмент = document.createDocumentFragment();
		узФрагмент.appendChild(document.createElement('td'))
		.className = 'анализ-минимум';
		узФрагмент.appendChild(document.createElement('td'))
		.textContent = '\u2009<\u2009';
		узФрагмент.lastChild.className = 'статистика-символ';
		узФрагмент.appendChild(document.createElement('td'))
		.className = 'анализ-среднее';
		узФрагмент.appendChild(document.createElement('td'))
		.textContent = '\u2009<\u2009';
		узФрагмент.lastChild.className = 'статистика-символ';
		узФрагмент.appendChild(document.createElement('td'))
		.className = 'анализ-максимум';
		for (let ы = 0; ы < this._мчИстория.length; ++ы)
		{
			узФрагмент.appendChild(document.createElement('td'))
			.className = 'анализ-история статистика-подробно';
		}
		this._узПоказать.textContent = '';
		this._узПоказать.appendChild(узФрагмент);
	};

	Анализ.prototype._ВСтроку = function(чЧисло)
	{
		// Не использовать пустую строку, чтобы не сработал селектор :empty.
		return Number.isFinite(чЧисло) ? чЧисло.toFixed(this._чТочность) : '\u00A0';
	};

	Анализ.prototype.Очистить = function()
	{
		if (this._кЗаполнено !== 0)
		{
			this._Очистить();
		}
	};

	Анализ.prototype.ПолучитьПоследнееЧисло = function(чЗаглушка)
	{
		return this._кЗаполнено === 0 ? чЗаглушка : this._мчИстория[this._чИндекс];
	};

	Анализ.prototype.ДобавитьЧисло = function(чЧисло, пВыделить, пВыделитьСреднее)
	// чЧисло - добавляемое число в историю. Только значения Number.isFinite() будут показаны и будут принимать участие в расчетах.
	// пВыделить - выделить чЧисло. Простой тип или функция.
	// пВыделитьСреднее - выделить среднее, рассчитанное после добавления чЧисло. Простой тип или функция.
	// Возвращает среднее число.
	{
		const НАЧАЛО_ИСТОРИИ = 5;

		const лВыделить = Boolean(typeof пВыделить === 'function' ? пВыделить(чЧисло) : пВыделить);

		if (this._кЗаполнено !== 0)
		{
			this._узПоказать.children[НАЧАЛО_ИСТОРИИ + this._чИндекс].classList.add('статистика-подробно');
		}

		if (this._кЗаполнено !== this._мчИстория.length)
		{
			++this._кЗаполнено;
		}
		if (++this._чИндекс === this._мчИстория.length)
		{
			this._чИндекс = 0;
		}
		this._мчИстория[this._чИндекс] = чЧисло;
		this._млВыделить[this._чИндекс] = лВыделить;

		let чМинимальноеЧисло = Infinity, лВыделитьМинимальное = false;
		let чМаксимальноеЧисло = -Infinity, лВыделитьМаксимальное = false;
		let чСреднееЧисло = 0, кЧисел = 0;
		for (let ы = 0; ы < this._кЗаполнено; ++ы)
		{
			if (Number.isFinite(this._мчИстория[ы]))
			{
				if (this._мчИстория[ы] < чМинимальноеЧисло || (this._мчИстория[ы] === чМинимальноеЧисло && this._млВыделить[ы]))
				{
					чМинимальноеЧисло = this._мчИстория[ы];
					лВыделитьМинимальное = this._млВыделить[ы];
				}
				if (this._мчИстория[ы] > чМаксимальноеЧисло || (this._мчИстория[ы] === чМаксимальноеЧисло && this._млВыделить[ы]))
				{
					чМаксимальноеЧисло = this._мчИстория[ы];
					лВыделитьМаксимальное = this._млВыделить[ы];
				}
				чСреднееЧисло += this._мчИстория[ы];
				++кЧисел;
			}
		}

		let лВыделитьСреднее;
		if (кЧисел === 0)
		{
			чСреднееЧисло = NaN;
			лВыделитьСреднее = false;
		}
		else
		{
			чСреднееЧисло /= кЧисел;
			лВыделитьСреднее = Boolean(typeof пВыделитьСреднее === 'function' ? пВыделитьСреднее(чСреднееЧисло) : пВыделитьСреднее);
		}

		ОбновитьЗначение(this._узПоказать.children[0], this._ВСтроку(чМинимальноеЧисло),лВыделитьМинимальное);
		ОбновитьЗначение(this._узПоказать.children[2], this._ВСтроку(чСреднееЧисло), лВыделитьСреднее);
		ОбновитьЗначение(this._узПоказать.children[4], this._ВСтроку(чМаксимальноеЧисло), лВыделитьМаксимальное);
		ОбновитьЗначение(this._узПоказать.children[НАЧАЛО_ИСТОРИИ + this._чИндекс], this._ВСтроку(чЧисло), лВыделить)
		.classList.remove('статистика-подробно');

		return чСреднееЧисло;
	};

	function ОбновитьЗначение(пЭлемент, пЗначение, лВыделить)
	{
		const узЭлемент = Узел(пЭлемент);
		узЭлемент.classList.toggle('статистика-выделить', лВыделить);
		узЭлемент.textContent = пЗначение;
		return узЭлемент;
	}

	function ПолучитьНазваниеПрофиляH264(nProfileIndication, nConstraintSetFlag)
	// ITU-T H.264:2014 A.2 Profiles
	{
		switch (nProfileIndication)
		{
			case 66: return (nConstraintSetFlag & 0x40) === 0 ? 'Baseline' : 'Constrained Baseline'; // constraint_set1_flag
			case 77: return 'Main';
			case 88: return 'Extended';
			case 100:
				switch (nConstraintSetFlag & 0x0C)
				{
					case 0x08: return 'Progressive High'; // constraint_set4_flag
					case 0x0C: return 'Constrained High'; // constraint_set4_flag | constraint_set5_flag
				}
				return 'High';
			case 110: return (nConstraintSetFlag & 0x10) === 0 ? 'High 10' : 'High 10 Intra'; // constraint_set3_flag
			case 122: return (nConstraintSetFlag & 0x10) === 0 ? 'High 4:2:2' : 'High 4:2:2 Intra'; // constraint_set3_flag
			case 244: return (nConstraintSetFlag & 0x10) === 0 ? 'High 4:4:4 Predictive' : 'High 4:4:4 Intra'; // constraint_set3_flag
			case 44:  return 'CAVLC 4:4:4 Intra';
		}
		м_Журнал.Ой(`[Статистика] Неизвестный профиль H.264 ProfileIndication=${nProfileIndication} ConstraintSetFlag=${nConstraintSetFlag}`);
		return `P${nProfileIndication}C${nConstraintSetFlag}`;
	}

	const ОбновитьСтатистику = ДобавитьОбработчикИсключений(() =>
	{
		document.getElementById('статистика-длительностьпросмотра').textContent = м_i18n.ПеревестиСекундыВСтроку(performance.now() / 1000, true);

		const {droppedVideoFrames, totalVideoFrames} = м_Проигрыватель.ПолучитьКоличествоПропущенныхКадров();
		ОбновитьЗначение('статистика-пропущено', droppedVideoFrames, droppedVideoFrames >= ВЫДЕЛИТЬ_ПРОПУЩЕННЫЕ_КАДРЫ)
		.nextElementSibling.nextElementSibling.textContent = totalVideoFrames;

		let кЖдетЗагрузки = 0, чЖдетЗагрузки = 0, чЗагружается = 0, кПреобразовано = 0, чПреобразовано = 0;
		for (let оСегмент of г_моОчередь)
		{
			switch (оСегмент.чОбработка)
			{
			case ОБРАБОТКА_ЖДЕТ_ЗАГРУЗКИ:
				кЖдетЗагрузки += 1;
				чЖдетЗагрузки += оСегмент.чДлительность;
				break;
				
			case ОБРАБОТКА_ЗАГРУЖАЕТСЯ:
			case ОБРАБОТКА_ЗАГРУЖЕН:
				чЗагружается += оСегмент.чДлительность;
				break;

			case ОБРАБОТКА_ПРЕОБРАЗОВАН:
				кПреобразовано += 1;
				чПреобразовано += оСегмент.чДлительность;
				break;

			default:
				Проверить(false);
			}
		}

		const {чПросмотрено, чНеПросмотрено} = м_Проигрыватель.ПолучитьЗаполненностьБуфера();

		let уз = ОбновитьЗначение('статистика-очередь', чЖдетЗагрузки.toFixed(1), кЖдетЗагрузки > _кСегментовВСписке);
		уз = уз.nextElementSibling.nextElementSibling;
		уз.textContent = чЗагружается.toFixed(1);
		уз = уз.nextElementSibling;
		ОбновитьЗначение(уз, чПреобразовано.toFixed(1), кПреобразовано >= ВЫДЕЛИТЬ_ПРЕОБРАЗОВАНО);
		уз = уз.nextElementSibling;
		ОбновитьЗначение(уз, чНеПросмотрено.toFixed(1), ВыделитьНеПросмотрено(чНеПросмотрено));
		уз = уз.nextElementSibling.nextElementSibling;
		уз.textContent = чПросмотрено.toFixed(1);

		if ([СОСТОЯНИЕ_ЗАГРУЗКА, СОСТОЯНИЕ_НАЧАЛО_ВОСПРОИЗВЕДЕНИЯ, СОСТОЯНИЕ_ВОСПРОИЗВЕДЕНИЕ].includes(м_Управление.ПолучитьСостояние()))
		{
			_чНеПросмотреноСек = Math.min(_чНеПросмотреноСек, чНеПросмотрено);
			_кНеПросмотреноСек = (_кНеПросмотреноСек + 1) % ЧАСТОТА_ОБНОВЛЕНИЯ_СТАТИСТИКИ;
			if (_кНеПросмотреноСек === 0)
			{
				_оНеПросмотрено.ДобавитьЧисло(_чНеПросмотреноСек, ВыделитьНеПросмотрено, ВыделитьНеПросмотрено);
				_чНеПросмотреноСек = Infinity;
			}
		}
	});

	function ОкноПоказано()
	{
		return _чТаймер !== 0;
	}

	function ОткрытьОкно()
	{
		if (ОкноПоказано())
		{
			return;
		}

		_оИнтервалОбновления = new Анализ('статистика-интервалобновления', РАЗМЕР_ИСТОРИИ_СПИСКА,   0);
		_оСегментовДобавлено = new Анализ('статистика-сегментовдобавлено', РАЗМЕР_ИСТОРИИ_СПИСКА,   0);
		_оСекундДобавлено    = new Анализ('статистика-секунддобавлено',    РАЗМЕР_ИСТОРИИ_СПИСКА,   1);
		_оТолщинаСегмента    = new Анализ('статистика-толщинасегмента',    РАЗМЕР_ИСТОРИИ_ЗАГРУЗКИ, 1);
		_оТолщинаКанала      = new Анализ('статистика-толщинаканала',      РАЗМЕР_ИСТОРИИ_ЗАГРУЗКИ, 1);
		_оОжиданиеОтвета     = new Анализ('статистика-ожиданиеответа',     РАЗМЕР_ИСТОРИИ_ЗАГРУЗКИ, 1);
		_оНеПросмотрено      = new Анализ('статистика-непросмотрено',      РАЗМЕР_ИСТОРИИ_БУФЕРА,   1);

		_чВремяПоследнегоОбновления = NaN;
		_чНеПросмотреноСек          = Infinity;
		_кНеПросмотреноСек          = 0;

		//
		// Вывод редко изменяемых показаний.
		//
		ОбновитьЗначение('статистика-забраковано', _кЗабраковано, _кЗабраковано !== 0);
		ОбновитьЗначение('статистика-потерьвидео', _кПотерьВидео, _кПотерьВидео !== 0);
		ОбновитьЗначение('статистика-потерьзвука', _кПотерьЗвука, _кПотерьЗвука !== 0);
		Узел('статистика-исходных').textContent = _кИсходныхСегментов;
		ОбновитьЗначение('статистика-незагружено', _кОшибокЗагрузки, _кОшибокЗагрузки !== 0)
		.nextElementSibling.nextElementSibling.textContent = _кНезагруженныхСегментов;
		ОбновитьЗначение('статистика-переполнено', _кПереполненийБуфера, _кПереполненийБуфера !== 0)
		.nextElementSibling.nextElementSibling.textContent = _чПропущеноВБуфере.toFixed(1);
		ОбновитьЗначение('статистика-исчерпано', _кИсчерпанийБуфера, _кИсчерпанийБуфера >= ВЫДЕЛИТЬ_ИСЧЕРПАНИЕ_БУФЕРА);

		_чТаймер = setInterval(ОбновитьСтатистику, 1000 / ЧАСТОТА_ОБНОВЛЕНИЯ_СТАТИСТИКИ);
		ОбновитьСтатистику();

		м_События.ДобавитьОбработчик('тащилка-перетаскивание-статистика', м_Тащилка.ОбработатьИзменениеПоложенияОкна);

		ПоказатьЭлемент('статистика', true);
		м_Настройки.Изменить('лПоказатьСтатистику', true);
	}

	function ЗакрытьОкно()
	{
		if (!ОкноПоказано())
		{
			return;
		}

		ПоказатьЭлемент('статистика', false);

		_оИнтервалОбновления.Освободить(); _оИнтервалОбновления = null;
		_оСегментовДобавлено.Освободить(); _оСегментовДобавлено = null;
		_оСекундДобавлено.Освободить();    _оСекундДобавлено    = null;
		_оТолщинаСегмента.Освободить();    _оТолщинаСегмента    = null;
		_оТолщинаКанала.Освободить();      _оТолщинаКанала      = null;
		_оОжиданиеОтвета.Освободить();     _оОжиданиеОтвета     = null;
		_оНеПросмотрено.Освободить();      _оНеПросмотрено      = null;

		for (let уз of document.querySelectorAll('*[data-очистить]'))
		{
			уз.textContent = '';
		}

		clearInterval(_чТаймер);
		_чТаймер = 0;

		м_Настройки.Изменить('лПоказатьСтатистику', false);
	}

	function Запустить()
	{
		if (м_Настройки.Получить('лПоказатьСтатистику'))
		{
			ОткрытьОкно();
		}
	}

	function Остановить()
	{
		clearInterval(_чТаймер);
		_чТаймер = 0;
	}

	function ОчиститьИсторию()
	// Вызвать после изменения настроек, которые влияют на загрузку сегментов.
	{
		if (_оИнтервалОбновления !== null)
		{
			_оИнтервалОбновления.Очистить();
			_оСегментовДобавлено.Очистить();
			_оСекундДобавлено.Очистить();
			_оТолщинаСегмента.Очистить();
			_оТолщинаКанала.Очистить();
			_оОжиданиеОтвета.Очистить();
			_оНеПросмотрено.Очистить();

			_чВремяПоследнегоОбновления = NaN;
			_чНеПросмотреноСек          = Infinity;
			_кНеПросмотреноСек          = 0;
		}
		ОбновитьЗначение('статистика-незагружено', _кОшибокЗагрузки = 0, false)
		.nextElementSibling.nextElementSibling.textContent = _кНезагруженныхСегментов = 0;
		ОбновитьЗначение('статистика-переполнено', _кПереполненийБуфера = 0, false)
		.nextElementSibling.nextElementSibling.textContent = (_чПропущеноВБуфере = 0).toFixed(1);
		ОбновитьЗначение('статистика-исчерпано', _кИсчерпанийБуфера = 0, false);
	}

	function ПолучитьTargetDuration()
	{
		return _nTargetDuration;
	}

	function ПолучитьДлительностьКадраВСекундах()
	// Часто в исходном видео длительность кадров округлена до целых миллисекунд.
	{
		return {
			// Edge 15: Минимальные интервалы для перемотки: -17 мс и +16 мс.
			чМинимальная: Math.max(17, _чМинДлительностьВидеосемпла) / 1000,
			чМаксимальная: Math.min(1000 / 25, _чМаксДлительностьВидеосемпла) / 1000
		};
	}

	function ПолучитьДанныеДляОтчета()
	{
		return {
			ПараметрыВидео:           Узел('статистика-разрешениевидео').textContent + ' ' + Узел('статистика-сжатиевидео').textContent,
			ПараметрыЗвука:           Узел('статистика-сжатиезвука').textContent,
			ВсегоСкачано:             _кбВсегоСкачано,
			Забраковано:              _кЗабраковано,
			ПотерьВидео:              _кПотерьВидео,
			ПотерьЗвука:              _кПотерьЗвука,
			ОшибокЗагрузки:           _кОшибокЗагрузки,
			НезагруженныхСегментов:   _кНезагруженныхСегментов,
			ПереполненийБуфера:       _кПереполненийБуфера,
			ПропущеноВБуфере:         _чПропущеноВБуфере,
			ИсчерпанийБуфера:         _кИсчерпанийБуфера,
			ИсчерпанийБуфераДосрочно: _кИсчерпанийБуфераДосрочно
		};
	}

	function СкачаноНечто(кбСкачано)
	{
		if (Number.isFinite(кбСкачано))
		{
			_кбВсегоСкачано += кбСкачано;
			if (ОкноПоказано())
			{
				document.getElementById('статистика-скачано').textContent = (_кбВсегоСкачано / 1024 / 1024).toFixed();
			}
		}
	}

	function РазобранСписокСегментов(оСписок, чДлительностьСписка)
	{
		if (ОкноПоказано())
		{
			if (оСписок.моСегменты.length !== 0)
			{
				Узел('статистика-сервер').textContent = (new URL(оСписок.моСегменты[0].сАдрес)).host;
			}
			const уз = Узел('статистика-список');
			уз.textContent = `${оСписок.моСегменты.length} × ${(чДлительностьСписка / оСписок.моСегменты.length).toFixed(1)} = ${чДлительностьСписка.toFixed(1)}`;
			ОбновитьЗначение(уз.nextElementSibling.nextElementSibling, оСписок.nTargetDuration, оСписок.nTargetDuration !== _nTargetDuration);
		}
		_nTargetDuration = оСписок.nTargetDuration;
		_кСегментовВСписке = оСписок.моСегменты.length;
	}

	function ДобавленыСегментыВОчередь(кСегментовДобавлено, кСекундДобавлено)
	{
		if (ОкноПоказано())
		{
			// Рассчитываем интервал после получения списка сегментов, а не перед получением,
			// чтобы продолжительность получения была отражена в статистике.
			const чВремя = performance.now();
			_оИнтервалОбновления.ДобавитьЧисло((чВремя - _чВремяПоследнегоОбновления) / _nTargetDuration / 10,
				ВыделитьИнтервалОбновления, ВыделитьИнтервалОбновления);
			_чВремяПоследнегоОбновления = чВремя;

			const чВСреднемСегментовДобавлено = _оСегментовДобавлено.ДобавитьЧисло(кСегментовДобавлено,
				ВыделитьСегментовДобавлено, ВыделитьСегментовДобавлено);

			_оСекундДобавлено.ДобавитьЧисло(кСекундДобавлено,
				кСекундДобавлено / кСегментовДобавлено < _nTargetDuration * ВЫДЕЛИТЬ_СЕКУНД_ДОБАВЛЕНО,
				чЧисло => чЧисло / чВСреднемСегментовДобавлено < _nTargetDuration * ВЫДЕЛИТЬ_СЕКУНД_ДОБАВЛЕНО
			);
		}
	}

	function ЗагруженСегмент(чРазмерСегмента, чДлительностьСегмента, чДлительностьЗагрузки, чОжиданиеОтвета)
	{
		if (ОкноПоказано())
		{
			const чСредняяТолщинаСегмента = _оТолщинаСегмента.ДобавитьЧисло(чРазмерСегмента * 8 / 1000000 / чДлительностьСегмента);

			чДлительностьЗагрузки /= 1000;
			_оТолщинаКанала.ДобавитьЧисло(
				чРазмерСегмента * 8 / 1000000 / чДлительностьЗагрузки,
				чДлительностьЗагрузки > чДлительностьСегмента,
				чЧисло => чЧисло < чСредняяТолщинаСегмента
			);

			_оОжиданиеОтвета.ДобавитьЧисло(чОжиданиеОтвета / 1000, ВыделитьОжиданиеОтвета, ВыделитьОжиданиеОтвета);
		}
	}

	function НеЗагруженыСегменты(кНезагруженныхСегментов)
	{
		Проверить(кНезагруженныхСегментов > 0);
		_кОшибокЗагрузки += 1;
		_кНезагруженныхСегментов += кНезагруженныхСегментов;
		if (ОкноПоказано())
		{
			ОбновитьЗначение('статистика-незагружено', _кОшибокЗагрузки, true)
			.nextElementSibling.nextElementSibling.textContent = _кНезагруженныхСегментов;
		}
	}

	function ОтосланИсходныйСегмент()
	{
		++_кИсходныхСегментов;
		if (ОкноПоказано())
		{
			document.getElementById('статистика-исходных').textContent = _кИсходныхСегментов;
		}
	}

	function ПолученПреобразованныйСегмент(оСегмент)
	{
		const лОкноПоказано = ОкноПоказано();
		const оДанные = оСегмент.пДанные;

		if (оСегмент.лРазрыв)
		{
			Узел('статистика-разрешениевидео').textContent = `${оДанные.чШиринаКартинки}x${оДанные.чВысотаКартинки}`;

			let сСжатиеВидео = 'H.264'
				+ `\u2002${ПолучитьНазваниеПрофиляH264(оДанные.nProfileIndication, оДанные.nConstraintSetFlag)}`
				+ `\u2002L${(оДанные.nLevelIndication / 10).toFixed(1)}`
				+ `\u2002RF${оДанные.nMaxNumberReferenceFrames}`;
			if (оДанные.чДиапазон !== -1)
			{
				сСжатиеВидео += оДанные.чДиапазон === 0 ? '\u200216-235' : '\u20020-255';
			}
			if (оДанные.лЧересстрочное)
			{
				сСжатиеВидео += '\u2002чересстрочное';
			}
			if (оДанные.чЧастотаКадров !== 0)
			{
				// Twitch: Иногда чЧастотаКадров равна 1000 при фактической 60.
				сСжатиеВидео += `\u2002${оДанные.чЧастотаКадров < 0 ? '≈' : ''}${Math.abs(оДанные.чЧастотаКадров).toFixed(2)} ${Текст('J0140')}`;
			}
			document.getElementById('статистика-сжатиевидео').textContent = сСжатиеВидео;

			document.getElementById('статистика-сжатиезвука').textContent =
				['AAC-Main', 'AAC-LC', 'AAC-SSR', 'AAC-LTP'][оДанные.nAudioObjectType - 1]
				+ `\u2002${оДанные.чЧастотаДискретизации} ${Текст('J0141')}`
				+ `\u2002${оДанные.чКоличествоКаналов} ${Текст('J0142')}`;
		}

		if (Number.isFinite(оДанные.чСредняяДлительностьВидеоСемпла))
		{
			_чМинДлительностьВидеосемпла = оДанные.чМинДлительностьВидеоСемпла;
			_чМаксДлительностьВидеосемпла = оДанные.чМаксДлительностьВидеоСемпла;
			Проверить(_чМинДлительностьВидеосемпла <= _чМаксДлительностьВидеосемпла);

			// В идеале для нахождения потери кадров среднее арифметическое нужно заменить чем-нибудь более преближенным
			// к исходной частоте кадров. Но нагружать процессор этими расчетами не хочется.
			const чОтносительноеОтклонение = оДанные.чСредняяДлительностьВидеоСемпла / оДанные.чМаксДлительностьВидеоСемпла;
			const чАбсолютноеОтклонение = оДанные.чМаксДлительностьВидеоСемпла - оДанные.чСредняяДлительностьВидеоСемпла;
			if (чОтносительноеОтклонение <= ВЫДЕЛИТЬ_ПОТЕРЮ_ВИДЕО_ОТН && чАбсолютноеОтклонение >= ВЫДЕЛИТЬ_ПОТЕРЮ_ВИДЕО_АБС)
			{
				м_Журнал.Ой(`[Статистика] Превышено отклонение длительности кадра в сегменте ${оСегмент.чНомер}`
					+ ` СредняяДлительностьКадра=${м_Журнал.F0(оДанные.чСредняяДлительностьВидеоСемпла)}мс`
					+ ` АбсолютноеОтклонение=${м_Журнал.F0(чАбсолютноеОтклонение)}мс`
					+ ` ОтносительноеОтклонение=${м_Журнал.F2(чОтносительноеОтклонение)}`);
				оДанные.лПотериВидео = true;
			}
		}

		if (лОкноПоказано)
		{
			if (Number.isFinite(оДанные.чСредняяДлительностьВидеоСемпла))
			{
				ОбновитьЗначение(
					'статистика-частотакадров',
					`@${(1000 / оДанные.чСредняяДлительностьВидеоСемпла).toFixed(0)}`
					+ `\u2002−${(100 - оДанные.чСредняяДлительностьВидеоСемпла / оДанные.чМаксДлительностьВидеоСемпла * 100).toFixed()}%`
					+ `\u2002+${(оДанные.чСредняяДлительностьВидеоСемпла  / оДанные.чМинДлительностьВидеоСемпла * 100 - 100).toFixed()}%`,
					оДанные.чСредняяДлительностьВидеоСемпла / оДанные.чМаксДлительностьВидеоСемпла <= ВЫДЕЛИТЬ_ЧАСТОТУ_КАДРОВ
				);
			}
			if (ЭтоЧисло(оДанные.чБитрейтЗвука))
			{
				document.getElementById('статистика-битрейтзвука').textContent = `${оДанные.чБитрейтЗвука.toFixed()} ${Текст('J0143')}`;
			}
			if (ЭтоЧисло(оДанные.чПреобразованЗа))
			{
				document.getElementById('статистика-преобразованоза').textContent = оДанные.чПреобразованЗа.toFixed();
			}
		}

		if (оДанные.лПотериВидео)
		{
			++_кПотерьВидео;
			if (лОкноПоказано)
			{
				ОбновитьЗначение('статистика-потерьвидео', _кПотерьВидео, true);
			}
		}

		if (оДанные.лПотериЗвука)
		{
			++_кПотерьЗвука;
			if (лОкноПоказано)
			{
				ОбновитьЗначение('статистика-потерьзвука', _кПотерьЗвука, true);
			}
		}

		if (оДанные.лЗабраковано)
		{
			++_кЗабраковано;
			if (лОкноПоказано)
			{
				ОбновитьЗначение('статистика-забраковано', _кЗабраковано, true);
			}
		}
	}

	function ИсчерпанБуферПроигрывателя(лДосрочно)
	{
		++_кИсчерпанийБуфера;
		if (лДосрочно)
		{
			++_кИсчерпанийБуфераДосрочно;
		}
		if (ОкноПоказано())
		{
			ОбновитьЗначение('статистика-исчерпано', _кИсчерпанийБуфера, _кИсчерпанийБуфера >= ВЫДЕЛИТЬ_ИСЧЕРПАНИЕ_БУФЕРА);
		}
	}

	м_События.ДобавитьОбработчик('управление-изменилосьсостояние', чСостояние =>
	{
		if (чСостояние === СОСТОЯНИЕ_ЗАПУСК)
		{
			ОчиститьИсторию();
		}
	});

	м_События.ДобавитьОбработчик('список-выбранварианттрансляции', ([моСписокВариантов]) =>
	{
		if (моСписокВариантов)
		{
			ОчиститьИсторию();
		}
	});
	
	м_События.ДобавитьОбработчик('проигрыватель-переполненбуфер', чПропущено =>
	{
		++_кПереполненийБуфера;
		_чПропущеноВБуфере += чПропущено;
		if (ОкноПоказано())
		{
			ОбновитьЗначение('статистика-переполнено', _кПереполненийБуфера, true)
			.nextElementSibling.nextElementSibling.textContent = _чПропущеноВБуфере.toFixed(1);
		}
	});

	return {
		Запустить, Остановить,
		ОкноПоказано, ОткрытьОкно, ЗакрытьОкно,
		ОбновитьЗначение,
		ОчиститьИсторию,
		ПолучитьTargetDuration, ПолучитьДлительностьКадраВСекундах,
		ПолучитьДанныеДляОтчета,
		СкачаноНечто,
		РазобранСписокСегментов,
		ДобавленыСегментыВОчередь,
		ЗагруженСегмент,
		НеЗагруженыСегменты,
		ОтосланИсходныйСегмент,
		ПолученПреобразованныйСегмент,
		ИсчерпанБуферПроигрывателя
	};
})();

const м_Чат = (() =>
{
	let _узЧат = null; // iframe
	let _лБоковаяПанельДоступна = false;
	let _сИмяКанала = ''; // Кэшируемое имя канала для заголовка боковой панели.

	function ПолучитьПоложениеПанели()
	// Возвращает текущую сторону даже если включено автоположение панели.
	{
		switch (getComputedStyle(document.getElementById('проигрывательичат')).flexDirection)
		{
			case 'column-reverse': return ВЕРХНЯЯ_СТОРОНА;
			case 'row': return ПРАВАЯ_СТОРОНА;
			case 'column': return НИЖНЯЯ_СТОРОНА;
			case 'row-reverse': return ЛЕВАЯ_СТОРОНА;
			default: Проверить(false);
		}
	}

	const ОбработатьОкончаниеЗагрузкиЧата = ДобавитьОбработчикИсключений(оСобытие =>
	{
		оСобытие.target.classList.remove('загружается');
		оСобытие.target.removeEventListener('load', ОбработатьОкончаниеЗагрузкиЧата);
	});

	function ВставитьПанель()
	{
		if (!_узЧат)
		{
			НачатьИздеватьсяНадЧатом(г_чИдВкладки);
			// Чат перенаправляет twitch.tv на www.twitch.tv, потом меняет document.domain c www.twitch.tv на twitch.tv.
			// Атрибут sandbox запрещает менять document.domain, поэтому sandbox использовать нельзя.
			const сАдрес = м_Twitch.ПолучитьАдресПанелиЧата();
			м_Журнал.Вот(`[Чат] Вставляю iframe ${сАдрес}`);
			_узЧат = document.createElement('iframe');
			_узЧат.src = сАдрес;
			_узЧат.id = 'чат';
			_узЧат.width = м_Настройки.Получить('чШиринаПанелиЧата');
			_узЧат.height = м_Настройки.Получить('чВысотаПанелиЧата');
			_узЧат.className = 'загружается';
			_узЧат.addEventListener('load', ОбработатьОкончаниеЗагрузкиЧата);
			// HACK https://bugs.chromium.org/p/chromium/issues/detail?id=793280
			if (ВЕРСИЯ_ДВИЖКА_БРАУЗЕРА > 55 && ВЕРСИЯ_ДВИЖКА_БРАУЗЕРА < 66)
			{
				const чСкрытьНа = Math.round(2000 - performance.now());
				if (чСкрытьНа > 0)
				{
					// Во время ожидания таймера _узЧат может измениться.
					const оСтиль = _узЧат.style;
					оСтиль.opacity = '0';
					setTimeout(
						() =>
						{
							оСтиль.visibility = 'hidden';
							setTimeout(
								() =>
								{
									оСтиль.opacity = оСтиль.visibility = '';
								},
								1000
							);
						},
						чСкрытьНа
					);
				}
			}
			document.getElementById('размерчата').insertAdjacentElement('afterend', _узЧат);
		}
	}

	function УдалитьПанель()
	{
		if (_узЧат)
		{
			м_Журнал.Вот(`[Чат] Удаляю iframe ${_узЧат.src}`);
			_узЧат.removeEventListener('load', ОбработатьОкончаниеЗагрузкиЧата);
			_узЧат.remove();
			_узЧат = null;
		}
	}

	function ПрименитьАдресПанели()
	{
		if (_узЧат)
		{
			м_Журнал.Окак('[Чат] Меняю адрес iframe');
			УдалитьПанель();
			ВставитьПанель();
		}
	}

	function ПрименитьСостояниеПанели()
	// Вызвать, если изменилась настройка чСостояниеЧата.
	// Проще не удалять iframe, а менять его src, но тогда в чате кнопки браузера Вперед и Назад будут перезагружать чат.
	{
		const чСостояние = м_Настройки.Получить('чСостояниеЧата');
		м_Журнал.Окак(`[Чат] Новое состояние панели: ${чСостояние}`);
		ОтменитьПеретаскиваниеПанели();
		switch (чСостояние)
		{
		case ЧАТ_ВЫГРУЖЕН:
			document.body.classList.add('скрытьчат');
			УдалитьПанель();
			break;

		case ЧАТ_СКРЫТ:
			ЗакрытьБоковуюПанель();
			ВставитьПанель();
			document.body.classList.add('скрытьчат');
			break;

		case ЧАТ_ПАНЕЛЬ:
			ЗакрытьБоковуюПанель();
			ВставитьПанель();
			document.body.classList.remove('скрытьчат');
			break;

		default:
			Проверить(false);
		}
	}

	function ПрименитьПоложениеПанели()
	// Вызвать, если изменились настройки, влияющие на положение чата.
	{
		ОтменитьПеретаскиваниеПанели();
		const оКлассы = document.body.classList;
		if (м_Настройки.Получить('лАвтоПоложениеЧата'))
		{
			оКлассы.add('автоположениечата');
			оКлассы.toggle('чатвверху', м_Настройки.Получить('чВертикальноеПоложениеЧата') === ВЕРХНЯЯ_СТОРОНА);
			оКлассы.toggle('чатслева', м_Настройки.Получить('чГоризонтальноеПоложениеЧата') === ЛЕВАЯ_СТОРОНА);
		}
		else
		{
			const чПоложение = м_Настройки.Получить('чПоложениеПанелиЧата');
			оКлассы.remove('автоположениечата');
			оКлассы.toggle('чатвверху', чПоложение === ВЕРХНЯЯ_СТОРОНА);
			оКлассы.toggle('чатсправа', чПоложение === ПРАВАЯ_СТОРОНА);
			оКлассы.toggle('чатвнизу', чПоложение === НИЖНЯЯ_СТОРОНА);
			оКлассы.toggle('чатслева', чПоложение === ЛЕВАЯ_СТОРОНА);
		}
	}

	function СохранитьИПрименитьСостояниеЗакрытойПанели(чНовоеСостояние)
	{
		м_Настройки.Изменить('чСостояниеЗакрытогоЧата', чНовоеСостояние);
		const чСостояние = м_Настройки.Получить('чСостояниеЧата');
		if ((чСостояние === ЧАТ_ВЫГРУЖЕН || чСостояние === ЧАТ_СКРЫТ) && чСостояние !== чНовоеСостояние)
		{
			м_Настройки.Изменить('чСостояниеЧата', чНовоеСостояние);
			ПрименитьСостояниеПанели();
		}
	}

	function ПереключитьСостояниеПанели()
 	{
		const лПолноэкранныйРежим = м_ПолноэкранныйРежим.Включен();
		switch (м_Настройки.Получить('чСостояниеЧата'))
		{
		case ЧАТ_ВЫГРУЖЕН:
		case ЧАТ_СКРЫТ:
			м_Настройки.Изменить('чСостояниеЧата', ЧАТ_ПАНЕЛЬ, лПолноэкранныйРежим);
			break;

		case ЧАТ_ПАНЕЛЬ:
			м_Настройки.Изменить('чСостояниеЧата', лПолноэкранныйРежим ? ЧАТ_СКРЫТ : м_Настройки.Получить('чСостояниеЗакрытогоЧата'), лПолноэкранныйРежим);
			break;

		default:
			Проверить(false);
		}
		ПрименитьСостояниеПанели();
	}

	function ПереключитьПоложениеПанели()
 	{
		let чПоложение;
		if (м_Настройки.Получить('лАвтоПоложениеЧата'))
		{
			м_Настройки.Изменить('лАвтоПоложениеЧата', false);
			чПоложение = ПолучитьПоложениеПанели();
		}
		else
		{
			чПоложение = м_Настройки.Получить('чПоложениеПанелиЧата');
		}
		switch (чПоложение)
		{
			case ВЕРХНЯЯ_СТОРОНА: м_Настройки.Изменить('чПоложениеПанелиЧата', ПРАВАЯ_СТОРОНА); break;
			case ПРАВАЯ_СТОРОНА:  м_Настройки.Изменить('чПоложениеПанелиЧата', НИЖНЯЯ_СТОРОНА); break;
			case НИЖНЯЯ_СТОРОНА:  м_Настройки.Изменить('чПоложениеПанелиЧата', ЛЕВАЯ_СТОРОНА); break;
			case ЛЕВАЯ_СТОРОНА:   м_Настройки.Изменить('чПоложениеПанелиЧата', ВЕРХНЯЯ_СТОРОНА); break;
			default: Проверить(false);
		}
		ПрименитьПоложениеПанели();
	}

	function ПроверитьДоступностьБоковойПанели()
	{
		_лБоковаяПанельДоступна = Boolean(window.opr && opr.sidebarAction);
		if (_лБоковаяПанельДоступна)
		{
			м_События.ДобавитьОбработчик('twitch-полученыметаданныеканала', ОбработатьПолучениеМетаданныхКанала);
		}
		else
		{
			м_Журнал.Ой('[Чат] Боковая панель браузера недоступна');
			const узМеню = document.getElementById('открытьбоковуюпанель'); // Пункт меню.
			узМеню.nextElementSibling.remove(); // Разделитель меню.
			узМеню.remove();
		}
	}


	function НастроитьБоковуюПанель(сАдрес, сЗаголовок, лОткрыть)
	{
		Проверить(сАдрес === undefined || сАдрес === '' || сАдрес.startsWith('http://') || сАдрес.startsWith('https://'));
		Проверить(сЗаголовок === undefined || typeof сЗаголовок === 'string');
		Проверить(сАдрес !== undefined || сЗаголовок !== undefined);
		const оМанифест = chrome.runtime.getManifest().sidebar_action;
		if (сАдрес !== undefined)
		{
			opr.sidebarAction.setPanel(
			{
				// Operа позволяет загружать в боковую панель только страницы расширения.
				// В Firefox нет такого ограничения.
				panel: оМанифест.default_panel + '#' + encodeURIComponent(сАдрес)
			});
		}
		if (сЗаголовок !== undefined)
		{
			opr.sidebarAction.setTitle(
			{
				// Эмулируем поведение Firefox 59+.
				title: сЗаголовок ? сЗаголовок : оМанифест.default_title
			});
		}
	}

	function НастроитьНашуБоковуюПанель(сАдрес, сЗаголовок)
	{
		opr.sidebarAction.getPanel({}, ДобавитьОбработчикИсключений(сТекущийАдрес =>
		{
			if (chrome.runtime.lastError)
			{
				throw `Не удалось получить адрес боковой панели: ${chrome.runtime.lastError.message}`;
			}
			if (м_Twitch.ЭтоАдресПанелиЧата(decodeURIComponent((new URL(сТекущийАдрес)).hash.slice(1))))
			{
				НастроитьБоковуюПанель(сАдрес, сЗаголовок, false);
			}
		}));
	}

	function ОткрытьБоковуюПанель()
	{
		if (_лБоковаяПанельДоступна)
		{
			м_Настройки.Изменить('чСостояниеЧата', ЧАТ_ВЫГРУЖЕН, true);
			ПрименитьСостояниеПанели();
			const сАдрес = м_Twitch.ПолучитьАдресПанелиЧата();
			м_Журнал.Окак(`[Чат] Открываю боковую панель ${сАдрес}`);
			НастроитьБоковуюПанель(сАдрес, _сИмяКанала === '' ? '' : Текст('J0137', _сИмяКанала), true);
		}
	}

	function ЗакрытьБоковуюПанель()
	{
		if (_лБоковаяПанельДоступна)
		{
			м_Журнал.Окак('[Чат] Закрываю боковую панель');
			НастроитьНашуБоковуюПанель('', '');
		}
	}

	function ПрименитьАдресБоковойПанели()
	{
		if (_лБоковаяПанельДоступна)
		{
			const сАдрес = м_Twitch.ПолучитьАдресПанелиЧата();
			м_Журнал.Окак(`[Чат] Меняю адрес боковой панели на ${сАдрес}`);
			НастроитьНашуБоковуюПанель(сАдрес, undefined);
		}
	}

	function ОбработатьПолучениеМетаданныхКанала({сИмя})
	// Имя канала может быть получено после открытия боковой панели.
	// Также теоретически имя канала может измениться во время трансляции.
	{
		if (сИмя !== undefined && сИмя !== _сИмяКанала)
		{
			м_Журнал.Окак(`[Чат] Меняю заголовок боковой панели с ${_сИмяКанала} на ${сИмя}`);
			_сИмяКанала = сИмя;
			НастроитьНашуБоковуюПанель(undefined, Текст('J0137', сИмя));
		}
	}

	function ОбработатьПеретаскиваниеПанели(оПараметры)
	{
		const чПоложение = ПолучитьПоложениеПанели();
		switch (оПараметры.чШаг)
		{
			case 1:
				оПараметры._чНачальноеПоложение = чПоложение;
				if (чПоложение === ПРАВАЯ_СТОРОНА || чПоложение === ЛЕВАЯ_СТОРОНА)
				{
					// Учитывать min-width.
					оПараметры._чНачальныйРазмер = Number.parseInt(getComputedStyle(_узЧат).width, 10);
				}
				else
				{
					// Учитывать min-height.
					оПараметры._чНачальныйРазмер = Number.parseInt(getComputedStyle(_узЧат).height, 10);
				}
				break;

			case 2:
				if (оПараметры._чНачальноеПоложение !== чПоложение)
				{
					// Это может произойти например если включено автоположение чата.
					м_Журнал.Ой(`[Чат] Положение перетаскиваемой панели изменилось с ${оПараметры._чНачальноеПоложение} на ${чПоложение}`);
					м_Тащилка.ОтменитьПеретаскивание();
					break;
				}
				if (чПоложение === ПРАВАЯ_СТОРОНА || чПоложение === ЛЕВАЯ_СТОРОНА)
				{
					if (оПараметры.лИзмениласьX)
					{
						const чМаксРазмер = Number.parseInt(getComputedStyle(document.getElementById('проигрывательичат')).width, 10)
										  - Number.parseInt(getComputedStyle(document.getElementById('проигрыватель')).minWidth, 10);
						_узЧат.width = Math.max(Math.min(чПоложение === ЛЕВАЯ_СТОРОНА
							? оПараметры._чНачальныйРазмер + оПараметры.чИзменениеX
							: оПараметры._чНачальныйРазмер - оПараметры.чИзменениеX,
							чМаксРазмер), 0);
					}
				}
				else
				{
					if (оПараметры.лИзмениласьY)
					{
						const чМаксРазмер = Number.parseInt(getComputedStyle(document.getElementById('проигрывательичат')).height, 10);
										  - Number.parseInt(getComputedStyle(document.getElementById('проигрыватель')).minHeight, 10);
						_узЧат.height = Math.max(Math.min(чПоложение === ВЕРХНЯЯ_СТОРОНА
							? оПараметры._чНачальныйРазмер + оПараметры.чИзменениеY
							: оПараметры._чНачальныйРазмер - оПараметры.чИзменениеY,
							чМаксРазмер), 0);
					}
				}
				break;

			case 3:
				if (оПараметры.лОтмена)
				{
					break;
				}
				if (оПараметры._чНачальноеПоложение !== чПоложение)
				{
					м_Журнал.Ой(`[Чат] Положение перетаскиваемой панели изменилось с ${оПараметры._чНачальноеПоложение} на ${чПоложение}`);
					break;
				}
				if (чПоложение === ПРАВАЯ_СТОРОНА || чПоложение === ЛЕВАЯ_СТОРОНА)
				{
					м_Настройки.Изменить('чШиринаПанелиЧата', Number.parseInt(getComputedStyle(_узЧат).width, 10));
				}
				else
				{
					м_Настройки.Изменить('чВысотаПанелиЧата', Number.parseInt(getComputedStyle(_узЧат).height, 10));
				}
				break;

			default:
				Проверить(false);
		}
	}

	function ОтменитьПеретаскиваниеПанели()
	{
		м_Тащилка.ОтменитьПеретаскивание('размерчата');
	}

	ОбработатьИзменениеПолноэкранногоРежима.чСостояниеВОбычномРежиме = -1;
	
	function ОбработатьИзменениеПолноэкранногоРежима(лВключен)
	{
		if (лВключен)
		{
			if (ОбработатьИзменениеПолноэкранногоРежима.чСостояниеВОбычномРежиме === -1)
			{
				ОбработатьИзменениеПолноэкранногоРежима.чСостояниеВОбычномРежиме = м_Настройки.Получить('чСостояниеЧата');
				if (ОбработатьИзменениеПолноэкранногоРежима.чСостояниеВОбычномРежиме === ЧАТ_ПАНЕЛЬ)
				{
					м_Настройки.Изменить('чСостояниеЧата', ЧАТ_СКРЫТ, true);
					ПрименитьСостояниеПанели();
				}
			}
		}
		else
		{
			if (ОбработатьИзменениеПолноэкранногоРежима.чСостояниеВОбычномРежиме !== -1)
			{
				if (ОбработатьИзменениеПолноэкранногоРежима.чСостояниеВОбычномРежиме === ЧАТ_ПАНЕЛЬ)
				{
					м_Настройки.Изменить('чСостояниеЧата', ЧАТ_ПАНЕЛЬ);
					ПрименитьСостояниеПанели();
				}
				else if (м_Настройки.Получить('чСостояниеЧата') === ЧАТ_СКРЫТ
				&& м_Настройки.Получить('чСостояниеЗакрытогоЧата') === ЧАТ_ВЫГРУЖЕН)
				{
					м_Настройки.Изменить('чСостояниеЧата', ЧАТ_ВЫГРУЖЕН);
					ПрименитьСостояниеПанели();
				}
				ОбработатьИзменениеПолноэкранногоРежима.чСостояниеВОбычномРежиме = -1;
			}
		}
	}

	function ПрименитьАдрес()
	// Вызвать, если изменились настройки, влияющие на адрес чата.
	{
		ПрименитьАдресПанели();
		ПрименитьАдресБоковойПанели();
	}

	function Восстановить()
	{
		ПрименитьСостояниеПанели();
		ПрименитьПоложениеПанели();
		м_События.ДобавитьОбработчик('тащилка-перетаскивание-размерчата', ОбработатьПеретаскиваниеПанели);
		м_События.ДобавитьОбработчик('полноэкранныйрежим-изменен', ОбработатьИзменениеПолноэкранногоРежима);
	}

	ПроверитьДоступностьБоковойПанели();
	
	return {
		Восстановить,
		ПрименитьПоложениеПанели,
		ПрименитьАдрес,
		СохранитьИПрименитьСостояниеЗакрытойПанели,
		ПереключитьСостояниеПанели,
		ПереключитьПоложениеПанели,
		ОткрытьБоковуюПанель
	};
})();

const м_Шкала = (() =>
{
	let _чНачало = 0;
	let _чКонец  = 0;
	let _чПросмотрено;

	function ОграничитьВремя(чВремя)
	{
		return Ограничить(чВремя, _чНачало, _чКонец);
	}

	function Обновить()
	{
		Проверить(Number.isFinite(_чНачало) && Number.isFinite(_чКонец) && Number.isFinite(_чПросмотрено));
		document.getElementById('шкала-просмотрено').style.transform = `scaleX(${((_чПросмотрено - _чНачало) / (_чКонец - _чНачало)).toFixed(4)})`;
	}

	const ОбработатьЩелчок = ДобавитьОбработчикИсключений(оСобытие =>
	{
		if (м_Управление.ПолучитьСостояние() !== СОСТОЯНИЕ_ПОВТОР)
		{
			return;
		}
		const оБордюр = оСобытие.currentTarget.getBoundingClientRect();
		const оСтиль = getComputedStyle(оСобытие.currentTarget);
		// У шкалы пока нет бордюра.
		const чНачалоШкалы = Math.round(оБордюр.left + Number.parseFloat(оСтиль.paddingLeft));
		const чКонецШкалы = Math.round(оБордюр.right - Number.parseFloat(оСтиль.paddingRight));
		// Windows 7: Hot spot курсора pointer находится левее центра указательного пальца. Исправляем это надоразумение.
		const чУказатель = оСобытие.clientX + 1;
		// Щелчок по левому полю перематывает на первый кадр. По правому полю - на последний.
		const чПеремотатьДо = ОграничитьВремя((чУказатель - чНачалоШкалы) / (чКонецШкалы - чНачалоШкалы) * (_чКонец - _чНачало) + _чНачало);
		м_Журнал.Окак(`[Шкала] Перематываю до ${чПеремотатьДо}`);
		м_Проигрыватель.ПеремотатьПовторДо(чПеремотатьДо);
	});

	function ЗадатьНачалоИКонец(чНачало, чКонец)
	{
		Проверить(чНачало <= чКонец);
		_чНачало = чНачало;
		_чКонец = чКонец;
		document.getElementById('шкала').addEventListener('click', ОбработатьЩелчок);
	}

	function ЗадатьПросмотрено(чПросмотрено)
	{
		_чПросмотрено = ОграничитьВремя(чПросмотрено);
		Обновить();
	}

	function ПолучитьНачало()
	{
		return _чНачало;
	}

	function ПолучитьКонец()
	{
		return _чКонец;
	}

	return {
		ЗадатьНачалоИКонец, ЗадатьПросмотрено,
		ПолучитьНачало, ПолучитьКонец
	};
})();

const м_Окна = (() =>
{
	function ПолучитьОткрытое()
	{
		return document.body.getAttribute('data-окно-открыто') || '';
	}

	function ОткрытьОкно(сИдОкна)
	{
		const узОкно = Узел(сИдОкна);
		Проверить(узОкно.classList.contains('окно'));
		узОкно.classList.add('окнооткрыто');
		document.body.setAttribute('data-окно-открыто', сИдОкна);
		м_События.ОбработатьСобытие(`окна-открыто-${сИдОкна}`);
	}

	function ЗакрытьОкно(сИдОкна)
	{
		const узОкно = Узел(сИдОкна);
		Проверить(узОкно.classList.contains('окно'));
		узОкно.classList.remove('окнооткрыто');
		document.body.removeAttribute('data-окно-открыто');
		м_События.ОбработатьСобытие('окна-закрыто', сИдОкна);
	}

	function Открыть(сИдОкна)
	{
		Проверить(ЭтоНепустаяСтрока(сИдОкна));
		const сИдОткрытогоОкна = ПолучитьОткрытое();
		if (сИдОкна === сИдОткрытогоОкна)
		{
			return false;
		}
		if (сИдОткрытогоОкна)
		{
			ЗакрытьОкно(сИдОткрытогоОкна);
		}
		ОткрытьОкно(сИдОкна);
		return true;
	}

	function Закрыть(сИдОкна)
	{
		Проверить(typeof сИдОкна === 'string');
		if (!сИдОкна || сИдОкна !== ПолучитьОткрытое())
		{
			return false;
		}
		ЗакрытьОкно(сИдОкна);
		return true;
	}

	function Переключить(сИдОкна)
	{
		Открыть(сИдОкна) || ЗакрытьОкно(сИдОкна);
	}

	function ОбработатьЛевыйЩелчок({target: узЩелчок})
	{
		// Щелчок по пункту меню не должен закрывать окно.
		if (Узел('проигрыватель').contains(узЩелчок))
		{
			const сИдОкна = узЩелчок.getAttribute('data-окно-переключить');
			if (сИдОкна)
			{
				Переключить(сИдОкна);
			}
			else
			{
				const сИдОткрытогоОкна = ПолучитьОткрытое();
				if (сИдОткрытогоОкна && !Узел(сИдОткрытогоОкна).contains(узЩелчок))
				{
					ЗакрытьОкно(сИдОткрытогоОкна);
				}
			}
		}
	}

	м_События.ДобавитьОбработчик('управление-левыйщелчок', ОбработатьЛевыйЩелчок);

	return {
		ПолучитьОткрытое,
		Открыть,
		Закрыть,
		Переключить
	};
})();

const м_Меню = (() =>
{
	function ПолучитьОткрытоеМеню()
	{
		return document.getElementsByClassName('менюоткрыто')[0];
	}

	function ОткрытьМеню(узМеню)
	{
		Проверить(узМеню.id);
		Проверить(узМеню.classList.contains('меню'));
		document.body.classList.remove('меню-безанимации');
		document.body.classList.add('меню-открыто');
		узМеню.classList.add('менюоткрыто');
		м_События.ОбработатьСобытие(`меню-открыто-${узМеню.id}`);
	}

	function ЗакрытьМеню(узМеню, лБезАнимации)
	{
		Проверить(узМеню.classList.contains('меню'));
		document.body.classList.toggle('меню-безанимации', лБезАнимации);
		document.body.classList.remove('меню-открыто');
		узМеню.classList.remove('менюоткрыто');
	}

	function Закрыть(лБезАнимации)
	{
		const узОткрытоеМеню = ПолучитьОткрытоеМеню();
		if (узОткрытоеМеню)
		{
			ЗакрытьМеню(узОткрытоеМеню, лБезАнимации);
		}
	}

	function ПереместитьМенюКТочке(узМеню, x, y)
	// getComputedStyle() не учитывает transform, getBoundingClientRect() учитывает.
	{
		const оСтиль = getComputedStyle(узМеню);
		const чШиринаМеню = Number.parseFloat(оСтиль.width,  10);
		const чВысотаМеню = Number.parseFloat(оСтиль.height, 10);
		const чШиринаОкна = window.innerWidth;
		const чВысотаОкна = window.innerHeight;

		let чМенюX;
		if (x + чШиринаМеню <= чШиринаОкна)
		{
			// Оставить курсор вне меню, чтобы щелчок левой кнопкой закрыл меню.
			// Такая большая поправка нужна для Chrome 68 с измененным масштабом.
			чМенюX = x + 1.999;
		}
		else if (чШиринаМеню <= x)
		{
			чМенюX = x - чШиринаМеню - 0.5;
		}
		else
		{
			чМенюX = Math.max(чШиринаОкна - чШиринаМеню, 0);
		}

		let чМенюY;
		if (y + чВысотаМеню <= чВысотаОкна)
		{
			чМенюY = y + 1.999;
		}
		else
		{
			// По возможности размещаем меню ниже курсора, потому что часто используемые команды
			// находятся в верхней части главного меню. Предполагается, что ширина окна минимум
			// в 2 раза больше ширины меню и поэтому курсор окажется вне меню.
			чМенюY = Math.max(чВысотаОкна - чВысотаМеню, 0);
		}

		узМеню.style.left = `${чМенюX}px`;
		узМеню.style.top  = `${чМенюY}px`;
	}

	function ПереместитьМенюКЭлементу(узМеню, узЭлемент)
	{
		const {left: x, top: y, right: x2, bottom: y2} = узЭлемент.getBoundingClientRect();
		const оСтиль = getComputedStyle(узМеню);
		const чШиринаМеню = Number.parseFloat(оСтиль.width,  10);
		const чВысотаМеню = Number.parseFloat(оСтиль.height, 10);
		const чШиринаОкна = window.innerWidth;
		const чВысотаОкна = window.innerHeight;

		let чМенюX;
		if (x + чШиринаМеню <= чШиринаОкна)
		{
			чМенюX = x;
		}
		else if (чШиринаМеню <= x2)
		{
			чМенюX = x2 - чШиринаМеню;
		}
		else
		{
			чМенюX = Math.max(чШиринаОкна - чШиринаМеню, 0);
		}

		let чМенюY;
		if (y2 + чВысотаМеню <= чВысотаОкна)
		{
			чМенюY = y2;
		}
		else if (чВысотаМеню <= y)
		{
			чМенюY = y - чВысотаМеню;
		}
		else
		{
			чМенюY = Math.max(чВысотаОкна - чВысотаМеню, 0);
		}

		узМеню.style.left = `${чМенюX}px`;
		узМеню.style.top  = `${чМенюY}px`;
		узМеню.style.minWidth = `${x2 - x}px`;
	}

	const ОбработатьКонтекстноеМеню = ДобавитьОбработчикИсключений(оСобытие =>
	{
		const узОткрытоеМеню = ПолучитьОткрытоеМеню();
		if (узОткрытоеМеню && узОткрытоеМеню.contains(оСобытие.target))
		{
			// Ссылки в меню выделять запрещено, поэтому ЭтоСобытиеДляСсылки() вместо ЭтотЭлементМожноВыделить().
			if (!ЭтоСобытиеДляСсылки(оСобытие))
			{
				оСобытие.preventDefault();
			}
			return;
		}
		// Контекстное меню браузера запрещать...
		// - Нужно для тега video, команды которого могут поломать работу проигрывателя.
		// - Нельзя для ссылок, там есть полезные команды. Ссылки разрешено выделять.
		// - Нельзя для элементов, содержимое которых можно выделить, потому что на сенсорном экране выделение
		//   начинается "правым щелчком". На настольных компьютерах контекстное меню браузера пригодится, чтобы
		//   совершить действие над выделенным текстом: копировать, искать в интернете.
		let узОткрытьМеню = null;
		if (!ЭтотЭлементМожноВыделить(оСобытие.target))
		{
			оСобытие.preventDefault();
			узОткрытьМеню = Узел('главноеменю');
		}
		if (узОткрытоеМеню && узОткрытоеМеню !== узОткрытьМеню)
		{
			ЗакрытьМеню(узОткрытоеМеню, false);
		}
		if (узОткрытьМеню)
		{
			// Edge 17: С измененным масштабом координаты могут быть дробными.
			ПереместитьМенюКТочке(узОткрытьМеню, оСобытие.clientX, оСобытие.clientY);
			if (узОткрытьМеню !== узОткрытоеМеню)
			{
				ОткрытьМеню(узОткрытьМеню);
			}
		}
	});

	function ОбработатьЛевыйЩелчок({target: узЩелчок})
	{
		// Закрыть меню после щелчка по его пункту.
		if (узЩелчок.classList.contains('меню-пункт'))
		{
			ЗакрытьМеню(узЩелчок.parentNode, true);
			return;
		}
		const узОткрытоеМеню = ПолучитьОткрытоеМеню();
		if (узОткрытоеМеню && !узОткрытоеМеню.contains(узЩелчок))
		{
			ЗакрытьМеню(узОткрытоеМеню, false);
		}
		// Открыть меню после нажатия на кнопку.
		const сОткрытьМеню = узЩелчок.getAttribute('data-меню-переключить');
		if (сОткрытьМеню)
		{
			const узОткрытьМеню = Узел(сОткрытьМеню);
			if (узОткрытьМеню !== узОткрытоеМеню)
			{
				// Не использовать координаты из оСобытие, они без дробных частей, поэтому будут нестыковки в 1-2 пиксела.
				ПереместитьМенюКЭлементу(узОткрытьМеню, узЩелчок);
				ОткрытьМеню(узОткрытьМеню);
			}
		}
	}

	function ОбработатьИзменениеПолноэкранногоРежима(лВключен)
	{
		Закрыть(true);
	}

	// Нажатие SHIFT+F10 может послать событие в html и body.
	// Не вешать на document, Firefox 60 может послать туда событие во время загрузки страницы.
	// report://00000000000000_15274341445
	document.documentElement.addEventListener('contextmenu', ОбработатьКонтекстноеМеню);
	м_События.ДобавитьОбработчик('управление-левыйщелчок', ОбработатьЛевыйЩелчок);
	м_События.ДобавитьОбработчик('полноэкранныйрежим-изменен', ОбработатьИзменениеПолноэкранногоРежима);

	return {Закрыть};
})();

const м_ПолноэкранныйРежим = (() =>
{
	let _sRequestFullscreen = 'requestFullscreen';
	let _sExitFullscreen    = 'exitFullscreen';
	let _sFullscreenElement = 'fullscreenElement';
	let _sFullscreenchange  = 'fullscreenchange';
	if (!document.requestFullscreen)
	{
		_sRequestFullscreen = 'webkitRequestFullscreen';
		_sExitFullscreen    = 'webkitExitFullscreen';
		_sFullscreenElement = 'webkitFullscreenElement';
		_sFullscreenchange  = 'webkitfullscreenchange';
	}

	const ОбработатьИзменениеРежима = ДобавитьОбработчикИсключений(() =>
	{
		const лВключен = Обновить();
		м_События.ОбработатьСобытие('полноэкранныйрежим-изменен', лВключен);
	});

	const ОбработатьДвойнойЩелчок = ДобавитьОбработчикИсключений(оСобытие =>
	{
		// Вешать переход в полноэкранный режим на все элементы страницы нельзя,
		// потому что двойным щелчком выделяют текст и быстро нажимают на кнопку.
		if (оСобытие.button === ЛЕВАЯ_КНОПКА && оСобытие.target.id === 'проигрыватель')
		{
			оСобытие.preventDefault();
			Переключить();
		}
	});

	function Включен()
	{
		return !!document[_sFullscreenElement];
	}

	function Обновить()
	{
		const лВключен = Включен();
		м_Журнал.Окак(`[ПолноэкранныйРежим] Текущее состояние: ${лВключен}`);
		ИзменитьКнопку('переключитьполноэкранный', лВключен);
		return лВключен;
	}

	function Включить()
	{
		if (Включен())
		{
			return false;
		}
		м_Журнал.Вот('[ПолноэкранныйРежим] Вход в полноэкранный режим');
		м_Автоскрытие.Скрыть(true);
		// В полноэкранном режиме должно быть доступно контекстное меню.
		document.getElementById('проигрывательичат')[_sRequestFullscreen]();
		return true;
	}

	function Отключить()
	// Может вызываться до Запустить().
	{
		if (!Включен())
		{
			return false;
		}
		м_Журнал.Вот('[ПолноэкранныйРежим] Выход из полноэкранного режима');
		м_Автоскрытие.Скрыть(true);
		document[_sExitFullscreen]();
		return true;
	}

	function Переключить()
	{
		Включить() || Отключить();
	}

	document.addEventListener(_sFullscreenchange, ОбработатьИзменениеРежима);
	document.addEventListener('dblclick', ОбработатьДвойнойЩелчок);
	Обновить();

	return {
		Включен,
		Отключить,
		Переключить
	};
})();

const м_Уведомление = (() =>
// TODO Новое уведомление не заменяет незавершенное, а помещается в очередь.
// TODO Игнорировать идущие подряд одинаковые уведомления.
{
	const ПОКАЗЫВАТЬ_УВЕДОМЛЕНИЕ = 2000; // Миллисекунды.

	let _чТаймер = 0;

	function Показать(сИдЗначка, лЖопа)
	{
		Проверить(document.getElementById(сИдЗначка) && typeof лЖопа === 'boolean');
		const узУведомление = document.getElementById('уведомление');
		узУведомление.classList.toggle('жопа', лЖопа);
		узУведомление.firstElementChild.setAttributeNS('http://www.w3.org/1999/xlink', 'href', `#${сИдЗначка}`);
		ПоказатьЭлемент(узУведомление, true);
		if (_чТаймер !== 0)
		{
			clearTimeout(_чТаймер);
		}
		_чТаймер = setTimeout(СкрытьУведомление, ПОКАЗЫВАТЬ_УВЕДОМЛЕНИЕ);
	}

	function ПоказатьСчастье()
	{
		Показать('svg-success', false);
	}

	function ПоказатьЖопу()
	{
		Показать('svg-fail', true);
	}

	const СкрытьУведомление = ДобавитьОбработчикИсключений(() =>
	{
		ПоказатьЭлемент('уведомление', false);
		_чТаймер = 0;
	});

	return {
		Показать,
		ПоказатьСчастье, ПоказатьЖопу
	};
})();

const м_Автоскрытие = (() =>
{
	const МИН_ИНТЕРВАЛ_ПЕРЕМЕЩЕНИЯ_МЫШИ = 95;  // Миллисекунды. Минимальный интервал следования событий mousemove.
	const ПОРОГ_НАЧАЛА_ДВИЖЕНИЯ         = 90;  // Миллисекунды. Частота опроса мыши >= 60 Гц.
	const ПОРОГ_ОКОНЧАНИЯ_ДВИЖЕНИЯ      = 300; // Миллисекунды.
	
	const _узАвтоскрытие = document.getElementById('проигрыватель');

	let _чТаймер = 0; // 0 если таймер не активен и интерфейс скрыт.
	let _чСкрытьВ;
	let _nScreenX, _nScreenY;
	let _nClientX, _nClientY;
	let _чНачалоДвижения = 0;
	let _чПоследнееДвижение = 0;

	const ОбработатьТаймер = ДобавитьОбработчикИсключений(() =>
	{
		Проверить(_чТаймер !== 0);
		const чСкрытьЧерез = _чСкрытьВ - performance.now();
		if (чСкрытьЧерез > 100)
		{
			_чТаймер = setTimeout(ОбработатьТаймер, чСкрытьЧерез);
			_чСкрытьВ = 0;
		}
		else
		{
			Скрыть(false);
		}
	});

	function Показать()
	{
		if (_чТаймер === 0)
		{
			document.body.classList.remove('автоскрытие', 'панель-безанимации');
			_чТаймер = setTimeout(ОбработатьТаймер, м_Настройки.Получить('чИнтервалАвтоскрытия') * 1000);
			_чСкрытьВ = 0;
		}
		else
		{
			// Не вызывать лишний раз clearTimeout() и setTimeout().
			_чСкрытьВ = performance.now() + м_Настройки.Получить('чИнтервалАвтоскрытия') * 1000;
		}
	}

	function Скрыть(лБезАнимации)
	// Может вызываться до Запустить().
	{
		if (_чТаймер !== 0)
		{
			clearTimeout(_чТаймер);
			_чТаймер = 0;
			document.body.classList.add('автоскрытие');
			document.body.classList.toggle('панель-безанимации', лБезАнимации);
			if (лБезАнимации)
			{
				// Не реагировать на небольшие движения мыши.
				_чНачалоДвижения = _чПоследнееДвижение = 0;
			}
		}
	}

	function ОбработатьРедкоеДвижениеМыши(оСобытие)
	{
		// Chrome 52: При входе в полноэкранный режим посылаются mousemove, даже если мышь не двигалась.
		// Windows 7: Координаты screen могут изменяться во время WIN + TAB, поэтому добавляем проверку client.
		if ((_nScreenX !== оСобытие.screenX || _nScreenY !== оСобытие.screenY)
		&&  (_nClientX !== оСобытие.clientX || _nClientY !== оСобытие.clientY))
		{
			_nScreenX = оСобытие.screenX; _nScreenY = оСобытие.screenY;
			_nClientX = оСобытие.clientX; _nClientY = оСобытие.clientY;
			// Можно заменить на performance.now().
			const чВремя = оСобытие.timeStamp;
			if (чВремя - _чПоследнееДвижение >= ПОРОГ_ОКОНЧАНИЯ_ДВИЖЕНИЯ)
			{
				_чНачалоДвижения = чВремя;
			}
			// Игнорировать движение, продолжительность которого меньше ПОРОГ_НАЧАЛА_ДВИЖЕНИЯ. Зритель мог случайно задеть
			// мышь или стол, на котором она лежит. "Лишнее" отключение автоскрытия во время просмотра может мешать.
			else if (чВремя - _чНачалоДвижения >= ПОРОГ_НАЧАЛА_ДВИЖЕНИЯ)
			{
				Показать();
			}
			_чПоследнееДвижение = чВремя;
		}
	}

	const ОбработатьДвижениеМыши = ДобавитьОбработчикИсключений(оСобытие =>
	{
		// mousemove может посылаться с частотой 1000 Гц. В этом случае моя обработка события занимает
		// всего пару процентов не самого сильного процессора. Но Chrome 51 не любит, когда часто вызывается
		// setTimeout(), да и очередь ни к чему захламлять ненужными событиями. Поэтому частота обработки
		// mousemove уменьшается до МИН_ИНТЕРВАЛ_ПЕРЕМЕЩЕНИЯ_МЫШИ. Высокая точность для автоскрытия не требуется.
		_узАвтоскрытие.removeEventListener('mousemove', ОбработатьДвижениеМыши);
		setTimeout(ПерехватитьДвижениеМыши, МИН_ИНТЕРВАЛ_ПЕРЕМЕЩЕНИЯ_МЫШИ);
		ОбработатьРедкоеДвижениеМыши(оСобытие);
	});

	const ПерехватитьДвижениеМыши = ДобавитьОбработчикИсключений(() =>
	{
		_узАвтоскрытие.addEventListener('mousemove', ОбработатьДвижениеМыши);
	});

	const ОбработатьЩелчок = ДобавитьОбработчикИсключений(оСобытие =>
	{
		// Переустановить таймер. Важно для сенсорного экрана, mousemove которого не показывает интерфейс.
		Показать();
	});

	const ОбработатьПокиданиеМыши = ДобавитьОбработчикИсключений(() =>
	{
		Скрыть(false);
	});

	function Запустить()
	{
		ПерехватитьДвижениеМыши();
		_узАвтоскрытие.addEventListener('click', ОбработатьЩелчок);
		_узАвтоскрытие.addEventListener('mouseleave', ОбработатьПокиданиеМыши);
	}

	return {
		Запустить,
		Скрыть,
		Показать
	};
})();

const м_Управление = (() =>
{
	// После изменения этой константы также изменить всплывающую подсказку.
	const ПЕРЕМАТЫВАТЬ_СТРЕЛКАМИ_НА     = 5;   // Секунды, назад и вперед.
	const ПЕРЕМАТЫВАТЬ_ПО_КАДРАМ_НА     = 5;   // Кадры, только назад.

	// Текст для ссылки до получения метаданных.
	const НАЗВАНИЕ_ТРАНСЛЯЦИИ_НЕИЗВЕСТНО = '• • •';

	const ЯЗЫКИ =
	{
		'da':    'Dansk',
		'de':    'Deutsch',
		'en':    'English',
		'en-gb': 'English (UK)',
		'es':    'Español',
		'es-mx': 'Español (Latinoamérica)',
		'fr':    'Français',
		'it':    'Italiano',
		'hu':    'Magyar',
		'nl':    'Nederlands',
		'no':    'Norsk',
		'pl':    'Polski',
		'pt':    'Português',
		'pt-br': 'Português (Brasil)',
		'sk':    'Slovenčina',
		'fi':    'Suomi',
		'sv':    'Svenska',
		'vi':    'Tiếng Việt',
		'tr':    'Türkçe',
		'cs':    'Čeština',
		'el':    'Ελληνικά',
		'bg':    'Български',
		'ru':    'Русский',
		'ar':    'العربية',
		'th':    'ภาษาไทย',
		'zh':    '中文',
		'zh-cn': '简体中文',
		'zh-tw': '繁體中文',
		'zh-hk': '中文（香港）',
		'ja':    '日本語',
		'ko':    '한국어',
		'hi':    'हिंदी',
		'ro':    'Română',
		'ase':   'American Sign Language',
		'asl':   'American Sign Language' // Twitch передает этот неправильный код.
	};

	let _чСостояние;
	let _оНачалоВоспроизведения, _оРазмерБуфера, _оРастягиваниеБуфера, _оИнтервалОбновленияСписков, _оДлительностьПовтора;
	let _оРазмерИнтерфейса, _оИнтервалАвтоскрытия;

	function ЗапуститьИзменениеГромкостиКолесом()
	{
		if (м_Настройки.Получить('лМенятьГромкостьКолесом'))
		{
			document.addEventListener('wheel', ОбработатьВращениеКолеса);
			document.addEventListener('mousedown', ОбработатьНажатиеКолеса);
		}
		else
		{
			document.removeEventListener('wheel', ОбработатьВращениеКолеса);
			document.removeEventListener('mousedown', ОбработатьНажатиеКолеса);
		}
	}

	const ОбработатьВращениеКолеса = ДобавитьОбработчикИсключений(оСобытие =>
	{
		if (!оСобытие.shiftKey && !оСобытие.ctrlKey && !оСобытие.altKey && !оСобытие.metaKey
		&& !ЭлементВЭтойТочкеМожноПрокрутить(оСобытие.clientX, оСобытие.clientY))
		{
			// Chrome 59 переводит строки в пикселы. Edge 15 переводит строки и страницы в пикселы.
			м_Журнал.Вот(`[Управление] Движение колеса deltaY=${оСобытие.deltaY} deltaMode=${оСобытие.deltaMode}`);
			оСобытие.preventDefault();
			// Оставить звук приглушенным, потому что зритель мог случайно задеть колесо.
			// Кроме того, см. коментарий в НачатьВоспроизведение() для Chrome.
			if (оСобытие.deltaY < 0)
			{
				СохранитьИПрименитьНастройкиЗвука(undefined, Math.min(м_Настройки.Получить('чГромкость2') + ШАГ_ПОВЫШЕНИЯ_ГРОМКОСТИ_КОЛЕСОМ, МАКСИМАЛЬНАЯ_ГРОМКОСТЬ));
			}
			if (оСобытие.deltaY > 0)
			{
				СохранитьИПрименитьНастройкиЗвука(undefined, Math.max(м_Настройки.Получить('чГромкость2') - ШАГ_ПОНИЖЕНИЯ_ГРОМКОСТИ_КОЛЕСОМ, МИНИМАЛЬНАЯ_ГРОМКОСТЬ));
			}
		}
	});

	const ОбработатьНажатиеКолеса = ДобавитьОбработчикИсключений(оСобытие =>
	{
		if (оСобытие.button === СРЕДНЯЯ_КНОПКА
		&& !оСобытие.shiftKey && !оСобытие.ctrlKey && !оСобытие.altKey && !оСобытие.metaKey
		&& !ЭтоСобытиеДляСсылки(оСобытие))
		{
			оСобытие.preventDefault();
			СохранитьИПрименитьНастройкиЗвука(!м_Настройки.Получить('лПриглушить'));
		}
	});

	function ПрименитьМасштабированиеИзображения()
	{
		Узел('глаз').classList.toggle('масштабировать', м_Настройки.Получить('лМасштабироватьИзображение'));
	}

	function ПрименитьРазмерИнтерфейса()
	{
		// Не используем для 100% небольшие числа, например 1px, которые могут быть перебиты
		// настройкой минимального размера шрифта браузера. На данный момент 16px можно заменить
		// на большее значение (пересчитав rem в css). 10px маловато, потому что значение настройки
		// может быть меньше 100%.
		document.documentElement.style.fontSize = `${16 * м_Настройки.Получить('чРазмерИнтерфейса') / 100}px`;
	}

	function ПрименитьАнимациюИнтерфейса()
	{
		document.body.classList.toggle('санимацией', м_Настройки.Получить('лАнимацияИнтерфейса'));
	}

	function ОстановитьПросмотрТрансляции()
	{
		if (_чСостояние === СОСТОЯНИЕ_ОСТАНОВКА || _чСостояние === СОСТОЯНИЕ_ПОВТОР)
		{
			return false;
		}
		м_Журнал.Окак('[Управление] Останавливаю просмотр трансляции');
		м_Список.Остановить();
		// Удалить сегменты, застрявшие в рабочем потоке.
		м_Преобразователь.Остановить();
		// Очистить очередь и отменить загрузку сегментов.
		г_моОчередь.Очистить();
		// Изменить состояние, остановить воспроизведение, сменить поведение на повтор.
		г_моОчередь.Добавить(new Сегмент(ОБРАБОТКА_ПРЕОБРАЗОВАН, СОСТОЯНИЕ_ПОВТОР));
		// Ждать завершение _лАсинхроннаяОперация.
		м_Проигрыватель.ДобавитьСледующийСегмент();
		return true;
	}

	function ПереключитьПросмотрТрансляции()
	{
		if (!ОстановитьПросмотрТрансляции())
		{
			м_Журнал.Окак('[Управление] Начинаю просмотр трансляции');
			// Удалить СОСТОЯНИЕ_ПОВТОР если оно еще находится в очереди.
			г_моОчередь.Очистить();
			// Изменить состояние, очистить буфер проигрывателя, сменить поведение на прямую трансляцию.
			м_Проигрыватель.Перезагрузить(СОСТОЯНИЕ_ЗАПУСК);
			м_Список.Запустить();
		}
	}

	function ПереключитьОкноСтатистики()
	{
		if (м_Статистика.ОкноПоказано())
		{
			м_Статистика.ЗакрытьОкно();
		}
		else
		{
			м_Статистика.ОткрытьОкно();
		}
	}
	
	function ПереключитьПроверкуЦвета(оСобытие)
	{
		if (document.body.classList.toggle('проверкацвета'))
		{
			document.body.classList.toggle('проверкацветафон', !оСобытие.shiftKey);
			м_Новости.ОткрытьСправку();
		}
		else
		{
			document.body.classList.remove('проверкацветафон');
		}
	}

	function СоздатьКлип()
	{
		if (!м_Twitch.СоздатьКлип())
		{
			м_Уведомление.ПоказатьЖопу();
		}
	}

	function КопироватьТекстВБуферОбмена(сТекст)
	{
		Проверить(typeof сТекст === 'string');
		if (сТекст === '')
		{
			м_Уведомление.ПоказатьЖопу();
			return;
		}
		navigator.clipboard.writeText(сТекст)
		.then(
			() =>
			{
				м_Журнал.Вот('[Управление] Копирование в буфер обмена завершено');
				м_Уведомление.ПоказатьСчастье();
			},
			пПричина =>
			{
				м_Журнал.Ой(`[Управление] Ошибка при копировании в буфер обмена: ${пПричина}`);
				м_Уведомление.ПоказатьЖопу();
			}
		)
		.catch(м_Отладка.ПойманоИсключение);
	}

	function КопироватьАдресТрансляцииВБуферОбмена()
	{
		if (КопироватьАдресТрансляцииВБуферОбмена.лИдетВыполнение)
		{
			return;
		}
		КопироватьАдресТрансляцииВБуферОбмена.лИдетВыполнение = true;
		м_Журнал.Окак('[Управление] Получаю адрес трансляции для копирования');
		// VLC Media Player не любит https.
		м_Twitch.ПолучитьАбсолютныйАдресСпискаВариантов(null, true)
		.then(сРезультат =>
		{
			м_Журнал.Вот('[Управление] Копирую адрес трансляции в буфер обмена');
			// Firefox: Расширение должно иметь разрешение clipboardWrite, чтобы
			// записывать в буфер обмена вне обработчика действия пользователя.
			return navigator.clipboard.writeText(сРезультат)
			.then(
				() =>
				{
					КопироватьАдресТрансляцииВБуферОбмена.лИдетВыполнение = false;
					м_Журнал.Вот('[Управление] Копирование в буфер обмена завершено');
					м_Уведомление.ПоказатьСчастье();
					м_Управление.ОстановитьПросмотрТрансляции();
				},
				// Не помещаем этот обработчик в главную цепочку обещаний, чтобы можно
				// было отделить ошибки копирования от ошибок получения адреса.
				пПричина =>
				{
					// Преобразуем пПричина в строку.
					throw `Ошибка при копировании в буфер обмена: ${пПричина}`;
				}
			);
		})
		.catch(ДобавитьОбработчикИсключений(пПричина =>
		{
			КопироватьАдресТрансляцииВБуферОбмена.лИдетВыполнение = false;
			if (typeof пПричина === 'string')
			{
				м_Журнал.Ой(`[Управление] Ошибка при копировании адреса трансляции в буфер обмена: ${пПричина}`);
				м_Уведомление.ПоказатьЖопу();
			}
			else
			{
				throw пПричина;
			}
		}));
	}

	const ОбработатьИзменениеГромкости = ДобавитьОбработчикИсключений(оСобытие =>
	{
		СохранитьИПрименитьНастройкиЗвука(false, Number.parseFloat(оСобытие.target.value));
	});

	function СохранитьИПрименитьНастройкиЗвука(лПриглушить /* необязательный */, чГромкость /* необязательный */)
	{
		Проверить(лПриглушить !== undefined || чГромкость !== undefined);
		if (лПриглушить !== undefined)
		{
			м_Настройки.Изменить('лПриглушить', лПриглушить);
		}
		if (чГромкость !== undefined)
		{
			м_Настройки.Изменить('чГромкость2', Math.round(чГромкость));
		}
		ОбновитьНастройкиЗвука();
		м_Проигрыватель.ПрименитьНастройкиЗвука();
		м_Автоскрытие.Показать();
	}

	function ОбновитьНастройкиЗвука()
	{
		document.getElementById('громкость').value = м_Настройки.Получить('чГромкость2');
		ИзменитьКнопку('переключитьприглушить', м_Настройки.Получить('лПриглушить'));
	}

	function ИзменитьПодпискуЗрителяНаКанал(чПодписка)
	{
		// pointer-events: none позволяет нажимать кнопки клавой.
		if (!document.getElementById('зритель-подписка').classList.contains('обновляется'))
		{
			м_Twitch.ИзменитьПодпискуЗрителяНаКанал(чПодписка);
		}
	}

	const ОбработатьЛевыйЩелчок = ДобавитьОбработчикИсключений(оСобытие =>
	{
		if (оСобытие.button !== ЛЕВАЯ_КНОПКА)
		{
			return;
		}

		const узЩелчок = оСобытие.target;
		let узПозывной = узЩелчок;
		let сПозывной = узПозывной.id || узПозывной.name;
		if (!сПозывной && узЩелчок.parentNode)
		{
			узПозывной = узЩелчок.parentNode;
			сПозывной = узПозывной.id || узПозывной.name;
		}

		оСобытие.узПозывной = узПозывной;
		оСобытие.сПозывной = сПозывной;
		м_События.ОбработатьСобытие('управление-левыйщелчок', оСобытие);

		switch (сПозывной)
		{
		case 'переключитьтрансляцию':
			ПереключитьПросмотрТрансляции();
			break;

		case 'переключитьпаузу':
			if (_чСостояние === СОСТОЯНИЕ_ПОВТОР)
			{
				м_Проигрыватель.ПереключитьПаузу();
			}
			break;

		case 'переключитьприглушить':
			СохранитьИПрименитьНастройкиЗвука(!м_Настройки.Получить('лПриглушить'));
			break;

		case 'переключитьчат':
			м_Чат.ПереключитьСостояниеПанели();
			break;

		case 'создатьклип':
			СоздатьКлип();
			break;

		case 'переключитьполноэкранный':
			м_ПолноэкранныйРежим.Переключить();
			break;

		case 'одновременныхзагрузок':
			Проверить(узЩелчок.checked);
			м_Настройки.Изменить('кОдновременныхЗагрузок', Number.parseInt(узЩелчок.value, 10));
			м_Статистика.ОчиститьИсторию();
			break;

		case 'менятьгромкостьколесом':
			м_Настройки.Изменить('лМенятьГромкостьКолесом', узЩелчок.checked);
			ЗапуститьИзменениеГромкостиКолесом();
			break;

		case 'анимацияинтерфейса':
			м_Настройки.Изменить('лАнимацияИнтерфейса', узЩелчок.checked);
			ПрименитьАнимациюИнтерфейса();
			break;

		case 'масштабироватьизображение':
			м_Настройки.Изменить('лМасштабироватьИзображение', узЩелчок.checked);
			ПрименитьМасштабированиеИзображения();
			break;


		case 'автоположениечата':
			м_Настройки.Изменить('лАвтоПоложениеЧата', узЩелчок.checked);
			ОбновитьОкноНастроек();
			м_Чат.ПрименитьПоложениеПанели();
			break;

		case 'горизонтальноеположениечата':
			Проверить(узЩелчок.checked);
			м_Настройки.Изменить('чГоризонтальноеПоложениеЧата', Number.parseInt(узЩелчок.value, 10));
			м_Чат.ПрименитьПоложениеПанели();
			break;

		case 'вертикальноеположениечата':
			Проверить(узЩелчок.checked);
			м_Настройки.Изменить('чВертикальноеПоложениеЧата', Number.parseInt(узЩелчок.value, 10));
			м_Чат.ПрименитьПоложениеПанели();
			break;

		case 'положениечата':
			Проверить(узЩелчок.checked);
			м_Настройки.Изменить('чПоложениеПанелиЧата', Number.parseInt(узЩелчок.value, 10));
			м_Чат.ПрименитьПоложениеПанели();
			break;

		case 'состояниезакрытогочата':
			Проверить(узЩелчок.checked);
			м_Чат.СохранитьИПрименитьСостояниеЗакрытойПанели(Number.parseInt(узЩелчок.value, 10));
			break;

		case 'переключитьстатистику':
		case 'позиция-текст':
			ПереключитьОкноСтатистики();
			break;

		case 'открытьновости':
		case 'открытьновости2':
			м_Новости.ОткрытьНовости();
			break;

		case 'открытьсправку':
			м_Новости.ОткрытьСправку();
			break;

		case 'отправитьотзыв':
			м_Отладка.ЗавершитьРаботуИОтправитьОтзыв();
			break;

		case 'экспортнастроек':
			м_Настройки.Экспорт();
			break;

		case 'импортнастроек':
			const уз = document.getElementById('выборфайладляимпортанастроек');
			уз.value = ''; // onchange
			уз.click();
			break;

		case 'сброситьнастройки':
			м_Настройки.Сбросить();
			break;

		case 'проверкацвета':
			ПереключитьПроверкуЦвета(оСобытие);
			break;

		case 'типтрансляции':
			Проверить(узЩелчок.nodeName === 'BUTTON');
			if (!узЩелчок.disabled)
			{
				window.location.assign(узЩелчок.getAttribute('data-адрес'));
			}
			break;

		case 'зритель-подписаться':
			ИзменитьПодпискуЗрителяНаКанал(ПОДПИСКА_УВЕДОМЛЯТЬ);
			break;

		case 'зритель-отписаться':
			ИзменитьПодпискуЗрителяНаКанал(ПОДПИСКА_НЕОФОРМЛЕНА);
			break;

		case 'зритель-уведомлять':
			ИзменитьПодпискуЗрителяНаКанал(узЩелчок.checked ? ПОДПИСКА_УВЕДОМЛЯТЬ : ПОДПИСКА_НЕУВЕДОМЛЯТЬ);
			break;

		case 'открытьбоковуюпанель':
			м_Чат.ОткрытьБоковуюПанель();
			break;

		case 'закрытьстатистику':
			м_Статистика.ЗакрытьОкно();
			break;

		case 'копироватьадресзаписи':
			м_Журнал.Вот('[Управление] Копирую адрес записи в буфер обмена');
			КопироватьТекстВБуферОбмена(м_Twitch.ПолучитьАдресЗаписиДляТекущейПозиции());
			break;

		case 'копироватьадресканала':
			м_Журнал.Вот('[Управление] Копирую адрес канала в буфер обмена');
			КопироватьТекстВБуферОбмена(м_Twitch.ПолучитьАдресКанала(false));
			break;

		case 'копироватьадрестрансляции':
			КопироватьАдресТрансляцииВБуферОбмена();
			break;
		}
	});

	const ОбработатьНажатиеИОтпусканиеКлавы = ДобавитьОбработчикИсключений(оСобытие =>
	// Firefox 47: <button> нажимается по отпусканию SPACE.
	// TODO Проверять <input type=text>.
	{
		const SHIFT_KEY = 1 << 16;
		const CTRL_KEY  = 1 << 17;
		const ALT_KEY   = 1 << 18;
		const META_KEY  = 1 << 19;

		const лНажатие = оСобытие.type === 'keydown';
		const лНажатие1 = лНажатие && !оСобытие.repeat;
		switch (оСобытие.keyCode + оСобытие.shiftKey * SHIFT_KEY + оСобытие.ctrlKey * CTRL_KEY + оСобытие.altKey * ALT_KEY + оСобытие.metaKey * META_KEY)
		{
		case 13: // ENTER
		case 13 + ALT_KEY: // ALT + ENTER
			if (лНажатие1)
			{
				м_ПолноэкранныйРежим.Переключить();
			}
			break;

		case 27: // ESC
			// Firefox на нажатие ESC прерывает загрузку фрейма с чатом. Отключаем это безобразие.
			// Отключаем ДО выполнения команды, чтобы браузер не прервал загрузку фрейма с отчетом
			// об ошибке, если ошибка произойдет во время выполнения этой команды.
			оСобытие.preventDefault();
			if (лНажатие1)
			{
				м_Меню.Закрыть(true);
				м_Окна.Закрыть(м_Окна.ПолучитьОткрытое());
				м_Автоскрытие.Скрыть(true);
			}
			break;

		case 86: // V
			if (лНажатие1)
			{
				м_Окна.Переключить('настройки');
			}
			break;

		case 73: // I
			if (лНажатие1)
			{
				м_Окна.Переключить('канал');
			}
			break;

		case 83: // S
			if (лНажатие1)
			{
				ПереключитьОкноСтатистики();
			}
			break;

		case 112: // F1
			if (лНажатие1)
			{
				м_Новости.ОткрытьСправку();
			}
			break;

		case 67: // C
		case 45: // INSERT
			if (лНажатие1)
			{
				м_Чат.ПереключитьСостояниеПанели();
			}
			break;

		case 67 + SHIFT_KEY: // SHIFT + C
			if (лНажатие1)
			{
				м_Чат.ОткрытьБоковуюПанель();
			}
			break;

		case 85: // U
			if (лНажатие1)
			{
				м_Чат.ПереключитьПоложениеПанели();
				ОбновитьОкноНастроек();
			}
			break;

		case 32: // SPACE
			if (лНажатие1)
			{
				ПереключитьПросмотрТрансляции();
				м_Автоскрытие.Показать();
			}
			break;

		case 48: // 0
		case 49: // 1
		case 50: // 2
		case 51: // 3
		case 52: // 4
		case 53: // 5
		case 54: // 6
		case 55: // 7
		case 56: // 8
		case 57: // 9
			if (лНажатие1 && _чСостояние === СОСТОЯНИЕ_ПОВТОР)
			{
				ЗадатьСкоростьВоспроизведения((оСобытие.keyCode === 48 ? 58 : оСобытие.keyCode) - 53);
				м_Автоскрытие.Показать();
			}
			break;

		// EDGE 15: PLUS и NUMPAD PLUS увеличивают скорость воспроизведения.
		case 187: // PLUS
		case 107: // NUMPAD PLUS
			if (лНажатие1 && _чСостояние === СОСТОЯНИЕ_ПОВТОР)
			{
				ЗадатьСкоростьВоспроизведения(Infinity);
				м_Автоскрытие.Показать();
			}
			break;

		// EDGE 15: MINUS и NUMPAD MINUS уменьшают скорость воспроизведения.
		case 189: // MINUS
		case 109: // NUMPAD MINUS
			if (лНажатие1 && _чСостояние === СОСТОЯНИЕ_ПОВТОР)
			{
				ЗадатьСкоростьВоспроизведения(-Infinity);
				м_Автоскрытие.Показать();
			}
			break;

		case 90: // Z
		case 12: // NUMPAD 5
			if (лНажатие1 && _чСостояние === СОСТОЯНИЕ_ПОВТОР)
			{
				м_Проигрыватель.ПереключитьПаузу();
				м_Автоскрытие.Показать();
			}
			break;

		case 37: // LEFT
			if (лНажатие && _чСостояние === СОСТОЯНИЕ_ПОВТОР)
			{
				м_Журнал.Окак(`[Управление] Перематываю на -${ПЕРЕМАТЫВАТЬ_СТРЕЛКАМИ_НА}с`);
				м_Проигрыватель.ПеремотатьПовторНа(false, -ПЕРЕМАТЫВАТЬ_СТРЕЛКАМИ_НА);
				м_Автоскрытие.Показать();
			}
			break;

		case 39: // RIGHT
			if (лНажатие && _чСостояние === СОСТОЯНИЕ_ПОВТОР)
			{
				м_Журнал.Окак(`[Управление] Перематываю на +${ПЕРЕМАТЫВАТЬ_СТРЕЛКАМИ_НА}с`);
				м_Проигрыватель.ПеремотатьПовторНа(false, ПЕРЕМАТЫВАТЬ_СТРЕЛКАМИ_НА);
				м_Автоскрытие.Показать();
			}
			break;

		case 37 + SHIFT_KEY: // SHIFT + LEFT
			if (лНажатие && _чСостояние === СОСТОЯНИЕ_ПОВТОР)
			{
				м_Журнал.Окак(`[Управление] Перематываю на -${ПЕРЕМАТЫВАТЬ_ПО_КАДРАМ_НА} кадров`);
				м_Проигрыватель.ПеремотатьПовторНа(true, -ПЕРЕМАТЫВАТЬ_ПО_КАДРАМ_НА);
				м_Автоскрытие.Показать();
			}
			break;

		case 39 + SHIFT_KEY: // SHIFT + RIGHT
			if (лНажатие && _чСостояние === СОСТОЯНИЕ_ПОВТОР)
			{
				м_Журнал.Окак(`[Управление] Перематываю на +1 кадр`);
				м_Проигрыватель.ПеремотатьПовторНа(true, 1);
				м_Автоскрытие.Показать();
			}
			break;

		case 38: // UP
			if (лНажатие)
			{
				СохранитьИПрименитьНастройкиЗвука(false, Math.min(м_Настройки.Получить('чГромкость2') + ШАГ_ПОВЫШЕНИЯ_ГРОМКОСТИ_КЛАВОЙ, МАКСИМАЛЬНАЯ_ГРОМКОСТЬ));
			}
			break;

		case 40: // DOWN
			if (лНажатие)
			{
				СохранитьИПрименитьНастройкиЗвука(false, Math.max(м_Настройки.Получить('чГромкость2') - ШАГ_ПОНИЖЕНИЯ_ГРОМКОСТИ_КЛАВОЙ, МИНИМАЛЬНАЯ_ГРОМКОСТЬ));
			}
			break;

		case 33: // PAGE UP
			if (лНажатие1)
			{
				СохранитьИПрименитьНастройкиЗвука(false);
			}
			break;

		case 34: // PAGE DOWN
			if (лНажатие1)
			{
				СохранитьИПрименитьНастройкиЗвука(true);
			}
			break;

		case 77: // M
			if (лНажатие1)
			{
				СохранитьИПрименитьНастройкиЗвука(!м_Настройки.Получить('лПриглушить'));
			}
			break;

		case 82: // R
			if (лНажатие1)
			{
				const лМасштабироватьИзображение = м_Настройки.Получить('лМасштабироватьИзображение');
				м_Настройки.Изменить('лМасштабироватьИзображение', !лМасштабироватьИзображение);
				ОбновитьОкноНастроек();
				ПрименитьМасштабированиеИзображения();
				м_Уведомление.Показать(`svg-fullscreen-${лМасштабироватьИзображение}`, false);
			}
			break;


		case 88 + ALT_KEY: // ALT + X
			if (лНажатие1)
			{
				СоздатьКлип();
			}
			break;


		default: return;
		}

		оСобытие.preventDefault();
	});

	function ОбновитьОкноНастроек()
	{
		document.querySelector(`input[name="одновременныхзагрузок"][value="${м_Настройки.Получить('кОдновременныхЗагрузок')}"]`).checked = true;
		document.querySelector(`input[name="состояниезакрытогочата"][value="${м_Настройки.Получить('чСостояниеЗакрытогоЧата')}"]`).checked = true;
		document.getElementById('адресчата').selectedIndex = м_Настройки.Получить('лПолноценныйЧат') ? 0 : м_Настройки.Получить('лЗатемнитьЧат') ? 2 : 1;
		document.getElementById('масштабироватьизображение').checked = м_Настройки.Получить('лМасштабироватьИзображение');
		document.getElementById('менятьгромкостьколесом').checked = м_Настройки.Получить('лМенятьГромкостьКолесом');
		document.getElementById('анимацияинтерфейса').checked = м_Настройки.Получить('лАнимацияИнтерфейса');

		const лАвтоПоложение = м_Настройки.Получить('лАвтоПоложениеЧата');
		document.getElementById('автоположениечата').checked = лАвтоПоложение;
		const сузСтороны = document.querySelectorAll('.положениечата input');
		if (лАвтоПоложение)
		{
			const чГоризонтальноеПоложение = м_Настройки.Получить('чГоризонтальноеПоложениеЧата');
			const чВертикальноеПоложение = м_Настройки.Получить('чВертикальноеПоложениеЧата');
			let узГоризонтальноеПоложение, узВертикальноеПоложение;
			for (let узСторона of сузСтороны)
			{
				const чСторона = Number.parseInt(узСторона.value, 10);
				if (чГоризонтальноеПоложение === чСторона)
				{
					узГоризонтальноеПоложение = узСторона;
				}
				if (чВертикальноеПоложение === чСторона)
				{
					узВертикальноеПоложение = узСторона;
				}
				узСторона.name = чСторона === ПРАВАЯ_СТОРОНА || чСторона === ЛЕВАЯ_СТОРОНА ? 'горизонтальноеположениечата' : 'вертикальноеположениечата';
			}
			узГоризонтальноеПоложение.checked = узВертикальноеПоложение.checked = true;
		}
		else
		{
			const чПоложение = м_Настройки.Получить('чПоложениеПанелиЧата');
			let узПоложение;
			for (let узСторона of сузСтороны)
			{
				if (чПоложение === Number.parseInt(узСторона.value, 10))
				{
					узПоложение = узСторона;
				}
				узСторона.name = 'положениечата';
			}
			узПоложение.checked = true;
		}

		if (_оНачалоВоспроизведения)
		{
			_оНачалоВоспроизведения.Обновить();
			_оРазмерБуфера.Обновить();
			_оРастягиваниеБуфера.Обновить();
			_оИнтервалОбновленияСписков.Обновить();
			_оДлительностьПовтора.Обновить();
			_оРазмерИнтерфейса.Обновить();
			_оИнтервалАвтоскрытия.Обновить();
		}
		else
		{
			_оНачалоВоспроизведения     = new ВводЧисла('чНачалоВоспроизведения', 0.5, 1, 'началовоспроизведения');
			_оРазмерБуфера              = new ВводЧисла('чРазмерБуфера',          0.5, 1, 'размербуфера');
			_оРастягиваниеБуфера        = new ВводЧисла('чРастягиваниеБуфера',    0.5, 1, 'растягиваниебуфера');
			_оИнтервалОбновленияСписков = new ВводЧисла('чИнтервалОпроса',         10, 0, 'интервалопроса');
			_оДлительностьПовтора       = new ВводЧисла('чДлительностьПовтора2',   30, 0, 'длительностьповтора');
			_оНачалоВоспроизведения.ПослеИзменения = _оРазмерБуфера.ПослеИзменения = _оРастягиваниеБуфера.ПослеИзменения = _оИнтервалОбновленияСписков.ПослеИзменения = м_Статистика.ОчиститьИсторию;

			_оРазмерИнтерфейса = new ВводЧисла('чРазмерИнтерфейса', 1, 0, 'размеринтерфейса');
			_оРазмерИнтерфейса.ПослеИзменения = ПрименитьРазмерИнтерфейса;

			_оИнтервалАвтоскрытия = new ВводЧисла('чИнтервалАвтоскрытия', 0.5, 1, 'интервалавтоскрытия');
		}
	}

	function ОбработатьОткрытиеГлавногоМеню()
	{
		Узел('копироватьадресзаписи').tabIndex = м_Twitch.ПолучитьАдресЗаписиДляТекущейПозиции() ? 0 : -1;
	}

	function ОбработатьПаузу(лПауза)
	{
		ИзменитьКнопку('переключитьпаузу', лПауза);
	}

	function ОбработатьИзменениеПредустановкиБуферизации()
	{
		ОбновитьОкноНастроек();
		м_Статистика.ОчиститьИсторию();
	}

	function ПолучитьСкоростьВоспроизведения()
	{
		const узСкорость = Узел('скорость');
		м_Журнал.Окак(`[Управление] Выбрана скорость ${узСкорость.value}`);
		const чСкорость = Number.parseFloat(узСкорость.value);
		// Firefox 47, Chrome 52: Отрицательный playbackRate не поддерживается.
		// Firefox 47: Минимальная скорость 0.25.
		// Chrome 52:  Минимальная скорость 0.06.
		// Chrome 59:  NVIDIA GTX770 не вытягивает скорость 4x.
		Проверить(Number.isFinite(чСкорость) && чСкорость >= 0);
		return чСкорость;
	}

	function ЗадатьСкоростьВоспроизведения(чСкорость)
	// -Infinity - замедлить на 1 шаг
	// +Infinity - ускорить  на 1 шаг
	// < 0       - пониженная скорость
	// = 0       - нормальная скорость
	// > 0       - повышенная скорость
	{
		Проверить(ЭтоЧисло(чСкорость));
		const узСкорость = Узел('скорость');
		Проверить(узСкорость.selectedIndex >= 0);
		let чИндекс;
		if (чСкорость === -Infinity || чСкорость === Infinity)
		{
			чИндекс = узСкорость.selectedIndex - Math.sign(чСкорость);
		}
		else
		{
			чИндекс = узСкорость.querySelector('option[value="1.00"]').index - чСкорость;
		}
		if (чИндекс >= 0 && чИндекс < узСкорость.length && чИндекс !== узСкорость.selectedIndex)
		{
			узСкорость.selectedIndex = чИндекс;
			м_Проигрыватель.ЗадатьСкоростьПовтора(ПолучитьСкоростьВоспроизведения());
		}
	}

	const ОбработатьИзменениеСкоростиВоспроизведения = ДобавитьОбработчикИсключений(оСобытие =>
	{
		if (_чСостояние === СОСТОЯНИЕ_ПОВТОР)
		{
			м_Проигрыватель.ЗадатьСкоростьПовтора(ПолучитьСкоростьВоспроизведения());
		}
	});

	const ОбработатьИзменениеВариантаТрансляции = ДобавитьОбработчикИсключений(оСобытие =>
	{
		м_Журнал.Окак(`[Управление] Выбран вариант ${оСобытие.target.value}`);
		Проверить(оСобытие.target.value);
		м_Настройки.Изменить('сНазваниеВарианта', оСобытие.target.value);
		м_Список.ИзменитьВариантТрансляции();
	});

	const ОбработатьИзменениеАдресаЧата = ДобавитьОбработчикИсключений(оСобытие =>
	{
		м_Журнал.Окак(`[Управление] Выбран адрес чата ${оСобытие.target.selectedIndex}`);
		switch (оСобытие.target.selectedIndex)
		{
		case 0:
			м_Настройки.Изменить('лПолноценныйЧат', true);
			break;

		case 1:
			м_Настройки.Изменить('лПолноценныйЧат', false);
			м_Настройки.Изменить('лЗатемнитьЧат', false);
			break;

		case 2:
			м_Настройки.Изменить('лПолноценныйЧат', false);
			м_Настройки.Изменить('лЗатемнитьЧат', true);
			break;

		default:
			Проверить(false);
		}
		м_Чат.ПрименитьАдрес();
	});

	const ОбработатьВыборФайлаДляИмпортаНастроек = ДобавитьОбработчикИсключений(оСобытие =>
	{
		if (оСобытие.target.files.length === 1)
		{
			м_Настройки.Импорт(оСобытие.target.files[0]);
		}
	});

	function ОбновитьСписокВариантовТрансляции([моСписокВариантов, чВыбранныйВариант])
	{
		const узСписок = document.getElementById('варианттрансляции');
		узСписок.length = 0;
		if (моСписокВариантов)
		{
			for (let ы = 0; ы < моСписокВариантов.length; ++ы)
			{
				let сПереведенноеНазвание = моСписокВариантов[ы].сНазвание;
				if (сПереведенноеНазвание.endsWith('(source)'))
				{
					сПереведенноеНазвание = сПереведенноеНазвание.slice(0, -8) + Текст('J0139');
				}
				узСписок.add(new Option(сПереведенноеНазвание, моСписокВариантов[ы].сИдентификатор, ы === чВыбранныйВариант, ы === чВыбранныйВариант));
			}
		}
		узСписок.disabled = узСписок.length < 2;
	}

	function ПоказатьПропускВидео()
	{
		м_Уведомление.Показать('svg-cut', true);
	}

	function Запустить()
	{
		Проверить(_чСостояние === undefined);

		Узел('названиетрансляции').lastElementChild.href = м_Twitch.ПолучитьАдресКанала(true);

		let уз = document.getElementById('громкость');
		уз.min = МИНИМАЛЬНАЯ_ГРОМКОСТЬ;
		уз.max = МАКСИМАЛЬНАЯ_ГРОМКОСТЬ;
		уз.step = ШАГ_ИЗМЕНЕНИЯ_ГРОМКОСТИ_МЫШЬЮ;
		уз.addEventListener('input', ОбработатьИзменениеГромкости);

		for (уз of document.getElementById('скорость').children)
		{
			уз.text = уз.value === '1.00' ? '1x' : м_i18n.ФорматироватьЧисло(уз.value, 2);
		}

		ОбновитьНастройкиЗвука();
		ОбновитьОкноНастроек();
		м_Автоскрытие.Запустить();
		м_Автоскрытие.Показать();
		м_Новости.Запустить();
		м_Чат.Восстановить();

		м_События.ДобавитьОбработчик('меню-открыто-главноеменю', ОбработатьОткрытиеГлавногоМеню);
		м_События.ДобавитьОбработчик('список-выбранварианттрансляции', ОбновитьСписокВариантовТрансляции);
		м_События.ДобавитьОбработчик('проигрыватель-переполненбуфер', ПоказатьПропускВидео);
		м_События.ДобавитьОбработчик('проигрыватель-пауза', ОбработатьПаузу);
		м_События.ДобавитьОбработчик('настройки-измениласьпредустановка-буферизация', ОбработатьИзменениеПредустановкиБуферизации);
		м_События.ДобавитьОбработчик('twitch-полученыметаданныеканала', ПоказатьМетаданныеКанала);
		м_События.ДобавитьОбработчик('twitch-полученыметаданныезрителя', ПоказатьМетаданныеЗрителя);
		м_События.ДобавитьОбработчик('twitch-полученыметаданныетрансляции', ПоказатьМетаданныеТрансляции);

		// Firefox 60 после перетаскивания элементов за пределы окна посылает оСобытие.target == document.
		// https://bugzilla.mozilla.org/show_bug.cgi?id=1445959
		document.documentElement.addEventListener('click', ОбработатьЛевыйЩелчок);
		document.addEventListener('keydown', ОбработатьНажатиеИОтпусканиеКлавы);
		document.addEventListener('keyup', ОбработатьНажатиеИОтпусканиеКлавы);
		document.getElementById('скорость').addEventListener('change', ОбработатьИзменениеСкоростиВоспроизведения);
		document.getElementById('варианттрансляции').addEventListener('change', ОбработатьИзменениеВариантаТрансляции);
		document.getElementById('адресчата').addEventListener('change', ОбработатьИзменениеАдресаЧата);
		document.getElementById('выборфайладляимпортанастроек').addEventListener('change', ОбработатьВыборФайлаДляИмпортаНастроек);
		ЗапуститьИзменениеГромкостиКолесом();

		ИзменитьСостояние(СОСТОЯНИЕ_ЗАПУСК);
		ПрименитьМасштабированиеИзображения();
		ПрименитьРазмерИнтерфейса();
		ПрименитьАнимациюИнтерфейса();
		// Показать проигрыватель.
		м_Оформление.Запустить();
	}

	function ИзменитьСостояние(чНовоеСостояние)
	{
		Проверить(Number.isInteger(чНовоеСостояние));
		if (чНовоеСостояние === _чСостояние)
		{
			return;
		}

		м_Журнал.Вот(`[Управление] Состояние трансляции изменилось с ${_чСостояние} на ${чНовоеСостояние}`);
		м_События.ОбработатьСобытие('управление-изменилосьсостояние', чНовоеСостояние);

		document.body.setAttribute('data-состояние', чНовоеСостояние);
		ИзменитьКнопку('переключитьтрансляцию', чНовоеСостояние === СОСТОЯНИЕ_ОСТАНОВКА || чНовоеСостояние === СОСТОЯНИЕ_ПОВТОР);
		document.getElementById('создатьклип').disabled = чНовоеСостояние === СОСТОЯНИЕ_ЗАПУСК || чНовоеСостояние === СОСТОЯНИЕ_НАЧАЛО_ТРАНСЛЯЦИИ || чНовоеСостояние === СОСТОЯНИЕ_ЗАВЕРШЕНИЕ_ТРАНСЛЯЦИИ;

		switch (чНовоеСостояние)
		{
		case СОСТОЯНИЕ_ЗАПУСК:
			ПоказатьМетаданныеТрансляции(
			{
				лЗапись:                 null,
				сАдресЗаписи:            '',
				сНазваниеТрансляции:     НАЗВАНИЕ_ТРАНСЛЯЦИИ_НЕИЗВЕСТНО,
				сНазваниеИгры:           null,
				сАдресИгры:              null,
				кЗрителей:               null,
				чДлительностьТрансляции: null
			});
			// После снятия с паузы.
			м_Twitch.ЗавершитьСборМетаданныхТрансляции(true);
			break;

		case СОСТОЯНИЕ_НАЧАЛО_ТРАНСЛЯЦИИ:
			ПоказатьМетаданныеТрансляции(
			{
				лЗапись:                 null,
				сАдресЗаписи:            '',
				сНазваниеТрансляции:     НАЗВАНИЕ_ТРАНСЛЯЦИИ_НЕИЗВЕСТНО,
				сНазваниеИгры:           null,
				сАдресИгры:              null,
				кЗрителей:               null,
				чДлительностьТрансляции: null
			});
			м_Twitch.НачатьСборМетаданныхТрансляции();
			break;

		case СОСТОЯНИЕ_ЗАВЕРШЕНИЕ_ТРАНСЛЯЦИИ:
			ПоказатьМетаданныеТрансляции(
			{
				лЗапись:                 null,
				сАдресЗаписи:            '',
				сНазваниеТрансляции:     Текст('J0100'),
				сАдресИгры:              null,
				кЗрителей:               null,
				чДлительностьТрансляции: null
			});
			м_Twitch.ЗавершитьСборМетаданныхТрансляции(true);
			break;

		case СОСТОЯНИЕ_ЗАГРУЗКА:
		case СОСТОЯНИЕ_НАЧАЛО_ВОСПРОИЗВЕДЕНИЯ:
		case СОСТОЯНИЕ_ВОСПРОИЗВЕДЕНИЕ:
			break;

		case СОСТОЯНИЕ_ОСТАНОВКА:
		case СОСТОЯНИЕ_ПОВТОР:
			ПоказатьМетаданныеТрансляции(
			{
				кЗрителей: null
			});
			м_Twitch.ЗавершитьСборМетаданныхТрансляции(false);
			break;
				
		default:
			Проверить(false);
		}

		_чСостояние = чНовоеСостояние;
	}

	function ПолучитьСостояние()
	{
		Проверить(_чСостояние !== undefined);
		return _чСостояние;
	}

	function ПоказатьМетаданныеКанала(оМетаданные)
	{
		if (оМетаданные.сИмя !== undefined)
		{
			ИзменитьЗаголовокДокумента(`${оМетаданные.сИмя} - Alternate Player for Twitch.tv`);
			document.getElementById('канал-имя').textContent = оМетаданные.сИмя;
		}

		if (оМетаданные.сАватар !== undefined)
		{
			Проверить(оМетаданные.сАватар);
			document.getElementById('канал-аватар').src = оМетаданные.сАватар;
		}

		if (оМетаданные.сОписание !== undefined)
		{
			document.getElementById('канал-описание').textContent = оМетаданные.сОписание || '';
		}

		if (оМетаданные.сКодЯзыка !== undefined)
		{
			const уз = document.getElementById('канал-язык');
			if (оМетаданные.сКодЯзыка)
			{
				const сЯзык = ЯЗЫКИ[оМетаданные.сКодЯзыка.toLowerCase()];
				if (!сЯзык)
				{
					throw new Error(`Неизвестный язык: ${оМетаданные.сКодЯзыка}`);
				}
				уз.textContent = сЯзык;
				ПоказатьЭлемент(уз.parentNode, true);
			}
			else
			{
				ПоказатьЭлемент(уз.parentNode, false);
			}
		}

		if (оМетаданные.кПодписчиков !== undefined)
		{
			document.getElementById('канал-подписчиков').textContent = м_i18n.ФорматироватьЧисло(оМетаданные.кПодписчиков);
		}

		if (оМетаданные.кПросмотров !== undefined)
		{
			document.getElementById('канал-просмотров').textContent = м_i18n.ФорматироватьЧисло(оМетаданные.кПросмотров);
		}

		if (оМетаданные.дКаналСоздан !== undefined)
		{
			document.getElementById('канал-создан').textContent = оМетаданные.дКаналСоздан.toLocaleDateString();
		}

		ПоказатьМассивСсылок(оМетаданные.моСообщества, 'канал-сообщества');
		ПоказатьМассивСсылок(оМетаданные.моКоманды, 'канал-команды');
	}

	function ПоказатьМассивСсылок(моСсылки, пВставить)
	{
		if (моСсылки === undefined)
		{
			return;
		}
		const узВставить = Узел(пВставить);
		if (моСсылки.length === 0)
		{
			ПоказатьЭлемент(узВставить.parentNode, false);
		}
		else
		{
			const оФрагмент = document.createDocumentFragment();
			for (let ы = 0, оСсылка; оСсылка = моСсылки[ы]; ++ы)
			{
				if (ы !== 0)
				{
					оФрагмент.appendChild(document.createTextNode(',\u2002'));
				}
				Проверить(оСсылка.сАдрес && оСсылка.сИмя);
				const узСсылка = document.createElement('a');
				узСсылка.href = оСсылка.сАдрес;
				узСсылка.rel = 'noopener noreferrer';
				узСсылка.target = '_blank';
				if (оСсылка.сОписание)
				{
					узСсылка.className = 'канал-ссылка';
					узСсылка.title = оСсылка.сОписание;
				}
				узСсылка.appendChild(document.createTextNode(оСсылка.сИмя));
				оФрагмент.appendChild(узСсылка);
			}
			узВставить.textContent = '';
			узВставить.appendChild(оФрагмент);
			ПоказатьЭлемент(узВставить.parentNode, true);
		}
	}

	function ПоказатьМетаданныеЗрителя(оМетаданные)
	{
		if (оМетаданные.сИмя !== undefined)
		{
			if (оМетаданные.сИмя !== '')
			{
				document.getElementById('зритель-имя').textContent = оМетаданные.сИмя;
			}
			else
			{
				м_i18n.InsertAdjacentHtmlMessage(document.getElementById('зритель-имя'), 'content', 'F0590');
			}
		}

		if (оМетаданные.чПодписка !== undefined)
		{
			const уз = document.getElementById('зритель-подписка');
			if (оМетаданные.чПодписка === ПОДПИСКА_ОБНОВЛЯЕТСЯ)
			{
				уз.classList.add('обновляется');
			}
			else
			{
				уз.classList.remove('обновляется');
				уз.setAttribute('data-подписка', оМетаданные.чПодписка);
				document.getElementById('зритель-уведомлять').checked = оМетаданные.чПодписка === ПОДПИСКА_УВЕДОМЛЯТЬ;
			}
		}
	}

	function ПоказатьМетаданныеТрансляции(оМетаданные)
	// undefined - не менять, null - скрыть.
	{
		if (оМетаданные.лЗапись !== undefined)
		{
			const уз = Узел('типтрансляции');
			if (оМетаданные.лЗапись === null)
			{
				ПоказатьЭлемент(уз, false);
			}
			else
			{
				ИзменитьКнопку(уз, оМетаданные.лЗапись);
				if (оМетаданные.сАдресЗаписи)
				{
					уз.setAttribute('data-адрес', оМетаданные.сАдресЗаписи);
					уз.disabled = false;
				}
				else
				{
					уз.disabled = true;
				}
				ПоказатьЭлемент(уз, true);
			}
		}

		if (оМетаданные.сНазваниеТрансляции !== undefined)
		{
			const уз = document.getElementById('названиетрансляции');
			if (оМетаданные.сНазваниеТрансляции === null)
			{
				ПоказатьЭлемент(уз, false);
			}
			else
			{
				уз.lastElementChild.title = оМетаданные.сНазваниеТрансляции + Текст('J0101');
				уз.lastElementChild.textContent = оМетаданные.сНазваниеТрансляции;
				ПоказатьЭлемент(уз, true);
			}
		}

		if (оМетаданные.сНазваниеИгры !== undefined)
		{
			const уз = document.getElementById('названиеигры');
			if (оМетаданные.сНазваниеИгры === null)
			{
				ПоказатьЭлемент(уз, false);
			}
			else
			{
				уз.lastElementChild.href = оМетаданные.сАдресИгры;
				уз.lastElementChild.title = оМетаданные.сНазваниеИгры + Текст('J0102');
				уз.lastElementChild.textContent = оМетаданные.сНазваниеИгры;
				ПоказатьЭлемент(уз, true);
			}
		}

		if (оМетаданные.кЗрителей !== undefined)
		{
			const уз = document.getElementById('количествозрителей');
			if (оМетаданные.кЗрителей === null)
			{
				ПоказатьЭлемент(уз, false);
			}
			else
			{
				уз.lastElementChild.textContent = м_i18n.ФорматироватьЧисло(оМетаданные.кЗрителей, 0);
				ПоказатьЭлемент(уз, true);
			}
		}

		if (оМетаданные.чДлительностьТрансляции !== undefined)
		{
			document.getElementById('позиция-текст').textContent =
				оМетаданные.чДлительностьТрансляции === null ? ''
				: м_i18n.ПеревестиСекундыВСтроку(оМетаданные.чДлительностьТрансляции / 1000, false);
		}
	}

	return {
		Запустить,
		ПолучитьСостояние, ИзменитьСостояние,
		ПолучитьСкоростьВоспроизведения,
		ОбновитьНастройкиЗвука,
		ОстановитьПросмотрТрансляции
	};
})();


//
// Выбор устройства для вывода звука.
//
{
	const _oMediaElement = document.getElementById('глаз');

	function ЭтоНастоящееАудиоустройство(сИд)
	// HACK Chrome 66 + Windows: Если есть хотя бы одно настоящее устройство, то добавляются специальные устройства default и communications.
	{
		return сИд !== 'default' && сИд !== 'communications';
	}

	function ПолучитьИдТекущегоАудиоустройства()
	// HACK Chrome 66 + Windows: По умолчанию звук идет на специальное устройство default.
	{
		Проверить(_oMediaElement.parentNode);
		const сИд = _oMediaElement.sinkId;
		м_Журнал.Вот(`[Аудиоустройства] Текущее аудиоустройство: ${сИд}`);
		return сИд !== '' ? сИд : 'default';
	}

	function ОбновитьСписокАудиоустройств()
	{
		const узСписокАудиоустройств = document.getElementById('аудиоустройства-список');
		узСписокАудиоустройств.length = 0;
		м_Журнал.Окак('[Аудиоустройства] Получаю список медиаустройств');
		navigator.mediaDevices.enumerateDevices()
		.then(
			моМедиаустройства =>
			{
				м_Журнал.Вот(`[Аудиоустройства] Найдено медиаустройств: ${моМедиаустройства.length}`);
				let кАудиоустройств = 0, кНастоящихАудиоустройств = 0;
				for (let оМедиаустройство of моМедиаустройства)
				{
					м_Журнал.Вот(`[Аудиоустройства] Найдено медиаустройство kind=${оМедиаустройство.kind} deviceId=${оМедиаустройство.deviceId} groupId=${оМедиаустройство.groupId} label=${оМедиаустройство.label}`);
					if (оМедиаустройство.kind === 'audiooutput')
					{
						++кАудиоустройств;
						if (ЭтоНастоящееАудиоустройство(оМедиаустройство.deviceId))
						{
							++кНастоящихАудиоустройств;
						}
						if (оМедиаустройство.label !== '')
						{
							узСписокАудиоустройств.add(new Option(оМедиаустройство.label, оМедиаустройство.deviceId, false, false));
						}
					}
				}
				узСписокАудиоустройств.value = ПолучитьИдТекущегоАудиоустройства();
				// Проверить наличие разрешения также можно с помощью navigator.permissions.query(), но не во всех версиях браузера.
				if (узСписокАудиоустройств.length === 0 && кАудиоустройств !== 0)
				{
					// UNDONE HACK Попытка изменить доступ к аудиоустройствам в режиме инкогнито валит Blink.
					// https://bugs.chromium.org/p/chromium/issues/detail?id=832697
					// https://bugs.chromium.org/p/chromium/issues/detail?id=833061
					// Исправлено в Chrome 69.
					if (chrome.extension.inIncognitoContext)
					{
						ПоказатьЭлемент('аудиоустройства', false);
						return;
					}
					ПоказатьЭлемент('аудиоустройства-доступ', true);
					ПоказатьЭлемент(узСписокАудиоустройств, false);
					м_События.ДобавитьОбработчик('управление-левыйщелчок', ОбработатьПолучениеДоступа);
				}
				else
				{
					ПоказатьЭлемент('аудиоустройства-доступ', false);
					ПоказатьЭлемент(узСписокАудиоустройств, true);
					узСписокАудиоустройств.addEventListener('change', ОбработатьВыборАудиоустройства);
				}
				// Не скрывать список если он уже один раз был показан. Это нужно, чтобы сменить устройство после удаления текущего.
				if (кНастоящихАудиоустройств > 1)
				{
					ПоказатьЭлемент('аудиоустройства', true);
				}
			},
			пПричина =>
			{
				м_Журнал.Ой(`[Аудиоустройства] Не удалось получить список медиаустройств: ${пПричина}`);
			}
		)
		.catch(м_Отладка.ПойманоИсключение);
	}

	function ОбработатьПолучениеДоступа({сПозывной})
	{
		if (сПозывной !== 'аудиоустройства-доступ')
		{
			return;
		}
		// getUserMedia() не походит, потому что не запрашивает разрешение если не найдено ни одного audioinput, даже если указать идентификатор audiooutput.
		// Дать расширению разрешение пользователь может вручную в дебрях настроек браузера, используя origin разрешения. Это слишком жестоко.
		// С помощью contentSettings делаем описанную выше операцию программно.
		м_Журнал.Окак('[Аудиоустройства] Запрашиваю разрешение contentSettings');
		chrome.permissions.request(
			{
				permissions: ['contentSettings']
			},
			ДобавитьОбработчикИсключений(лРазрешениеПолучено =>
			{
				if (!лРазрешениеПолучено)
				{
					// lastError == null если пользователь не дал разрешение.
					м_Журнал.Ой(`[Аудиоустройства] Разрешение не получено: ${chrome.runtime.lastError ? chrome.runtime.lastError.message : ''}`);
					// Сейчас chrome.contentSettings недоступны.
					return;
				}
				м_Журнал.Окак('[Аудиоустройства] Даю расширению доступ к аудиоустройствам');
				chrome.contentSettings.microphone.set(
					{
						// Chrome 66: Нельзя указывать схему расширения.
						primaryPattern: `*://${chrome.runtime.id}/*`,
						setting: 'allow',
						// Первый раз дать разрешение пользователь мог в режиме инкогнито.
						scope: chrome.extension.inIncognitoContext ? 'incognito_session_only' : 'regular'
					},
					ДобавитьОбработчикИсключений(() =>
					{
						if (chrome.runtime.lastError)
						{
							м_Журнал.Ой(`[Аудиоустройства] Не удалось дать доступ: ${chrome.runtime.lastError.message}`);
						}
						ОбновитьСписокАудиоустройств();
					})
				);
			})
		);
	}

	const ОбработатьВыборАудиоустройства = ДобавитьОбработчикИсключений(оСобытие =>
	{
		if (оСобытие.target.selectedIndex === -1)
		{
			return;
		}
		м_Журнал.Окак(`[Аудиоустройства] Меняю аудиоустройство с ${_oMediaElement.sinkId} на ${оСобытие.target.value} (${оСобытие.target.selectedOptions[0].text})`);
		_oMediaElement.setSinkId(оСобытие.target.value)
		.then(
			() =>
			{
				м_Журнал.Окак(`[Аудиоустройства] Аудиоустройство изменено на ${_oMediaElement.sinkId}`);
			},
			пПричина =>
			{
				м_Журнал.Ой(`[Аудиоустройства] Не удалось изменить аудиоустройство: ${пПричина}`);
				// Могли отнять доступ к аудиоустройствам (не знаю как). Нужно показать кнопку для получения доступа.
				// Список устройств мог измениться, если версия браузера не поддерживает ondevicechange. Нужно обновить список.
				ОбновитьСписокАудиоустройств();
			}
		)
		.catch(м_Отладка.ПойманоИсключение);
	});
	
	if (_oMediaElement.setSinkId === undefined)
	{
		// Например Firefox 60 и Edge 16.
		м_Журнал.Ой('[Аудиоустройства] Браузер не поддерживает MediaElement.setSinkId');
	}
	else
	{
		if (navigator.mediaDevices.addEventListener === undefined)
		{
			// Например Chrome 49.
			м_Журнал.Ой('[Аудиоустройства] Браузер не поддерживает mediaDevices.ondevicechange');
		}
		else
		{
			navigator.mediaDevices.addEventListener('devicechange', ДобавитьОбработчикИсключений(ОбновитьСписокАудиоустройств));
		}
		ОбновитьСписокАудиоустройств();
	}
}


const м_Проигрыватель = (() =>
{
	// Нет необходимости нагибать процессор слишком часто.
	//
	// Firefox 48: Если CTS кадров перепутаны, то после удаления или добавления видео, ямы в buffered перестают быть
	// видны, поэтому в них можно "провалиться": воспроизвдение в этом месте остановится. Такое происходит редко. Чтобы
	// уменьшить вероятность провала, не стоит уменьшать ИНТЕРВАЛ_УДАЛЕНИЯ_ВИДЕО слишком сильно.
	const ИНТЕРВАЛ_УДАЛЕНИЯ_ВИДЕО = 10; // Секунды.


	// Chrome 59 + Windows + аппаратное декодирование: Остановка воспроизведения происходит в конце кадра за
	// 1..7 кадров до конца HTMLMediaElement.buffered. Возможно зависит от HTMLMediaElement.playbackRate.
	//
	// Chrome 59 + Windows + аппаратное декодирование: Если до конца HTMLMediaElement.buffered ≈ менее 0,2 с, то
	// добавление сегмента приводит к рывку видео и увеличению счетчика пропущенных кадров. Продолжительность рывка
	// намного меньше, чем в Firefox.
	const ИСЧЕРПАНИЕ_БУФЕРА = 1 / 25 * 7; // Секунды.

	const ПОВТОР_НЕДОСТУПЕН_ЕСЛИ_ПРОСМОТРЕНО_МЕНЬШЕ_ЧЕМ = 1.0; // Секунды > ИСЧЕРПАНИЕ_БУФЕРА.

	const ПРОВЕРИТЬ_ДОБАВЛЕНИЕ_СЕГМЕНТА            = -1;
	const ПРОВЕРИТЬ_НАЧАЛО_ВОСПРОИЗВЕДЕНИЯ         = -2;
	const ПРОВЕРИТЬ_ВОСПРОИЗВЕДЕНИЕ                = -3;
	const ПРОВЕРИТЬ_ОСТАНОВКА_ВОСПРОИЗВЕДЕНИЯ      = -4;

	const ВОСПРОИЗВЕДЕНИЕ_НЕВОЗМОЖНО               = 0;
	const ВОСПРОИЗВЕДЕНИЕ_ВОЗМОЖНО                 = 1;
	const ВОСПРОИЗВЕДЕНИЕ_ВОЗМОЖНО_ПОСЛЕ_ПЕРЕМОТКИ = 2;

	let _oMediaElement;
	let _oMediaSource;
	let _oMediaSourceBuffer = null;
	// 0: начальное значение.
	// 1: _oMediaSource открывался.
	// 2: воспроизведение начиналось.
	let _чВоспроизведениеНачиналось = 0;
	let _лАсинхроннаяОперация = false;
	let _сРазмерБуфера = 'чНачалоВоспроизведения';
	let _лЖдатьЗаполненияБуфера = true;
	let _чСмещениеНачалаТрансляции = 0;
	// HACK Chrome 53 + Windows + аппаратное декодирование: Если после остановки воспроизведения в буфере останется
	// не просмотрено менее ≈ 16 кадров, то после быстрого продолжения воспроизведения картинка перестанет обновляться
	// до следующей остановки. Перемотка исправляет эту ошибку.
	// https://bugs.chromium.org/p/chromium/issues/detail?id=710856
	let _лНужнаПеремотка = false;


	const _оПрямаяТрансляция =
	{
		ОбработатьSourceOpen()
		{
			Проверить(_oMediaElement.paused);
			_чВоспроизведениеНачиналось = Math.max(_чВоспроизведениеНачиналось, 1);
			ДобавитьСледующийСегмент();
		},

		ОбработатьProgress()
		// Обработка этого события добавлена на всякий случай: после завершения appendBuffer(),
		// содержимое _oMediaSourceBuffer могло не успеть добраться до _oMediaElement.
		{
			if (!_лАсинхроннаяОперация)
			{
				НачатьВоспроизведение(ПроверитьПозициюВоспроизведения(ПРОВЕРИТЬ_ДОБАВЛЕНИЕ_СЕГМЕНТА));
			}
		},

		ОбработатьWaiting()
		// Воспроизведение могло остановиться перед ямой. Обработчик timeupdate не проверяет
		// наличие ям, потому что браузер небольшие ямы может перепрыгнуть без посторонней помощи.
		{
		},

		ОбработатьPlaying()
		{
			if (м_Управление.ПолучитьСостояние() === СОСТОЯНИЕ_НАЧАЛО_ВОСПРОИЗВЕДЕНИЯ && !_oMediaElement.paused)
			{
				м_Управление.ИзменитьСостояние(СОСТОЯНИЕ_ВОСПРОИЗВЕДЕНИЕ);
			}
		},

		ОбработатьSeeking: ЗАГЛУШКА,
		ОбработатьSeeked: НачатьВоспроизведение,

		ОбработатьEnded()
		{
			ПерезагрузитьПроигрыватель(СОСТОЯНИЕ_ЗАГРУЗКА);
		},

		ОбработатьTimeUpdate()
		{
			if (!_oMediaElement.seeking && !_oMediaElement.paused && !_oMediaElement.ended)
			{
				ПроверитьПозициюВоспроизведения(ПРОВЕРИТЬ_ВОСПРОИЗВЕДЕНИЕ);
			}
		}
	};

	const _оПовтор =
	{
		лПауза: true,

		ОбработатьSourceOpen()
		// Может прийти, если начать и сразу остановить просмотр трансляции.
		{
			Проверить(_oMediaElement.paused);
			_чВоспроизведениеНачиналось = Math.max(_чВоспроизведениеНачиналось, 1);
		},

		ОбработатьProgress: ЗАГЛУШКА,
		ОбработатьWaiting: ЗАГЛУШКА,
		ОбработатьPlaying: ЗАГЛУШКА,
		ОбработатьSeeked: ЗАГЛУШКА,

		ОбработатьSeeking()
		// Если изменить _oMediaElement.currentTime до окончания перемотки, то событие timeupdate не придет.
		{
			м_Шкала.ЗадатьПросмотрено(_oMediaElement.currentTime);
		},

		ОбработатьEnded()
		{
			if (!this.лПауза)
			{
				// Сначала приходит timeupdate и происходит перемотка на начало. Потом приходит ended и воспроизведение возобновляется.
				_oMediaElement.play();
			}
		},

		ОбработатьTimeUpdate()
		{
			// Нельзя определить режим работы по _oMediaElement.paused. _oMediaElement.paused = true после события ended.
			// Каким был _oMediaElement.paused до прихода ended узнать по состоянию _oMediaElement нельзя.
			if (!this.лПауза && !_oMediaElement.seeking)
			{
				this.ПроверитьПозициюВоспроизведения(ПРОВЕРИТЬ_ВОСПРОИЗВЕДЕНИЕ);
			}
			м_Шкала.ЗадатьПросмотрено(_oMediaElement.currentTime);
		},

		ПроверитьПозициюВоспроизведения(чВремя)
		{
			Проверить(Number.isFinite(чВремя));
			Проверить(чВремя === ПРОВЕРИТЬ_НАЧАЛО_ВОСПРОИЗВЕДЕНИЯ || чВремя === ПРОВЕРИТЬ_ВОСПРОИЗВЕДЕНИЕ || чВремя >= 0);
			
			const оБуфер = _oMediaElement.buffered;
			const чПоследняяОбласть = оБуфер.length - 1;
			// Chrome 47: currentTime может быть на 0.000001 секунды меньше присвоенной величины.
			// Если это не учесть, то получим бесконечную перемотку на начало области.
			const чТекущееВремя = _oMediaElement.currentTime + 0.0001;
			let чПеремотатьДо = чВремя >= 0 ? чВремя : чТекущееВремя;
			let сПричинаПеремотки = '';

			for (let лНачатьСначала = false;;)
			{
				let чНужноДляВоспроизведения = чВремя === ПРОВЕРИТЬ_ВОСПРОИЗВЕДЕНИЕ ? ИСЧЕРПАНИЕ_БУФЕРА : МИН_РАЗМЕР_БУФЕРА;
				for (let чОбласть = 0; чОбласть <= чПоследняяОбласть; ++чОбласть)
				{
					if (чПеремотатьДо < оБуфер.start(чОбласть))
					{
						чНужноДляВоспроизведения = МИН_РАЗМЕР_БУФЕРА;
						сПричинаПеремотки += 'Перепрыгиваю яму. ';
						чПеремотатьДо = оБуфер.start(чОбласть);
					}
					if (оБуфер.end(чОбласть) - чПеремотатьДо >= чНужноДляВоспроизведения)
					{
						break;
					}
				}

				if (this.лПауза || чПеремотатьДо < м_Шкала.ПолучитьКонец())
				{
					break;
				}
				if (лНачатьСначала)
				{
					ПоказатьСостояние('Ой', `Бесконечная перемотка Время=${чВремя}`);
					return;
				}
				чПеремотатьДо = м_Шкала.ПолучитьНачало();
				сПричинаПеремотки += 'Начинаю сначала. ';
				лНачатьСначала = true;
			}

			if (чПеремотатьДо !== чТекущееВремя)
			{
				ПоказатьСостояние('Окак', `${сПричинаПеремотки}Перематываю до ${чПеремотатьДо}`);
				_oMediaElement.currentTime = чПеремотатьДо;
			}
		}
	};

	// _оПрямаяТрансляция или _оПовтор.
	let _оПоведение = _оПрямаяТрансляция;

	function ПоказатьСостояние(сВажность, сЗапись)
	{
		const оБуфер = _oMediaSource.sourceBuffers.length !== 0 ? _oMediaSource.sourceBuffers[0] : null;
		const сОбластиБуфера = ПеревестиОбластиВСтроку(оБуфер ? оБуфер.buffered : null);
		const сОбласти = ПеревестиОбластиВСтроку(_oMediaElement.buffered)
		const лОбластиРавны = сОбластиБуфера === сОбласти;
		if (сВажность === 'Вот' && ((оБуфер && оБуфер.buffered.length > 1) || _oMediaElement.buffered.length > 1))
		{
			сВажность = 'Окак';
		}
		if (_oMediaElement.error || !лОбластиРавны)
		{
			сВажность = 'Ой';
		}
		м_Журнал[сВажность](
			`${сЗапись.charAt(0) === '[' ? '' : '[Проигрыватель] '}${сЗапись} •••`
			+ (оБуфер && оБуфер.updating ? ' [U]' : '')
			+ (_oMediaElement.paused     ? ' [P]' : '')
			+ (_oMediaElement.seeking    ? ' [S]' : '')
			+ (_oMediaElement.ended      ? ' [E]' : '')
			+ (_oMediaElement.error ? ` error=${_oMediaElement.error.code}` : '')
			+ (_oMediaElement.src.startsWith('blob:') || _oMediaElement.src.startsWith('mediasource:') ? '' : ` src=${_oMediaElement.src}`)
			+ (_oMediaSource.readyState === 'open' ? '' : ` MSE.readyState=${_oMediaSource.readyState}`)
			+ (_oMediaSource.sourceBuffers.length === 1 ? '' : ` MSE.buffers=${_oMediaSource.sourceBuffers.length}`)
			+ (_oMediaElement.networkState === HTMLMediaElement.NETWORK_LOADING ? '' : ` networkState=${_oMediaElement.networkState}`)
			+ ` readyState=${_oMediaElement.readyState}`
			+ ` currentTime=${_oMediaElement.currentTime}`
			+ (лОбластиРавны ? ` buffered=${сОбласти}` : ` MSE.buffered=${сОбластиБуфера} buffered=${сОбласти}`)
			+ (_oMediaElement.duration === Infinity ? '' : ` duration=${_oMediaElement.duration}`)
			+ ` seekable=${ПеревестиОбластиВСтроку(_oMediaElement.seekable)}`
			+ ` played=${ПеревестиОбластиВСтроку(_oMediaElement.played)}`
		);
	}

	function ПеревестиОбластиВСтроку(оОбласти)
	{
		let сРезультат = '';
		if (оОбласти && оОбласти.length !== 0)
		{
			let чОбласть = Math.max(оОбласти.length - 20, 0);
			if (чОбласть !== 0)
			{
				сРезультат = `[${чОбласть}]`;
			}
			for (; чОбласть < оОбласти.length; ++чОбласть)
			{
				if (чОбласть !== 0)
				{
					сРезультат += `(${(оОбласти.start(чОбласть) - оОбласти.end(чОбласть - 1)).toFixed(3)})`;
				}
				сРезультат += `${оОбласти.start(чОбласть)}-${оОбласти.end(чОбласть)}`;
			}
		}
		return сРезультат;
	}

	function ПолучитьЗаполненностьБуфера(оБуфер = _oMediaElement.buffered)
	// Возвращает
	// {
	//   чПросмотрено:   длительность   просмотренного видео >= 0 с
	//   чНеПросмотрено: длительность непросмотренного видео >= 0 с
	// }
	// Ямы не учитываются.
	{
		let чПросмотрено = 0;
		let чНеПросмотрено = 0;
		if (оБуфер.length !== 0)
		{
			const чНачало = оБуфер.start(0);
			const чКонец = оБуфер.end(оБуфер.length - 1);
			const чТекущееВремя = Ограничить(_oMediaElement.currentTime, чНачало, чКонец);
			чПросмотрено = чТекущееВремя - чНачало;
			чНеПросмотрено = чКонец - чТекущееВремя;
		}
		return {чПросмотрено, чНеПросмотрено};
	}

	function ПолучитьКоличествоПропущенныхКадров()
	{
		return _oMediaElement.getVideoPlaybackQuality ? _oMediaElement.getVideoPlaybackQuality() :
		{
			totalVideoFrames:   _oMediaElement.webkitDecodedFrameCount,
			droppedVideoFrames: _oMediaElement.webkitDroppedFrameCount
		};
	}

	function ПолучитьПозициюВоспроизведенияТрансляции(лДляКлипа)
	// Возвращает -1 если воспроизведение не начиналось.
	{
		let чПозиция = _oMediaElement.currentTime;
		// Во время повтора сегменты ближе к началу шкалы уже недоступны на сервере Twitch.
		if (лДляКлипа && м_Управление.ПолучитьСостояние() === СОСТОЯНИЕ_ПОВТОР)
		{
			чПозиция = м_Шкала.ПолучитьКонец();
		}
		// После ПерезагрузитьПроигрыватель() воспроизведение не начиналось. Не ждать
		// заполнения буфера, которое может длиться несколько десятков секунд.
		if (!лДляКлипа && чПозиция === 0 && _oMediaSourceBuffer !== null)
		{
			const оБуфер = _oMediaSourceBuffer.buffered;
			if (оБуфер.length !== 0)
			{
				чПозиция = оБуфер.start(0);
			}
		}
		return чПозиция === 0 ? -1 : Math.max(чПозиция + _чСмещениеНачалаТрансляции, 0);
	}

	function РасчитатьСмещениеНачалаТрансляции(оСегмент)
	// Изменяет _чСмещениеНачалаТрансляции.
	// Вызывать после добавления сегмента в буфер проигрывателя.
	// Если трансляция длится больше ≈ 0x1FFFFFFFF / 90000 секунд, то позиция кодирования
	// добавляется к смещению (которое становится положительным числом) и затем обнуляется.
	// Бывают и другие комбинации, например чПозицияКодирования = 10000 и чСмещениеНачалаТрансляции = 5000.
	{
		// В сегменте есть статистика?
		if (!ЭтоЧисло(оСегмент.пДанные.чПозицияКодирования))
		{
			return;
		}
		// ВД как правило лишь на несколько миллисекунд отличается от ВП, поэтому годится для расчета смещения.
		// Большой точности для смещения не требуется.
		const чСмещениеНачалаТрансляции = ЭтоЧисло(оСегмент.чTwitchПрошлоВремени) ? оСегмент.чTwitchПрошлоВремени - оСегмент.пДанные.чПозицияКодирования : 0;
		const лОй = чСмещениеНачалаТрансляции === 0 || Math.abs(чСмещениеНачалаТрансляции - _чСмещениеНачалаТрансляции) > 1;
		м_Журнал[лОй ? 'Ой' : 'Вот'](`[Проигрыватель] Смещение начала трансляции ${м_Журнал.F1(чСмещениеНачалаТрансляции)}с`);
		_чСмещениеНачалаТрансляции = чСмещениеНачалаТрансляции;
	}

	function ПоказатьПродолжительностьТрансляции()
	{
		if (м_Статистика.ОкноПоказано())
		{
			const оБуфер = _oMediaSourceBuffer.buffered;
			if (оБуфер.length !== 0)
			{
				Узел('статистика-продолжительностьтрансляции').textContent =
					м_i18n.ПеревестиСекундыВСтроку(оБуфер.end(оБуфер.length - 1) + _чСмещениеНачалаТрансляции, true);
			}
		}
	}
	
	function ПоказатьЗадержкуТрансляции(оСегмент)
	{
		if (м_Статистика.ОкноПоказано())
		{
			let сЗадержка = '';
			if (ЭтоЧисло(оСегмент.пДанные.чВремяКодирования))
			{
				const чТекущееВремя = _oMediaElement.currentTime;
				if (чТекущееВремя !== 0)
				{
					const чЧасть1 = (Date.now() - оСегмент.пДанные.чВремяКодирования) / 1000;
					const чЧасть2 = оСегмент.пДанные.чПозицияКодирования - чТекущееВремя;
					сЗадержка = `${чЧасть1.toFixed(1)} + ${чЧасть2.toFixed(1)} = ${(чЧасть1 + чЧасть2).toFixed(1)}`;
				}
			}
			м_Журнал.Вот(`[Проигрыватель] Задержка трансляции ${сЗадержка}с`);
			Узел('статистика-задержкатрансляции').textContent = сЗадержка;
		}
	}

	function ПрименитьНастройкиЗвука()
	{
		_oMediaElement.volume = м_Настройки.Получить('чГромкость2') / МАКСИМАЛЬНАЯ_ГРОМКОСТЬ;
		_oMediaElement.muted = м_Настройки.Получить('лПриглушить');
	}

	function ПерезагрузитьИЖдатьЗаполненияБуфера(чНовоеСостояние)
	{
		_лЖдатьЗаполненияБуфера = true;
		ПерезагрузитьПроигрыватель(чНовоеСостояние);
	}

	function ПерезагрузитьПроигрыватель(чНовоеСостояние)
	{
		ПоказатьСостояние('Окак', 'Перезагрузка проигрывателя');
		м_Управление.ИзменитьСостояние(чНовоеСостояние);
		_оПоведение = _оПрямаяТрансляция;
		_oMediaSourceBuffer = null;
		_лНужнаПеремотка = false;
		// - _oMediaElement.pause().
		// - _oMediaElement.currentTime = 0.
		// - _oMediaElement.playbackRate = 1.
		// - Посылает abort в _oMediaSourceBuffer если нужно.
		// - Отсоединяет _oMediaSourceBuffer от _oMediaSource.
		// - Закрывает _oMediaSource.
		// - Открывает _oMediaSource.
		_oMediaElement.load();
		// Ждем вызова ОбработатьSourceOpen().
	}

	function СледитьЗаОшибками()
	{
		if (_oMediaElement.error)
		{
			м_Отладка.ЗавершитьРаботуИПоказатьСообщение('J0206');
		}
	}

	const СледитьЗаСобытиямиMediaSource = ДобавитьОбработчикИсключений(оСобытие =>
	{
		СледитьЗаОшибками();
		const сЗапись = `[MediaSource] ${оСобытие.type}`;
		switch (оСобытие.type)
		{
		case 'sourceopen':
			ПоказатьСостояние('Вот', сЗапись);
			_оПоведение.ОбработатьSourceOpen();
			break;

		case 'sourceended':
		case 'sourceclose':
			ПоказатьСостояние('Вот', сЗапись);
			break;
	
		default:
			м_Журнал.Вот(сЗапись);
		}
	});

	const СледитьЗаСобытиямиMediaElement = ДобавитьОбработчикИсключений(оСобытие =>
	{
		СледитьЗаОшибками();
		const сЗапись = `[MediaElement] ${оСобытие.type}`;
		switch (оСобытие.type)
		{
		case 'loadstart':
			ПоказатьСостояние('Вот', `${сЗапись} src=${_oMediaElement.src} currentSrc=${_oMediaElement.currentSrc}`);
			break;

		case 'progress':
			ПоказатьСостояние('Вот', сЗапись);
			_оПоведение.ОбработатьProgress();
			break;

		case 'abort':
			ПоказатьСостояние('Вот', сЗапись);
			break;

		case 'waiting':
			ПоказатьСостояние('Окак', сЗапись);
			_оПоведение.ОбработатьWaiting();
			break;

		case 'playing':
			ПоказатьСостояние('Вот', сЗапись);
			_оПоведение.ОбработатьPlaying();
			break;

		case 'seeking':
			ПоказатьСостояние('Вот', сЗапись);
			_оПоведение.ОбработатьSeeking();
			break;

		case 'seeked':
			ПоказатьСостояние('Вот', сЗапись);
			_оПоведение.ОбработатьSeeked();
			break;

		case 'ended':
			ПоказатьСостояние('Вот', сЗапись);
			_оПоведение.ОбработатьEnded();
			break;

		case 'timeupdate':
			м_Журнал.Вот(`${сЗапись} readyState=${_oMediaElement.readyState} currentTime=${_oMediaElement.currentTime} НеПросмотрено=${м_Журнал.F2(ПолучитьЗаполненностьБуфера().чНеПросмотрено)}`);
			_оПоведение.ОбработатьTimeUpdate();
			break;

			case 'canplay':
				fitVideo()
				break

		case 'volumechange':
			м_Журнал.Вот(`${сЗапись} volume=${_oMediaElement.volume} muted=${_oMediaElement.muted}`);
			break;

		default:
			м_Журнал.Вот(сЗапись);
		}
	});

	function ПроверитьПозициюВоспроизведения(чИсточникПроверки, чБудетДобавлено = 0)
	// Это единственная функция, которая во время прямой трансляции изменяет _oMediaElement.currentTime.
	// ПРОВЕРИТЬ_ДОБАВЛЕНИЕ_СЕГМЕНТА:
	// - Переносит вперед _oMediaElement.currentTime чтобы предотвратить переполнение буфера.
	// - Ничего не возвращает.
	// ПРОВЕРИТЬ_НАЧАЛО_ВОСПРОИЗВЕДЕНИЯ, ПРОВЕРИТЬ_ВОСПРОИЗВЕДЕНИЕ, ПРОВЕРИТЬ_ОСТАНОВКА_ВОСПРОИЗВЕДЕНИЯ:
	// - Переносит вперед _oMediaElement.currentTime если найдена область >= МИН_РАЗМЕР_БУФЕРА.
	// - Вызывает БуферИсчерпан() если область не найдена и идет воспроизведение.
	// Возвращает:
	// - ВОСПРОИЗВЕДЕНИЕ_НЕВОЗМОЖНО если область не найдена.
	// - ВОСПРОИЗВЕДЕНИЕ_ВОЗМОЖНО если область найдена.
	// - ВОСПРОИЗВЕДЕНИЕ_ВОЗМОЖНО_ПОСЛЕ_ПЕРЕМОТКИ если область найдена и запущена перемотка.
	{
		const оБуфер = _oMediaElement.buffered;
		const чПоследняяОбласть = оБуфер.length - 1;
		if (чПоследняяОбласть === -1)
		{
			return false;
		}
		// Chrome 47: currentTime может быть на 0.000001 секунды меньше присвоенной величины.
		// Если это не учесть, то получим бесконечную перемотку на начало области.
		const чТекущееВремя = _oMediaElement.currentTime + 0.0001;
		let чПеремотатьДо = Math.max(чТекущееВремя, оБуфер.start(0));
		let сПричинаПеремотки = '';
		const чНеПросмотрено = оБуфер.end(чПоследняяОбласть) - чПеремотатьДо;

		// Пропустить часть видео, чтобы не увеличивать задержку трансляции и чтобы _oMediaSource и
		// УдалитьПросмотренноеВидео() начали удалять просмотренное видео, предотвращая переполнение
		// _oMediaSourceBuffer. _oMediaSource при удалении (coded frame eviction) учитывает currentTime
		// и не учитывает played и paused.
		// Причины переполнения:
		// - Chrome 49: _oMediaSource был закрыт до первого перехода на вкладку.
		// - Разделять по ключевым кадрам и очень длинный GOP.
		// - Окончание трансляции (часть которой застряла на сервере?) и сразу начало новой (заранее записанной?).
		// - Серьезный затык в сети или на сервере.
		// - Изменение настроек.
		// - Очень большое количество разрывов.
		// - Выход из спячки.
		// - Edge 15: Выход из WIN + L.
		// - Зависание перемотки или воспроизведения.
		if (чИсточникПроверки === ПРОВЕРИТЬ_ДОБАВЛЕНИЕ_СЕГМЕНТА)
		{
			const чРазмерБуфера = м_Настройки.Получить('чМаксРазмерБуфера');
			const чПереполнение = чРазмерБуфера + м_Настройки.Получить('чРастягиваниеБуфера');
			if (чНеПросмотрено <= чПереполнение)
			{
				return; // Возвращаемое значение не используется.
			}
			// Не показывать переполнение если оно произошло из-за позднего перехода на вкладку.
			if (_чВоспроизведениеНачиналось === 2)
			{
				м_События.ОбработатьСобытие('проигрыватель-переполненбуфер', чНеПросмотрено - чРазмерБуфера);
			}
			сПричинаПеремотки += `Переполнен буфер проигрывателя ${чНеПросмотрено.toFixed(2)}с > ${чПереполнение}с. `;
			// Немного добавить, чтобы непросмотренного точно хватило для начала воспроизведения.
			чПеремотатьДо = оБуфер.end(чПоследняяОбласть) - чРазмерБуфера - 0.1;
		}

		// После перехода на вкладку начальная задержка трансляции может составить чРазмерБуфера + чРастягиваниеБуфера, что слишком много.
		// Если переход выполнен поздно, то в процессе добавления сегментов и начала воспроизведения может несколько раз сработать защита
		// от переполнения буфера и один раз защита от превышения задержки трансляции.
		if (чИсточникПроверки === ПРОВЕРИТЬ_НАЧАЛО_ВОСПРОИЗВЕДЕНИЯ && _чВоспроизведениеНачиналось !== 2)
		{
			_чВоспроизведениеНачиналось = 2;
			// Длительность сегментов не всегда кратна размеру буфера.
			// Также нужно немного добавить, чтобы непросмотренного точно хватило для начала воспроизведения.
			const чПереполнение = м_Настройки.Получить('чМаксРазмерБуфера') + м_Статистика.ПолучитьTargetDuration() / 2;
			if (чНеПросмотрено > чПереполнение)
			{
				сПричинаПеремотки += `Превышена задержка трансляции ${чНеПросмотрено.toFixed(2)}с > ${чПереполнение}с. `;
				чПеремотатьДо = оБуфер.end(чПоследняяОбласть) - чПереполнение;
			}
		}

		// Chrome 48, Firefox 48: Иногда currentTime вылезает за пределы области.
		//
		// Chrome 59 + Windows + аппаратное декодирование: Перемотка не завершится пока после точки перемотки не появится достаточно кадров
		// для начала воспроизведения. Пример: В буфере 1.0-5.1 с. После перемотки до 5.0 с, 100 мс (3 кадра) недостаточно для воспроизведения.
		// Добавлены кадры, часть которых утеряна, в буфере 1.0-5.1 6.0-10.0. Перемотка никогда не завершится. Чтобы этого не произошло,
		// запрещаем перемотку и воспроизведение если данных недостаточно. Исключение сделано для переполнения буфера.
		Проверить(ИСЧЕРПАНИЕ_БУФЕРА < МИН_РАЗМЕР_БУФЕРА);
		let чНужноДляВоспроизведения = чИсточникПроверки === ПРОВЕРИТЬ_ВОСПРОИЗВЕДЕНИЕ ? ИСЧЕРПАНИЕ_БУФЕРА
		                             : чИсточникПроверки === ПРОВЕРИТЬ_ОСТАНОВКА_ВОСПРОИЗВЕДЕНИЯ ? Infinity
		                             : МИН_РАЗМЕР_БУФЕРА;
		let лВоспроизведениеВозможно = _oMediaSource.readyState === 'ended';
		let чДоКонцаОбласти;
		for (let чОбласть = 0; чОбласть <= чПоследняяОбласть; ++чОбласть)
		{
			if (чПеремотатьДо < оБуфер.start(чОбласть))
			{
				чНужноДляВоспроизведения = МИН_РАЗМЕР_БУФЕРА;
				сПричинаПеремотки += 'Перепрыгиваю яму. ';
				чПеремотатьДо = оБуфер.start(чОбласть);
			}
			чДоКонцаОбласти = оБуфер.end(чОбласть) - чПеремотатьДо;
			if (чДоКонцаОбласти >= чНужноДляВоспроизведения)
			{
				лВоспроизведениеВозможно = true;
				break;
			}
		}

		if (!лВоспроизведениеВозможно && !_oMediaElement.paused)
		{
			// Остановить воспроизведение если нужно.
			БуферИсчерпан(чДоКонцаОбласти, чНеПросмотрено, чБудетДобавлено);
		}
		
		if ((лВоспроизведениеВозможно || чИсточникПроверки === ПРОВЕРИТЬ_ДОБАВЛЕНИЕ_СЕГМЕНТА) && (чПеремотатьДо !== чТекущееВремя || _лНужнаПеремотка))
		{
			// Разрывы в _oMediaElement.played нам не нужны.
			if (чПеремотатьДо === чТекущееВремя)
			{
				чПеремотатьДо = _oMediaElement.currentTime;
			}
			ПоказатьСостояние(сПричинаПеремотки ? 'Ой' : 'Окак', `${сПричинаПеремотки}Перематываю до ${чПеремотатьДо}`)
			_лНужнаПеремотка = false;
			_oMediaElement.currentTime = чПеремотатьДо;
			// Edge 15 и Chrome 59: _oMediaElement.seeking возвращает false после изменения _oMediaElement.currentTime.
			// В Chrome 59 бывает редко. https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/12581492/
			return ВОСПРОИЗВЕДЕНИЕ_ВОЗМОЖНО_ПОСЛЕ_ПЕРЕМОТКИ;
		}

		return лВоспроизведениеВозможно ? ВОСПРОИЗВЕДЕНИЕ_ВОЗМОЖНО : ВОСПРОИЗВЕДЕНИЕ_НЕВОЗМОЖНО;
	}

	function НачатьВоспроизведение(чПроверка /* необязательный */)
	// Это единственная функция, которая во время прямой трансляции вызывает _oMediaElement.play().
	//
	// Firefox 45: После окончания перемотки, _oMediaElement.readyState может остаться равным HAVE_CURRENT_DATA. Возможно
	// потому что после _oMediaElement.currentTime доступно < 25 кадров. Для увеличения _oMediaElement.readyState
	// нужно вызвать _oMediaElement.play().
	//
	// Firefox 45: Если УдалитьПросмотренноеВидео() удалит из буфера всё видео, но оставит часть звука, то возможно состояние:
	// _oMediaElement.readyState == HAVE_CURRENT_DATA и _oMediaElement.buffered.length == 0.
	{
		if ((_oMediaElement.seeking || чПроверка === ВОСПРОИЗВЕДЕНИЕ_ВОЗМОЖНО_ПОСЛЕ_ПЕРЕМОТКИ) || !_oMediaElement.paused || _oMediaElement.ended)
		{
			return;
		}

		if (_лЖдатьЗаполненияБуфера && _oMediaSource.readyState !== 'ended')
		{
			const {чНеПросмотрено} = ПолучитьЗаполненностьБуфера();
			const чРазмерБуфера = м_Настройки.Получить(_сРазмерБуфера);
			if (чНеПросмотрено < чРазмерБуфера)
			{
				м_Журнал.Вот(`[Проигрыватель] В буфере не просмотрено ${м_Журнал.F3(чНеПросмотрено)}с < ${чРазмерБуфера}с`);
				return;
			}
			м_Журнал.Окак(`[Проигрыватель] В буфере не просмотрено ${м_Журнал.F3(чНеПросмотрено)}с >= ${чРазмерБуфера}с`);
		}
		else
		{
			м_Журнал.Окак('[Проигрыватель] Не нужно ждать заполнения буфера');
		}

		switch (ПроверитьПозициюВоспроизведения(ПРОВЕРИТЬ_НАЧАЛО_ВОСПРОИЗВЕДЕНИЯ))
		{
		case ВОСПРОИЗВЕДЕНИЕ_НЕВОЗМОЖНО:
			ПоказатьСостояние('Ой', `Не найдена область >= ${МИН_РАЗМЕР_БУФЕРА}с для начала воспроизведения`);
			_лЖдатьЗаполненияБуфера = true;
			break;

		// Не начинаем воспроизведение во время перемотки, потому что ПроверитьПозициюВоспроизведения() могла перескочить
		// яму, из-за чего длительность непросмотренного видео могла упасть ниже _сРазмерБуфера. Нужно проверить
		// заполненность буфера еще раз.
		case ВОСПРОИЗВЕДЕНИЕ_ВОЗМОЖНО:
			ПоказатьСостояние('Окак', 'Начало воспроизведения');
			_лЖдатьЗаполненияБуфера = true;
			_oMediaElement.play();
			// Chrome 67, Firefox 60 Android, Edge 17: В этот момент даже без блокировок возможно _oMediaElement.paused == true.
			// Chrome 66+: Если в chrome://flags/#autoplay-policy включить autoplay policy, то в расширении play() будет
			// блокироваться пока пользователь не нажмет что-нибудь на странице. Обнаружить блокировку во время запуска
			// проигрывателя непросто, потому что она срабатывает только если в буфере есть данные для воспроизведения.
			// Chrome 67=: autoplay policy по ошибке применяется к расширениям браузера. Исправлено в поздних билдах.
			// https://bugs.chromium.org/p/chromium/issues/detail?id=849674
			// Воспроизведение не блокируется, если звук приглушен. Не ставим на паузу, потому что после снятия
			// с паузы придется довольно долго ждать заполнения буфера, а включение звука происходит мгновенно.
			// Если после начала воспроизведения попытаться включить звук без нажатия пользователя (например, по вращению
			// колеса мыши), то браузер поставит воспроизведение на паузу.
			// Иногда _oMediaElement.paused == true без блокировок. Использовать возвращаемое play() обещание неудобно из-за
			// асинхронности, а также потому что отказ от обещания может произойти по разным причинам, например после быстрого
			// вызова pause() или load(), ошибки воспроизведения.
			// UNDONE Удалить в августе вместе с новостью.
			if (ВЕРСИЯ_ДВИЖКА_БРАУЗЕРА === 67 && !НачатьВоспроизведение.лБлокировкаСнята && _oMediaElement.paused && !_oMediaElement.muted)
			{
				ПоказатьСостояние('Ой', '[Проигрыватель] Приглушаю звук чтобы снять блокировку воспроизведения браузером');
				_oMediaElement.muted = true;
				_oMediaElement.play();
				if (_oMediaElement.paused)
				{
					ПоказатьСостояние('Ой', '[Проигрыватель] Воспроизведение не началось. Восстанавливаю настройки звука.');
					_oMediaElement.muted = false;
				}
				else
				{
					ПоказатьСостояние('Вот', '[Проигрыватель] Блокировка воспроизведения снята');
					м_Настройки.Изменить('лПриглушить', true, true);
					м_Управление.ОбновитьНастройкиЗвука();
				}
			}
			НачатьВоспроизведение.лБлокировкаСнята = true;
			// Может пройти больше секунды, прежде чем начало видео будет декодировано и показано.
			// Ждем события playing для смены состояния.
			//
			// Firefox 45: Иногда, скорее всего из-за ошибки лисы, после события seeked и вызова play(),
			// readyState остается равно HAVE_METADATA и не прилетают loadeddata, canplay, canplaythrough
			// и playing. Воспроизведение идет нормально (не знаю насколько долго).
			м_Управление.ИзменитьСостояние(СОСТОЯНИЕ_НАЧАЛО_ВОСПРОИЗВЕДЕНИЯ);
			break;
		}
	}

	function ОстановитьВоспроизведение(чНовоеСостояние)
	// Это единственная функция, которая во время прямой трансляции вызывает _oMediaElement.pause().
	{
		if (чНовоеСостояние !== undefined)
		{
			м_Управление.ИзменитьСостояние(чНовоеСостояние);
		}
		_oMediaElement.pause();
	}

	function БуферИсчерпан(чДоКонцаПоследнейОбласти, чНеПросмотрено, чБудетДобавлено)
	{
		Проверить(_oMediaSource.readyState !== 'ended');
		Проверить(чДоКонцаПоследнейОбласти < МИН_РАЗМЕР_БУФЕРА);
		const лДосрочно = чНеПросмотрено > 1.0;
		м_Статистика.ИсчерпанБуферПроигрывателя(лДосрочно);
		_сРазмерБуфера = 'чМаксРазмерБуфера';
		const чРазмерБуфера = м_Настройки.Получить(_сРазмерБуфера);
		if (чДоКонцаПоследнейОбласти + чБудетДобавлено >= МИН_РАЗМЕР_БУФЕРА && чНеПросмотрено + чБудетДобавлено >= чРазмерБуфера)
		{
			// Это может произойти с нулевым чБудетДобавлено:
			// - Firefox 54 и ИСПОЛЬЗОВАТЬ_WAITING: Исчерпание буфера произошло во время appendBuffer():
			//   readyState=HAVE_ENOUGH_DATA ▪ appendBuffer() ▪ readyState=HAVE_CURRENT_DATA ▪ timeupdate ▪ waiting
			// - Firefox 48 и ИСПОЛЬЗОВАТЬ_WAITING: Остановка перед невидимой ямой, которая появилась из-за перепутаных CTS кадров.
			ПоказатьСостояние(лДосрочно ? 'Ой' : 'Окак', `Буфер исчерпан, остановка не нужна БудетДобавлено=${м_Журнал.F3(чБудетДобавлено)}с ДоКонцаПоследнейОбласти=${м_Журнал.F3(чДоКонцаПоследнейОбласти)}с НеПросмотрено=${м_Журнал.F3(чНеПросмотрено)}с РазмерБуфера=${чРазмерБуфера}с`);
		}
		else
		{
			ПоказатьСостояние(лДосрочно ? 'Ой' : 'Окак', `Приостанавливаю воспроизведение для заполнения буфера ДоКонцаПоследнейОбласти=${м_Журнал.F3(чДоКонцаПоследнейОбласти)}с НеПросмотрено=${м_Журнал.F3(чНеПросмотрено)}с РазмерБуфера=${чРазмерБуфера}с`);
			_лНужнаПеремотка = true;
			// Вместо pause() можно обнулить playbackRate.
			ОстановитьВоспроизведение(СОСТОЯНИЕ_ЗАГРУЗКА);
		}
	}

	function УдалитьПросмотренноеВидео()
	{
		const чДлительностьПовтора = м_Настройки.Получить('чДлительностьПовтора2');
		if (чДлительностьПовтора === АВТОНАСТРОЙКА)
		{
			return Promise.resolve();
		}
		const {чПросмотрено, чНеПросмотрено} = ПолучитьЗаполненностьБуфера(_oMediaSourceBuffer.buffered);
		let чУдалитьДо;
		{
			if (чПросмотрено < чДлительностьПовтора + ИНТЕРВАЛ_УДАЛЕНИЯ_ВИДЕО)
			{
				return Promise.resolve();
			}
			чУдалитьДо = _oMediaElement.currentTime - чДлительностьПовтора;
		}

		return new Promise((фВыполнить, фОтказаться) =>
		{
			ПоказатьСостояние('Вот', `Удаляю просмотренное видео Просмотрено=${м_Журнал.F3(чПросмотрено)}с УдалитьДо=${м_Журнал.F3(чУдалитьДо)}с`);
			_oMediaSourceBuffer.addEventListener('updateend', Удалено);
			let чПрошлоВремени = -performance.now();
			_oMediaSourceBuffer.remove(0, чУдалитьДо);

			function Удалено()
			{
				try
				{
					// Удаление прервано в ПерезагрузитьПроигрыватель()? Обрабатывать событие abort не нужно.
					if (_oMediaSourceBuffer === null)
					{
						фОтказаться(ОтменаОбещания.ОБЕЩАНИЕ_ОТМЕНЕНО);
					}
					else
					{
						чПрошлоВремени += performance.now();
						_oMediaSourceBuffer.removeEventListener('updateend', Удалено);
						const {чПросмотрено} = ПолучитьЗаполненностьБуфера(_oMediaSourceBuffer.buffered);
						ПоказатьСостояние(чПрошлоВремени > 100 || чПросмотрено < МИН_РАЗМЕР_БУФЕРА ? 'Ой' : 'Вот',
							`Просмотренное видео удалено за ${м_Журнал.F0(чПрошлоВремени)}мс Просмотрено=${м_Журнал.F0(чПросмотрено)}с`);
						фВыполнить();
					}
				}
				catch (пИсключение)
				{
					фОтказаться(пИсключение);
				}
			}
		});
	}

	function ДобавитьСегмент(оСегмент, лИнициализация)
	{
		return new Promise((фВыполнить, фОтказаться) =>
		{
			ПоказатьСостояние('Вот', `Добавляю ${лИнициализация ? 'сегмент инициализации' : 'медиасегмент'} ${оСегмент.чНомер}`);
			_oMediaSourceBuffer.addEventListener('updateend', Добавлено);
			let чПрошлоВремени = -performance.now();
			_oMediaSourceBuffer.appendBuffer(лИнициализация ? оСегмент.пДанные.мбСегментИнициализации : оСегмент.пДанные.мбМедиасегмент);
		
			function Добавлено()
			{
				try
				{
					// Добавление прервано в ПерезагрузитьПроигрыватель()? Обрабатывать событие abort не нужно.
					if (_oMediaSourceBuffer === null)
					{
						фОтказаться(ОтменаОбещания.ОБЕЩАНИЕ_ОТМЕНЕНО);
					}
					else
					{
						чПрошлоВремени += performance.now();
						_oMediaSourceBuffer.removeEventListener('updateend', Добавлено);
						ПоказатьСостояние(чПрошлоВремени > 100 ? 'Ой' : 'Вот',
							`Добавлен сегмент ${оСегмент.чНомер} за ${м_Журнал.F0(чПрошлоВремени)}мс`);
						фВыполнить();
					}
				}
				catch (пИсключение)
				{
					фОтказаться(пИсключение);
				}
			}
		});
	}

	function ПредотвратитьПереполнениеОчереди()
	// Chrome 49: _oMediaSource закрыт до первого перехода на вкладку. Если пользователь забудет перейти, то получим переполнение
	// очереди. Немного ждем и останавливаем работу, чтобы избежать переполнения и не нагружать напрасно железо.
	// TODO Если в очереди есть разрывы, то теоретически задержка трансляции может превышать указанную в настройках проигрывателя.
	{
		// Нет смысла накапливать больше ПЕРЕПОЛНЕНИЕ_БУФЕРА, потому что этот излишек будет пропущен. Останавливать просмотр трансляции
		// по достижении чРазмерБуфера или даже чРазмерБуфера + чРастягиваниеБуфера слишком рано, потому что пользователь с широким каналом
		// не успеет переключиться на вкладку.
		const чПреобразовано = г_моОчередь.ПолучитьКоличествоПреобразованныхСегментов().чДлительность;
		if (чПреобразовано >= ПЕРЕПОЛНЕНИЕ_БУФЕРА)
		{
			м_Журнал.Ой(`[Проигрыватель] MediaSource закрыт слишком долго ${чПреобразовано}с >= ${ПЕРЕПОЛНЕНИЕ_БУФЕРА}с`);
			Проверить(м_Управление.ПолучитьСостояние() === СОСТОЯНИЕ_ЗАПУСК || м_Управление.ПолучитьСостояние() === СОСТОЯНИЕ_НАЧАЛО_ТРАНСЛЯЦИИ);
			м_Управление.ОстановитьПросмотрТрансляции();
		}
	}

	function ЗавершитьПоток(оСегмент)
	// Это единственная функция, которая во время прямой трансляции вызывает _oMediaSource.endOfStream().
	// Chrome 50: До endOfStream() _oMediaElement.duration может быть еще = NaN.
	// Chrome 49: Если не было appendBuffer(), то после endOfStream() _oMediaElement.duration = Infinity. https://bugs.chromium.org/p/chromium/issues/detail?id=604353
	{
		ПоказатьСостояние('Окак', `Сегмент ${оСегмент.чНомер} вызвал окончание потока`);
		// После endOfStream() в _oMediaElement.buffered могут появиться области без звука или видео. Firefox 48, согласно текущей
		// версии стандарта, на такие места не перематывает. Chrome 52 перематывает и воспроизводит. Чтобы в Firefox воспроизведение
		// не зависло, проверяем _oMediaElement.buffered ДО вызова endOfStream(). https://bugzilla.mozilla.org/show_bug.cgi?id=1294412
		if (_oMediaElement.buffered.length === 0
		// Часто перед окончанием потока в буфере остается ИСЧЕРПАНИЕ_БУФЕРА (если не ИСПОЛЬЗОВАТЬ_WAITING) и несколько кадров,
		// застревающих в рабочем потоке: Пауза ▪ Воспроизведение нескольких кадров ▪ Пауза ▪ Воспроизведение другого видео.
		// Смотрить на это не слишком приятно, поэтому не начинаем воспроизведение ради нескольких кадров.
		|| (_oMediaElement.paused && ПолучитьЗаполненностьБуфера().чНеПросмотрено < ИСЧЕРПАНИЕ_БУФЕРА + 0.1))
		{
			ПерезагрузитьИЖдатьЗаполненияБуфера(СОСТОЯНИЕ_ЗАГРУЗКА);
		}
		else
		{
			// Перемотка во время прямой трансляции означает, что в буфере достаточно данных для воспроизведения.
			_лЖдатьЗаполненияБуфера = typeof оСегмент.пДанные === 'number' || (!_oMediaElement.seeking && _oMediaElement.paused);
			_oMediaSource.endOfStream();
			НачатьВоспроизведение();
		}
	}

	function НайтиИОбработатьСменуВариантаТрансляции()
	{
		for (let ы = г_моОчередь.length; --ы >= 0;)
		{
			if (г_моОчередь[ы].пДанные === СОСТОЯНИЕ_СМЕНА_ВАРИАНТА && г_моОчередь[ы].чОбработка === ОБРАБОТКА_ПРЕОБРАЗОВАН)
			{
				г_моОчередь.ПоказатьСостояние();
				do
				{
					if (г_моОчередь[ы].пДанные === СОСТОЯНИЕ_СМЕНА_ВАРИАНТА || typeof г_моОчередь[ы].пДанные !== 'number')
					{
						г_моОчередь.Удалить(ы);
					}
				}
				while (--ы >= 0);
				г_моОчередь.ПоказатьСостояние();

				ПерезагрузитьИЖдатьЗаполненияБуфера(СОСТОЯНИЕ_ЗАГРУЗКА);
				break;
			}
		}
	}

	function ДобавитьСледующийСегмент()
	{
		Проверить(_oMediaElement);

		НайтиИОбработатьСменуВариантаТрансляции();
		const оСегмент = г_моОчередь[0];
		if (!оСегмент || оСегмент.чОбработка !== ОБРАБОТКА_ПРЕОБРАЗОВАН)
		{
			return;
		}
		Проверить(_оПоведение === _оПрямаяТрансляция);

		if (оСегмент.пДанные === СОСТОЯНИЕ_НАЧАЛО_ТРАНСЛЯЦИИ)
		{
			Проверить(_oMediaSource.sourceBuffers.length === 0);
			м_Управление.ИзменитьСостояние(оСегмент.пДанные);
			г_моОчередь.Удалить(0);
			ДобавитьСледующийСегмент();
			return;
		}

		if (_лАсинхроннаяОперация)
		{
			return;
		}

		if (оСегмент.пДанные === СОСТОЯНИЕ_ПОВТОР)
		{
			Проверить(м_Управление.ПолучитьСостояние() !== СОСТОЯНИЕ_ОСТАНОВКА && м_Управление.ПолучитьСостояние() !== СОСТОЯНИЕ_ПОВТОР);
			ЗапуститьПовтор();
			г_моОчередь.Удалить(0);
			ДобавитьСледующийСегмент();
			return;
		}

		const сГотовность = _oMediaSource.readyState;
		if (сГотовность !== 'open')
		{
			м_Журнал.Вот(`[Проигрыватель] Добавление сегмента ${оСегмент.чНомер} отложено MediaSource.readyState=${сГотовность} MediaElement.src=${_oMediaElement.src}`);
			if (сГотовность === 'closed' && _чВоспроизведениеНачиналось === 0)
			{
				ПредотвратитьПереполнениеОчереди();
			}
			return;
		}

		if (оСегмент.лРазрыв && _oMediaSource.sourceBuffers.length !== 0)
		{
			ЗавершитьПоток(оСегмент);
			return;
		}

		if (оСегмент.пДанные === СОСТОЯНИЕ_ЗАВЕРШЕНИЕ_ТРАНСЛЯЦИИ)
		{
			Проверить(оСегмент.лРазрыв && _oMediaSource.sourceBuffers.length === 0);
			м_Управление.ИзменитьСостояние(оСегмент.пДанные);
			г_моОчередь.Удалить(0);
			ДобавитьСледующийСегмент();
			return;
		}

		if (_oMediaSource.sourceBuffers.length === 0)
		{
			ДобавитьБуферы(оСегмент);
		}

		_лАсинхроннаяОперация = true;
		let оОбещание = УдалитьПросмотренноеВидео()
		.then(() =>
		{
			// Событие timeupdate посылается редко, каждые 250..500 мс, поэтому исчерпание буфера может быть пропущено,
			// что особенно неприятно в Edge 15 с его принудительной буферизацией. Добавляем еще одну проверку перед изменением
			// буфера. Почему проверка после удаления видео, а не перед ним: это повышает вероятность обнаружить исчерпание
			// буфера и повышает точность чБудетДобавлено, потому что за время удаления видео позиция воспроизведения изменяется.
			// Код в этой функции аналогичен обработчику timeupdate, за исключением передачи параметра чБудетДобавлено.
			if (!_oMediaElement.seeking && !_oMediaElement.paused && !_oMediaElement.ended)
			{
				ПроверитьПозициюВоспроизведения(ПРОВЕРИТЬ_ВОСПРОИЗВЕДЕНИЕ, оСегмент.чДлительность);
			}
		}) // ; мешает IntelliSense
		if (оСегмент.пДанные.мбСегментИнициализации)
		{
			оОбещание = оОбещание.then(() => ДобавитьСегмент(оСегмент, true));
		}
		оОбещание.then(() =>
		{
			return ДобавитьСегмент(оСегмент, false);
		})
		.then(() =>
		{
			_лАсинхроннаяОперация = false;
			г_моОчередь.Удалить(оСегмент);
			// Нет смысла начинать воспроизведение если запрошен повтор.
			if (!(г_моОчередь[0] && г_моОчередь[0].пДанные === СОСТОЯНИЕ_ПОВТОР))
			{
				РасчитатьСмещениеНачалаТрансляции(оСегмент);
				// Предотвратить переполнение буфера проигрывателя.
				const чПроверка = ПроверитьПозициюВоспроизведения(ПРОВЕРИТЬ_ДОБАВЛЕНИЕ_СЕГМЕНТА);
				// Начать воспроизведение только после добавления всех накопившихся в очереди преобразованных сегментов.
				// Во время добавления части добавленного потока могут многократно удаляться из-за переполнения буфера.
				// Похожая проверка есть в ОбработатьProgress().
				if (!(г_моОчередь[0] && г_моОчередь[0].чОбработка === ОБРАБОТКА_ПРЕОБРАЗОВАН))
				{
					НачатьВоспроизведение(чПроверка);
					ПоказатьПродолжительностьТрансляции();
					ПоказатьЗадержкуТрансляции(оСегмент);
				}
			}
			ДобавитьСледующийСегмент();
		})
		.catch(ДобавитьОбработчикИсключений(пПричина =>
		{
			_лАсинхроннаяОперация = false;
			if (пПричина === 'ДОБАВЛЕНИЕ СЕГМЕНТА ОТЛОЖЕНО')
			{
				return;
			}
			// ПерезагрузитьПроигрыватель() прервала выполнение УдалитьПросмотренноеВидео() или ДобавитьСегмент()?
			if (пПричина === ОтменаОбещания.ОБЕЩАНИЕ_ОТМЕНЕНО)
			{
				м_Журнал.Вот(`[Проигрыватель] Отменено добавление сегмента ${оСегмент.чНомер}`);
				г_моОчередь.Удалить(оСегмент);
			}
			else
			{
				throw пПричина;
			}
		}));
	}

	function ПеремотатьПовторДо(чПеремотатьДо)
	{
		Проверить(м_Управление.ПолучитьСостояние() === СОСТОЯНИЕ_ПОВТОР);
		_оПовтор.ПроверитьПозициюВоспроизведения(чПеремотатьДо);
	}

	function ПеремотатьПовторНа(лКадры, чПеремотатьНа)
	{
		Проверить(м_Управление.ПолучитьСостояние() === СОСТОЯНИЕ_ПОВТОР);
		Проверить(Number.isFinite(чПеремотатьНа));
		if (лКадры)
		{
			чПеремотатьНа *= м_Статистика.ПолучитьДлительностьКадраВСекундах().чМинимальная;
		}
		if (чПеремотатьНа !== 0)
		{
			ПеремотатьПовторДо(Ограничить(_oMediaElement.currentTime + чПеремотатьНа, м_Шкала.ПолучитьНачало(), м_Шкала.ПолучитьКонец()));
		}
	}

	function ПереключитьПаузу()
	{
		Проверить(м_Управление.ПолучитьСостояние() === СОСТОЯНИЕ_ПОВТОР);
		if (_оПовтор.лПауза = !_оПовтор.лПауза)
		{
			м_Журнал.Окак('[Проигрыватель] Ставлю повтор на паузу');
			_oMediaElement.pause();
		}
		else
		{
			м_Журнал.Окак('[Проигрыватель] Снимаю повтор с паузы');
			_оПовтор.ПроверитьПозициюВоспроизведения(ПРОВЕРИТЬ_НАЧАЛО_ВОСПРОИЗВЕДЕНИЯ);
			_oMediaElement.play();
		}
		м_События.ОбработатьСобытие('проигрыватель-пауза', _оПовтор.лПауза);
	}

	function ЗадатьСкоростьПовтора(чСкорость)
	{
		Проверить(м_Управление.ПолучитьСостояние() === СОСТОЯНИЕ_ПОВТОР);
		_oMediaElement.playbackRate = чСкорость;
	}

	function ЗапуститьПовтор()
	{
		_оПовтор.лПауза = true;
		_оПоведение = _оПовтор;
		ОстановитьВоспроизведение();
		// Chrome 52: Если вызвать endOfStream() до addSourceBuffer(), то _oMediaElement.error.code = MEDIA_ERR_SRC_NOT_SUPPORTED.
		if (_oMediaSource.sourceBuffers.length !== 0 && _oMediaSource.readyState === 'open')
		{
			_oMediaSource.endOfStream();
		}

		const {чПросмотрено} = ПолучитьЗаполненностьБуфера();
		// В ПроверитьПозициюВоспроизведения() часть видео может быть промотана еще до начала воспроизведения.
		if (_oMediaElement.played.length === 0 || чПросмотрено < ПОВТОР_НЕДОСТУПЕН_ЕСЛИ_ПРОСМОТРЕНО_МЕНЬШЕ_ЧЕМ)
		{
			ПоказатьСостояние('Окак', 'Повторять нечего');
			м_Управление.ИзменитьСостояние(СОСТОЯНИЕ_ОСТАНОВКА);
			return;
		}

		ПоказатьСостояние('Окак', 'Запуск повтора');
		_oMediaElement.playbackRate = м_Управление.ПолучитьСкоростьВоспроизведения();
		м_События.ОбработатьСобытие('проигрыватель-пауза', _оПовтор.лПауза);
		// Chrome 48: Иногда currentTime вылезает за пределы области.
		м_Шкала.ЗадатьНачалоИКонец(_oMediaElement.buffered.start(0), _oMediaElement.buffered.start(0) + чПросмотрено);
		м_Шкала.ЗадатьПросмотрено(_oMediaElement.currentTime);
		м_Управление.ИзменитьСостояние(СОСТОЯНИЕ_ПОВТОР);
	}

	function ДобавитьБуферы(оСегмент)
	{
		м_Журнал.Окак(`[Проигрыватель] Добавляю буфер ${оСегмент.пДанные.сКодеки}`);
		Проверить(оСегмент.лРазрыв && оСегмент.пДанные.сКодеки);
		try
		{
			_oMediaSourceBuffer = _oMediaSource.addSourceBuffer(оСегмент.пДанные.сКодеки);
		}
		catch (пИсключение)
		{
			// Edge 15 кидает DOMException, которое не является потомком Error.
			if (ЭтоОбъект(пИсключение) && пИсключение.name === 'NotSupportedError')
			{
				м_Отладка.ЗавершитьРаботуИПоказатьСообщение('J0201');
			}
			else
			{
				м_Отладка.ПойманоИсключение(пИсключение);
			}
		}
		_oMediaSourceBuffer.addEventListener('updatestart', СледитьЗаСобытиямиMediaSource);
		_oMediaSourceBuffer.addEventListener('update',      СледитьЗаСобытиямиMediaSource);
		_oMediaSourceBuffer.addEventListener('updateend',   СледитьЗаСобытиямиMediaSource);
		_oMediaSourceBuffer.addEventListener('abort',       СледитьЗаСобытиямиMediaSource);
		_oMediaSourceBuffer.addEventListener('error',       СледитьЗаСобытиямиMediaSource);
	}

	function Запустить()
	{
		Проверить(!_oMediaElement);

		try
		{
			_oMediaSource = new MediaSource();
		}
		catch (и)
		{
			м_Отладка.ЗавершитьРаботуИПоказатьСообщение('J0202');
		}
		_oMediaSource.addEventListener('sourceopen',                       СледитьЗаСобытиямиMediaSource);
		_oMediaSource.addEventListener('sourceended',                      СледитьЗаСобытиямиMediaSource);
		_oMediaSource.addEventListener('sourceclose',                      СледитьЗаСобытиямиMediaSource);
		_oMediaSource.sourceBuffers.addEventListener('addsourcebuffer',    СледитьЗаСобытиямиMediaSource);
		_oMediaSource.sourceBuffers.addEventListener('removesourcebuffer', СледитьЗаСобытиямиMediaSource);

		_oMediaElement = document.getElementById('глаз');
		ПрименитьНастройкиЗвука();
		for (let сСобытие of
		[
			'progress', 'error', 'playing', 'seeking', 'seeked', 'ended', 'timeupdate',
			'waiting',
			'loadstart', 'suspend', 'abort', 'emptied', 'stalled', 'loadedmetadata', 'loadeddata',
			'canplay', 'canplaythrough', 'durationchange', 'play', 'pause', 'ratechange', 'resize'
		])
		{
			_oMediaElement.addEventListener(сСобытие, СледитьЗаСобытиямиMediaElement);
		}
		_oMediaElement.src = URL.createObjectURL(_oMediaSource);
		return true;
	}

	function Остановить()
	{
		if (_oMediaElement)
		{
			URL.revokeObjectURL(_oMediaElement.src);
			_oMediaElement.removeAttribute('src');
			_oMediaElement.load();
		}
	}

	return {
		Запустить, Остановить,
		ПолучитьЗаполненностьБуфера, ПолучитьКоличествоПропущенныхКадров, ПолучитьПозициюВоспроизведенияТрансляции,
		ПоказатьСостояние,
		Перезагрузить: ПерезагрузитьИЖдатьЗаполненияБуфера,
		ПрименитьНастройкиЗвука,
		ДобавитьСледующийСегмент,
		ПеремотатьПовторДо, ПеремотатьПовторНа, ПереключитьПаузу, ЗадатьСкоростьПовтора
	};
})();

const м_Список = (() =>
{
	const ИНТЕРВАЛ_ОБНОВЛЕНИЯ_СПИСКА_ВАРИАНТОВ_НАЧАЛО      = 3000;  // Миллисекунды.
	const ИНТЕРВАЛ_ОБНОВЛЕНИЯ_СПИСКА_ВАРИАНТОВ_КОНЕЦ       = 30000; // Миллисекунды.
	const ИНТЕРВАЛ_ОБНОВЛЕНИЯ_СПИСКА_ВАРИАНТОВ_ШАГ         = 1000;  // Миллисекунды.

	const ДОБАВИТЬ_К_ИНТЕРВАЛУ_ОБНОВЛЕНИЯ_СПИСКА_СЕГМЕНТОВ = 150;   // Миллисекунды. Длительность сегмента может быть чуть больше чем обычно.
	                                                                // Новый сегмент может быть доступен чуть позже чем обычно.
	const КОЛИЧЕСТВО_СЕГМЕНТОВ_ДЛЯ_РАСЧЕТА_ИНТЕРВАЛА       = 10;    // Количество.

	// СОСТОЯНИЕ_НАЧАЛО_ТРАНСЛЯЦИИ - идет трансляция.
	// СОСТОЯНИЕ_ЗАВЕРШЕНИЕ_ТРАНСЛЯЦИИ - трансляция завершена, периодически проверять ее начало.
	// СОСТОЯНИЕ_ОСТАНОВКА - работа полностью остановлена.
	let _чСостояние = СОСТОЯНИЕ_ОСТАНОВКА;
	// СОСТОЯНИЕ_НАЧАЛО_ТРАНСЛЯЦИИ - индекс последнего сегмента в _мчДлительностьСегментов.
	// СОСТОЯНИЕ_ЗАВЕРШЕНИЕ_ТРАНСЛЯЦИИ - интервал обновления списка вариантов.
	let _чИнтервалОбновленияСписка;
	// Кольцевой буфер, в котором хранятся длительности последних сегментов.
	// Используется для расчета интервала обновления списка сегментов.
	let _мчДлительностьСегментов = new Array(КОЛИЧЕСТВО_СЕГМЕНТОВ_ДЛЯ_РАСЧЕТА_ИНТЕРВАЛА);
	let _ооОбновлениеСписков = new ОтменаОбещания();
	// Список отсортирован по убыванию nPeakBitrate. Исходный вариант всегда в начале списка.
	// {
	//   nPeakBitrate
	//   сИдентификатор
	//   сНазвание
	//   сАбсолютныйАдресСпискаСегментов
	//   сКодеки
	// }
	let _моСписокВариантов = null;
	// Индекс _моСписокВариантов.
	let _чВыбранныйВариант;
	// {
	//   nTargetDuration,
	//   nMediaSequenceNumber,
	//   лКонецСписка,
	//   моСегменты:
	//   {
	//     сАдрес,
	//     чДлительность,
	//     лРазрыв
	//   }
	// }
	let _оПоследнийСписок = null;

	function РазобратьСписок(лЭтоСписокВариантов, сАбсолютныйАдресСписка, сРазбираемыйСписок)
	{
		// https://tools.ietf.org/html/rfc8216
		const МАКС_ПОДДЕРЖИВАЕМАЯ_ВЕРСИЯ_HLS = 7;

		// Иногда вместе с кодом 200 вместо списка прилетает HTML произвольного содержания. Например
		// 400 Bad Request (nginx) или сообщение об окончании денег на счете интернет-провайдера. :)
		if (!сРазбираемыйСписок.startsWith('#EXTM3U'))
		{
			throw `Вместо списка загружена какая-то фигня длиною ${сРазбираемыйСписок.length}\n${сРазбираемыйСписок}`;
		}

		let чВерсия = 1;
		let mapRenditionGroups, моСписокВариантов, оНовыйВариант;
		let чДлительностьСписка, nMediaSequenceNumber, чTwitchПрошлоВремени, nTargetDuration, лКонецСписка, лРазрыв, моСегменты, оНовыйСегмент;
		if (лЭтоСписокВариантов)
		{
			mapRenditionGroups = new Map(); // Порядок элементов не важен.
			моСписокВариантов = [];
			оНовыйВариант = null; // Используется для проверки порядка следования тегов.
		}
		else
		{
			чДлительностьСписка = 0; // Статистика.
			nMediaSequenceNumber = 0;
			чTwitchПрошлоВремени = NaN;
			лРазрыв = false;
			моСегменты = [];
			оНовыйСегмент = null; // Используется для проверки порядка следования тегов.
		}

		const рвТегИлиАдрес = /^#([A-Z0-9\-]+)(?::(.+))?$|^[^#\r\n].*$/mg;
		// Пропускаем #EXTM3U.
		рвТегИлиАдрес.lastIndex = 7;
		for (let мсТегИлиАдрес; мсТегИлиАдрес = рвТегИлиАдрес.exec(сРазбираемыйСписок);)
		{
			let [сАдрес, сНазваниеТега, сЗначениеТега] = мсТегИлиАдрес;

			if (сАдрес.charAt(0) !== '#')
			{
				сАдрес = ResolveRelativeUrl(сАдрес, сАбсолютныйАдресСписка);
				if (лЭтоСписокВариантов)
				{
					Проверить(оНовыйВариант);
					оНовыйВариант.сАбсолютныйАдресСпискаСегментов = сАдрес;
					моСписокВариантов.push(оНовыйВариант);
					оНовыйВариант = null;
				}
				else
				{
					Проверить(оНовыйСегмент);
					Проверить(typeof оНовыйСегмент.чДлительность !== 'undefined');
					Проверить(!лКонецСписка);
					оНовыйСегмент.чTwitchПрошлоВремени = чTwitchПрошлоВремени;
					оНовыйСегмент.лРазрыв = лРазрыв;
					оНовыйСегмент.сАдрес = сАдрес;
					моСегменты.push(оНовыйСегмент);
					чДлительностьСписка  += оНовыйСегмент.чДлительность;
					чTwitchПрошлоВремени += оНовыйСегмент.чДлительность;
					лРазрыв = false;
					оНовыйСегмент = null;
				}
				continue;
			}

			switch (сНазваниеТега)
			{
			//
			// Теги общие для обоих типов списка.
			// #EXT-X-INDEPENDENT-SEGMENTS не используется.
			//
			case 'EXTM3U':
				Проверить(false);
				break;

			case 'EXT-X-VERSION':
				Проверить(чВерсия === 1);
				чВерсия = ParseDecimalInteger(сЗначениеТега);
				Проверить(чВерсия >= 2 && чВерсия <= МАКС_ПОДДЕРЖИВАЕМАЯ_ВЕРСИЯ_HLS);
				break;

			case 'EXT-X-START':
				Проверить(false);
				break;

			//
			// Теги списка вариантов.
			//
			case 'EXT-X-MEDIA':
			{
				Проверить(лЭтоСписокВариантов);
				const амАтрибуты = РазобратьСписокАтрибутов(сЗначениеТега);
				const сТип = амАтрибуты.get('TYPE');
				Проверить(сТип);
				// Видео и звук должны находиться в одном файле.
				Проверить((сТип !== 'VIDEO' && сТип !== 'AUDIO') || !амАтрибуты.has('URI'));
				if (сТип !== 'VIDEO')
				{
					м_Журнал.Ой(`[Список] Найден #EXT-X-MEDIA TYPE=${сТип}`);
				}
				else
				{
					const сГруппа = ParseQuotedString(амАтрибуты.get('GROUP-ID'));
					Проверить(!mapRenditionGroups.has(сГруппа));
					mapRenditionGroups.set(сГруппа, ParseQuotedString(амАтрибуты.get('NAME')));
				}
				break;
			}

			case 'EXT-X-STREAM-INF':
			{
				Проверить(лЭтоСписокВариантов);
				// Пропущен адрес?
				Проверить(!оНовыйВариант);
				оНовыйВариант = Object.create(null);
				const амАтрибуты = РазобратьСписокАтрибутов(сЗначениеТега);
				// Иногда после завершения трансляции BANDWIDTH=0.
				оНовыйВариант.nPeakBitrate = ParseDecimalInteger(амАтрибуты.get('BANDWIDTH'));
				оНовыйВариант.сКодеки = амАтрибуты.has('CODECS') ? ParseQuotedString(амАтрибуты.get('CODECS')) : '';
				Проверить(!амАтрибуты.has('AUDIO') && !амАтрибуты.has('SUBTITLES') && !амАтрибуты.has('CLOSED-CAPTIONS'));
				if (амАтрибуты.has('VIDEO'))
				{
					оНовыйВариант.сИдентификатор = ParseQuotedString(амАтрибуты.get('VIDEO'));
				}
				break;
			}

			case 'EXT-X-I-FRAME-STREAM-INF':
			case 'EXT-X-SESSION-DATA':
			case 'EXT-X-SESSION-KEY':
				Проверить(лЭтоСписокВариантов);
				break;

			//
			// Теги списка сегментов для всех сегментов.
			//
			case 'EXT-X-TARGETDURATION':
				Проверить(!лЭтоСписокВариантов);
				Проверить(nTargetDuration === undefined);
				nTargetDuration = ParseDecimalInteger(сЗначениеТега);
				Проверить(nTargetDuration > 0 && nTargetDuration < 24 * 60 * 60);
				break;

			case 'EXT-X-MEDIA-SEQUENCE':
				Проверить(!лЭтоСписокВариантов);
				Проверить(nMediaSequenceNumber === 0);
				nMediaSequenceNumber = ParseDecimalInteger(сЗначениеТега);
				break;

			case 'EXT-X-ENDLIST':
				Проверить(!лЭтоСписокВариантов);
				Проверить(лКонецСписка === undefined);
				Проверить(сЗначениеТега === undefined);
				лКонецСписка = true;
				м_Журнал.Окак(`[Список] #EXT-X-ENDLIST после сегмента ${nMediaSequenceNumber + моСегменты.length - 1}`);
				break;

			// Пока разбирать #EXT-X-DISCONTINUITY-SEQUENCE не нужно, потому что любой пропуск сегмента добавляет разрыв.
			case 'EXT-X-DISCONTINUITY-SEQUENCE':
			case 'EXT-X-DATERANGE':
				Проверить(!лЭтоСписокВариантов);
				break;

			case 'EXT-X-PLAYLIST-TYPE':
			case 'EXT-X-I-FRAMES-ONLY':
				Проверить(false);
				break;

			//
			// Теги списка сегментов для конкретного сегмента.
			//
			case 'EXTINF':
				Проверить(!лЭтоСписокВариантов);
				оНовыйСегмент = оНовыйСегмент || Object.create(null);
				Проверить(typeof оНовыйСегмент.чДлительность === 'undefined');
				оНовыйСегмент.чДлительность = ParseExtinfTag(сЗначениеТега);
				if (оНовыйСегмент.чДлительность - nTargetDuration > 1)
				{
					м_Журнал.Ой(`[Список] Длительность сегмента превышена на ${оНовыйСегмент.чДлительность - nTargetDuration}с`);
				}
				break;

			case 'EXT-X-DISCONTINUITY':
				// Twitch: Раньше архивные трансляции завершались странно:
				// #EXT-X-DISCONTINUITY
				// #EXT-X-ENDLIST
				Проверить(!лЭтоСписокВариантов);
				Проверить(!лРазрыв);
				Проверить(сЗначениеТега === undefined);
				лРазрыв = true;
				м_Журнал.Ой(`[Список] #EXT-X-DISCONTINUITY у сегмента ${nMediaSequenceNumber + моСегменты.length}`);
				break;

			case 'EXT-X-PROGRAM-DATE-TIME':
				Проверить(!лЭтоСписокВариантов);
				break;

			case 'EXT-X-BYTERANGE':
			case 'EXT-X-KEY':
			case 'EXT-X-MAP':
				Проверить(false);
				break;
		
			//
			// Нестандартные теги Twitch.
			//
			case 'EXT-X-TWITCH-ELAPSED-SECS':
				Проверить(!лЭтоСписокВариантов);
				Проверить(моСегменты.length === 0);
				Проверить(Number.isNaN(чTwitchПрошлоВремени));
				чTwitchПрошлоВремени = ParseFloatingPointOrDecimalInteger(сЗначениеТега);
				break;
			}
		}

		if (лЭтоСписокВариантов)
		{
			// Пропущен адрес?
			Проверить(!оНовыйВариант);

			for (let оВариант of моСписокВариантов)
			{
				if ('сИдентификатор' in оВариант)
				{
					оВариант.сНазвание = mapRenditionGroups.get(оВариант.сИдентификатор);
					Проверить(оВариант.сНазвание);
				}
				else
				{
					// #EXT-X-STREAM-INF без #EXT-X-MEDIA.
					оВариант.сИдентификатор = `CoolCmd${оВариант.nPeakBitrate}`;
					оВариант.сНазвание = `${м_i18n.ФорматироватьЧисло(оВариант.nPeakBitrate / 1000000, 1)} ${Текст('J0114')}`;
				}
				м_Журнал.Окак(`[Список] Добавлен вариант PeakBitrate=${оВариант.nPeakBitrate} Идентификатор=${оВариант.сИдентификатор} Название=${оВариант.сНазвание} Кодеки=${оВариант.сКодеки}`);
			}

			моСписокВариантов.sort(СравнитьВарианты);
			return моСписокВариантов;
		}

		// Пропущен адрес?
		Проверить(!оНовыйСегмент);
		// Пропущен #EXT-X-TARGETDURATION?
		Проверить(nTargetDuration !== undefined);
		const оСписокСегментов =
		{
			nTargetDuration,
			nMediaSequenceNumber,
			лКонецСписка: !!лКонецСписка,
			моСегменты
		};
		м_Журнал.Вот(`[Список] Разобран список сегментов TargetDuration=${nTargetDuration} MediaSequenceNumber=${nMediaSequenceNumber} КоличествоСегментов=${моСегменты.length} ДлительностьСписка=${м_Журнал.F1(чДлительностьСписка)}с`);
		м_Статистика.РазобранСписокСегментов(оСписокСегментов, чДлительностьСписка);
		return оСписокСегментов;
	}

	function СравнитьВарианты(оВариант1, оВариант2)
	// Сортирует список по убыванию nPeakBitrate. Исходный вариант всегда в начале списка.
	// HACK Twitch: nPeakBitrate исходного варианта отражает текущее значение, которое может быть намного
	// меньше среднего и максимального. Также при пережатии исходного варианта битрейт может не уменьшиться,
	// а увеличиться. В этих случаях сортировка только по nPeakBitrate переместит исходный вариант
	// в неправильную позицию.
	{
		return (оВариант2.сИдентификатор === 'chunked' ? 1000000000 : оВариант2.nPeakBitrate)
		     - (оВариант1.сИдентификатор === 'chunked' ? 1000000000 : оВариант1.nPeakBitrate);
	}

	function РазобратьСписокАтрибутов(сИсходныйТекст)
	{
		Проверить(сИсходныйТекст);
		const амАтрибуты = new Map();
		const рвАтрибут = /([A-Z0-9\-]+)=("[^"]+"|[^",][^,]*)(?:,|$)/g;
		while (рвАтрибут.lastIndex !== сИсходныйТекст.length)
		{
			const чКонецАтрибута = рвАтрибут.lastIndex;
			const мсАтрибут = рвАтрибут.exec(сИсходныйТекст);
			Проверить(мсАтрибут.index === чКонецАтрибута);
			Проверить(!амАтрибуты.has(мсАтрибут[1]));
			амАтрибуты.set(мсАтрибут[1], мсАтрибут[2]);
		}
		return амАтрибуты;
	}

	function ParseDecimalInteger(сИсходныйТекст)
	{
		Проверить(/^[0-9]{1,15}$/.test(сИсходныйТекст));
		return Number.parseInt(сИсходныйТекст, 10);
	}

	function ParseFloatingPointOrDecimalInteger(сИсходныйТекст)
	{
		// Нам нужны минимум 3 цифры после запятой.
		Проверить(/^[0-9]{1,14}(?:\.[0-9]{1,15})?$/.test(сИсходныйТекст));
		return Number.parseFloat(сИсходныйТекст);
	}

	function ParseQuotedString(сИсходныйТекст)
	{
		Проверить(сИсходныйТекст.length > 2 && сИсходныйТекст.charAt(0) === '"' && сИсходныйТекст.charAt(сИсходныйТекст.length - 1) === '"');
		return сИсходныйТекст.slice(1, -1);
	}

	function ParseDecimalResolution(сИсходныйТекст)
	{
		const чРазделитель = сИсходныйТекст.indexOf('x');
		Проверить(чРазделитель !== -1);
		return [ParseDecimalInteger(сИсходныйТекст.slice(0, чРазделитель)), ParseDecimalInteger(сИсходныйТекст.slice(чРазделитель + 1))];
	}

	function ParseExtinfTag(сИсходныйТекст)
	{
		// HACK Twitch: Непосредственно перед #EXT-X-ENDLIST встречается сегмент с небольшой отрицательной длительностью.
		if (сИсходныйТекст.charAt(0) === '-')
		{
			throw 'Отрицательный #EXTINF';
		}
		const чЗапятая = сИсходныйТекст.indexOf(',');
		return ParseFloatingPointOrDecimalInteger(чЗапятая === -1 ? сИсходныйТекст : сИсходныйТекст.slice(0, чЗапятая));
	}

	function ДобавитьСегментыВОчередь(оНовыйСписок)
	// Добавляет в очередь сегменты из оНовыйСписок.
	// Если нужно, добавляет в очередь СОСТОЯНИЕ_НАЧАЛО_ТРАНСЛЯЦИИ.
	// Возвращает количество добавленных в очередь сегментов.
	// Изменяет _чСостояние, _оПоследнийСписок.
	{
		const чНачалоНовогоСписка = оНовыйСписок.nMediaSequenceNumber;
		const чКонецНовогоСписка = чНачалоНовогоСписка + оНовыйСписок.моСегменты.length;
		let чНачалоПоследнегоСписка, чКонецПоследнегоСписка, чИндекс;
		if (_оПоследнийСписок === null)
		{
			// После окончания трансляции список может быть доступен довольно долго.
			if (оНовыйСписок.лКонецСписка)
			{
				throw 'Найден #EXT-X-ENDLIST';
			}

			// Twitch: Возможен пустой список с #EXT-X-ENDLIST и #EXT-X-MEDIA-SEQUENCE: 0.
			Проверить(оНовыйСписок.моСегменты.length !== 0);

			// Следующий добавляемый в очередь сегмент должен быть разорван.
			ДобавитьСегментыВОчередь.лРазрыв = true;
			чНачалоПоследнегоСписка = чКонецПоследнегоСписка = -1;

			чИндекс = оНовыйСписок.моСегменты.length;
			for (let чРазмерБуфера = м_Настройки.Получить('чРазмерБуфера'); --чИндекс > 0 && (чРазмерБуфера -= оНовыйСписок.моСегменты[чИндекс].чДлительность) > 0;) {}
		}
		else
		{
			Проверить(оНовыйСписок.моСегменты.length !== 0);

			чНачалоПоследнегоСписка = _оПоследнийСписок.nMediaSequenceNumber;
			чКонецПоследнегоСписка = чНачалоПоследнегоСписка + _оПоследнийСписок.моСегменты.length;
			чИндекс = 0;

			// Twitch, ТВЦ: Нам ошибочно прислали старый список.
			if (чНачалоНовогоСписка < чНачалоПоследнегоСписка
			// Twitch: Количество сегментов в списке ошибочно уменьшено с 15 до 14. #EXT-X-MEDIA-SEQUENCE не изменился.
			|| чКонецНовогоСписка < чКонецПоследнегоСписка)
			{
				м_Журнал.Ой(`[Список] Уменьшился media sequence number`
					+ ` [${чНачалоПоследнегоСписка}..${чКонецПоследнегоСписка}) ==> [${чНачалоНовогоСписка}..${чКонецНовогоСписка})`);
			}
			
			// Firefox 43: Из-за нехватки памяти в системе, загрузка списка может задержаться на несколько десятков секунд.
			const кСегментовПропущено = чНачалоНовогоСписка - чКонецПоследнегоСписка;
			if (кСегментовПропущено > 0)
			{
				м_Журнал.Ой(`[Список] Пропущено сегментов: ${кСегментовПропущено}`);
				м_Статистика.НеЗагруженыСегменты(кСегментовПропущено);
				ДобавитьСегментыВОчередь.лРазрыв = true;
			}

			if (оНовыйСписок.nTargetDuration !== _оПоследнийСписок.nTargetDuration)
			{
				м_Журнал.Ой(`[Список] Изменился target duration ${_оПоследнийСписок.nTargetDuration} ==> ${оНовыйСписок.nTargetDuration}`);
				СброситьИнтервалОбновленияСписков();
			}
		}

		let кСегментовДобавлено = 0;
		let кСекундДобавлено = 0; // Статистика.
		for (let оДобавляемыйСегмент; оДобавляемыйСегмент = оНовыйСписок.моСегменты[чИндекс]; ++чИндекс)
		{
			const чНомерДобавляемогоСегмента = чНачалоНовогоСписка + чИндекс;

			if (чНомерДобавляемогоСегмента >= чНачалоПоследнегоСписка && чНомерДобавляемогоСегмента < чКонецПоследнегоСписка)
			{
				const оСегмент = _оПоследнийСписок.моСегменты[чНомерДобавляемогоСегмента - чНачалоПоследнегоСписка];
				// Twitch: #EXT-X-MEDIA-SEQUENCE ошибочно на 1 меньше после начала трансляции.
				if (оСегмент.сАдрес !== оДобавляемыйСегмент.сАдрес || оСегмент.чДлительность !== оДобавляемыйСегмент.чДлительность)
				{
					м_Журнал.Ой(`[Список] У сегмента ${чНомерДобавляемогоСегмента} изменились адрес ${оСегмент.сАдрес} ==> ${оДобавляемыйСегмент.сАдрес}`
						+ ` или длительность ${оСегмент.чДлительность} ==> ${оДобавляемыйСегмент.чДлительность}`);
					ДобавитьСегментыВОчередь.лРазрыв = true;
				}
			}

			if (чНомерДобавляемогоСегмента >= чКонецПоследнегоСписка)
			{
				if (_чСостояние !== СОСТОЯНИЕ_НАЧАЛО_ТРАНСЛЯЦИИ)
				{
					_чСостояние = СОСТОЯНИЕ_НАЧАЛО_ТРАНСЛЯЦИИ;
					г_моОчередь.Добавить(new Сегмент(ОБРАБОТКА_ЗАГРУЖЕН, СОСТОЯНИЕ_НАЧАЛО_ТРАНСЛЯЦИИ));
					СброситьИнтервалОбновленияСписков();
				}

				// Twitch: Такие сегменты скорее всего появляются из-за полной утери одной из дорожек.
				if (оДобавляемыйСегмент.чДлительность === 0)
				{
					м_Журнал.Ой(`[Список] Пропускаю сегмент MediaSequenceNumber=${чНомерДобавляемогоСегмента} Длительность=0`);
					м_Статистика.НеЗагруженыСегменты(1);
					ДобавитьСегментыВОчередь.лРазрыв = true;
				}
				else
				{
					const оДобавлено = г_моОчередь.Добавить(new Сегмент(ОБРАБОТКА_ЖДЕТ_ЗАГРУЗКИ, оДобавляемыйСегмент.сАдрес,
						оДобавляемыйСегмент.чДлительность, оДобавляемыйСегмент.лРазрыв || ДобавитьСегментыВОчередь.лРазрыв, оДобавляемыйСегмент.чTwitchПрошлоВремени));
					м_Журнал.Вот(`[Список] Добавлен сегмент ${оДобавлено.чНомер} MediaSequenceNumber=${чНомерДобавляемогоСегмента}`
						+ ` Длительность=${оДобавлено.чДлительность} Разрыв=${оДобавлено.лРазрыв} TwitchПрошлоВремени=${оДобавлено.чTwitchПрошлоВремени}`);
					кСегментовДобавлено += 1;
					кСекундДобавлено += оДобавлено.чДлительность;
					ДобавитьСегментыВОчередь.лРазрыв = false;
				}
			}
		}

		м_Статистика.ДобавленыСегментыВОчередь(кСегментовДобавлено, кСекундДобавлено);

		if (чКонецНовогоСписка >= чКонецПоследнегоСписка)
		{
			_оПоследнийСписок = оНовыйСписок;
		}

		if (оНовыйСписок.лКонецСписка)
		{
			throw 'Найден #EXT-X-ENDLIST';
		}

		return кСегментовДобавлено;
	}

	function ОбновитьСписки(чЧерез)
	{
		Проверить(Number.isFinite(чЧерез) && чЧерез >= 0);
		м_Журнал.Вот(`[Список] Загрузка списка начнется через ${м_Журнал.F0(чЧерез)}мс`);
		let оОбещание = Ждать(_ооОбновлениеСписков, чЧерез);
		if (!_моСписокВариантов)
		{
			let сАбсолютныйАдресСпискаВариантов;
			оОбещание = оОбещание.then(() =>
			{
				return м_Twitch.ПолучитьАбсолютныйАдресСпискаВариантов(_ооОбновлениеСписков);
			})
			.then(сРезультат =>
			{
				сАбсолютныйАдресСпискаВариантов = сРезультат;
				return м_Загрузчик.ЗагрузитьТекст(_ооОбновлениеСписков, сАбсолютныйАдресСпискаВариантов,
					ЗАГРУЖАТЬ_СПИСОК_ВАРИАНТОВ_НЕ_ДОЛЬШЕ, 'список вариантов', false);
			})
			.then(сРезультат =>
			{
				м_Отладка.СохранитьСписокВариантов(сРезультат);
				_моСписокВариантов = РазобратьСписок(true, сАбсолютныйАдресСпискаВариантов, сРезультат);
				ВыбратьВариантТрансляции();
			});
		}
		let чНачалоОпроса;
		оОбещание.then(() =>
		{
			чНачалоОпроса = performance.now();
			return м_Загрузчик.ЗагрузитьТекст(_ооОбновлениеСписков,
				_моСписокВариантов[_чВыбранныйВариант].сАбсолютныйАдресСпискаСегментов,
				ЗАГРУЖАТЬ_СПИСОК_СЕГМЕНТОВ_НЕ_ДОЛЬШЕ, 'список сегментов', false);
		})
		.then(сРезультат =>
		{
			м_Отладка.СохранитьСписокСегментов(сРезультат);
			const чИнтервал = ПолучитьИнтервалОбновленияСпискаСегментов( ДобавитьСегментыВОчередь( РазобратьСписок(
				false, _моСписокВариантов[_чВыбранныйВариант].сАбсолютныйАдресСпискаСегментов, сРезультат)));
			ОбновитьСписки(Math.max(чИнтервал - performance.now() + чНачалоОпроса, 0));
			м_Загрузчик.ЗагрузитьСледующийСегмент();
		})
		.catch(ДобавитьОбработчикИсключений(пПричина =>
		{
			// Завершение трансляции?
			if (typeof пПричина === 'string')
			{
				м_Журнал.Ой(`[Список] Завершаю трансляцию. ${пПричина}`);
				ЗавершитьТрансляцию();
				ОбновитьСписки(ПолучитьИнтервалОбновленияСпискаВариантов());
				м_Загрузчик.ЗагрузитьСледующийСегмент();
			}
			// Выполнение этой цепочки обещаний было прервано вызовом _ооОбновлениеСписков.Отменить()?
			// В этот момент уже может работать другая цепочка обещаний.
			else if (пПричина === ОтменаОбещания.ОБЕЩАНИЕ_ОТМЕНЕНО)
			{
				м_Журнал.Вот('[Список] Отменено обновление списков');
			}
			else
			{
				throw пПричина;
			}
		}));
	}

	function ОтменитьОбновлениеСписков()
	{
		м_Журнал.Вот('[Список] Отменяю обновление списков');
		_ооОбновлениеСписков.Отменить();
	}

	function СброситьИнтервалОбновленияСписков()
	{
		_мчДлительностьСегментов.fill(0);
		_чИнтервалОбновленияСписка = -1;
	}

	function ПолучитьИнтервалОбновленияСпискаСегментов(кСегментовДобавлено)
	{
		Проверить(_чСостояние === СОСТОЯНИЕ_НАЧАЛО_ТРАНСЛЯЦИИ);

		const чМинИнтервал = МИН_ИНТЕРВАЛ_ОБНОВЛЕНИЯ_СПИСКОВ * _оПоследнийСписок.nTargetDuration * 10;
		if (кСегментовДобавлено === 0)
		{
			return чМинИнтервал;
		}

		const чИнтервал = м_Настройки.Получить('чИнтервалОпроса');
		if (чИнтервал !== АВТОНАСТРОЙКА)
		{
			return чИнтервал * _оПоследнийСписок.nTargetDuration * 10;
		}

		Проверить(кСегментовДобавлено > 0 && кСегментовДобавлено <= _оПоследнийСписок.моСегменты.length);
		if (_чИнтервалОбновленияСписка === -1)
		{
			_чИнтервалОбновленияСписка = 0;
			// Ради этой строки _мчДлительностьСегментов[] заполняется без помощи ДобавитьСегментыВОчередь().
			кСегментовДобавлено = _оПоследнийСписок.моСегменты.length;
		}
		кСегментовДобавлено = Math.min(кСегментовДобавлено, _мчДлительностьСегментов.length);
		do
		{
			_мчДлительностьСегментов[_чИнтервалОбновленияСписка] = _оПоследнийСписок.моСегменты[_оПоследнийСписок.моСегменты.length - кСегментовДобавлено].чДлительность;
			if (++_чИнтервалОбновленияСписка === _мчДлительностьСегментов.length)
			{
				_чИнтервалОбновленияСписка = 0;
			}
		}
		while (--кСегментовДобавлено !== 0);
		return Math.max(Math.max(..._мчДлительностьСегментов) * 1000 + ДОБАВИТЬ_К_ИНТЕРВАЛУ_ОБНОВЛЕНИЯ_СПИСКА_СЕГМЕНТОВ, чМинИнтервал);
	}

	function ПолучитьИнтервалОбновленияСпискаВариантов()
	{
		Проверить(_чСостояние === СОСТОЯНИЕ_ЗАВЕРШЕНИЕ_ТРАНСЛЯЦИИ);
		if (_чИнтервалОбновленияСписка === -1)
		{
			_чИнтервалОбновленияСписка = ИНТЕРВАЛ_ОБНОВЛЕНИЯ_СПИСКА_ВАРИАНТОВ_НАЧАЛО;
		}
		else
		{
			_чИнтервалОбновленияСписка = Math.min(_чИнтервалОбновленияСписка + ИНТЕРВАЛ_ОБНОВЛЕНИЯ_СПИСКА_ВАРИАНТОВ_ШАГ, ИНТЕРВАЛ_ОБНОВЛЕНИЯ_СПИСКА_ВАРИАНТОВ_КОНЕЦ);
		}
		return _чИнтервалОбновленияСписка;
	}

	function ВыбратьВариантТрансляции()
	// Изменяет _чВыбранныйВариант.
	{
		if (_моСписокВариантов.length === 0)
		{
			throw 'Список вариантов пуст';
		}
		// Если сЖелаемыйВариант не будет найден в списке, то возьмем вариант с максимальным качеством из начала списка.
		const сЖелаемыйВариант = м_Настройки.Получить('сНазваниеВарианта');
		_чВыбранныйВариант = _моСписокВариантов.length - 1;
		while (_чВыбранныйВариант !== 0 && _моСписокВариантов[_чВыбранныйВариант].сИдентификатор !== сЖелаемыйВариант)
		{
			--_чВыбранныйВариант
		}
		м_Журнал.Вот(`[Список] Выбран вариант трансляции ${_моСписокВариантов[_чВыбранныйВариант].сИдентификатор} ЖелаемыйВариант=${сЖелаемыйВариант}`);
		м_События.ОбработатьСобытие('список-выбранварианттрансляции', [_моСписокВариантов, _чВыбранныйВариант]);
	}

	function ОчиститьСписокВариантовТрансляции()
	// Изменяет _моСписокВариантов.
	{
		if (_моСписокВариантов)
		{
			м_Журнал.Вот('[Список] Очищаю список вариантов трансляции');
			_моСписокВариантов = null;
			м_События.ОбработатьСобытие('список-выбранварианттрансляции', [_моСписокВариантов, _чВыбранныйВариант]);
		}
	}

	function ЗавершитьТрансляцию()
	// Если нужно, добавляет в очередь СОСТОЯНИЕ_ЗАВЕРШЕНИЕ_ТРАНСЛЯЦИИ.
	{
		// Если СОСТОЯНИЕ_ОСТАНОВКА, то сменить СОСТОЯНИЕ_ЗАГРУЗКА на СОСТОЯНИЕ_ЗАВЕРШЕНИЕ_ТРАНСЛЯЦИИ.
		if (_чСостояние !== СОСТОЯНИЕ_ЗАВЕРШЕНИЕ_ТРАНСЛЯЦИИ)
		{
			_чСостояние = СОСТОЯНИЕ_ЗАВЕРШЕНИЕ_ТРАНСЛЯЦИИ;
			г_моОчередь.Добавить(new Сегмент(ОБРАБОТКА_ЗАГРУЖЕН, СОСТОЯНИЕ_ЗАВЕРШЕНИЕ_ТРАНСЛЯЦИИ));
			СброситьИнтервалОбновленияСписков();
		}
		ОчиститьСписокВариантовТрансляции();
		_оПоследнийСписок = null;
	}

	function ИзменитьВариантТрансляции()
	// Добавляет в очередь СОСТОЯНИЕ_СМЕНА_ВАРИАНТА.
	// _чСостояние может быть любым, например если список вариантов уже загружен, а список сегментов - нет.
	{
		Проверить(_моСписокВариантов);
		ОтменитьОбновлениеСписков();
		СброситьИнтервалОбновленияСписков();
		ВыбратьВариантТрансляции();
		_оПоследнийСписок = null;
		_ооОбновлениеСписков.НачалоВыполнения();
		ОбновитьСписки(0);
		г_моОчередь.Добавить(new Сегмент(ОБРАБОТКА_ЗАГРУЖЕН, СОСТОЯНИЕ_СМЕНА_ВАРИАНТА));
		м_Загрузчик.ЗагрузитьСледующийСегмент();
	}


	function Остановить()
	// Не изменяет очередь.
	{
		_чСостояние = СОСТОЯНИЕ_ОСТАНОВКА;
		ОтменитьОбновлениеСписков();
		ОчиститьСписокВариантовТрансляции();
		_оПоследнийСписок = null;
	}

	function Запустить()
	{
		Проверить(_чСостояние === СОСТОЯНИЕ_ОСТАНОВКА);
		_ооОбновлениеСписков.НачалоВыполнения();
		ОбновитьСписки(0);
	}

	СброситьИнтервалОбновленияСписков();

	return {
		Запустить, Остановить,
		ИзменитьВариантТрансляции
	};
})();

const м_Преобразователь = (() =>
{
	let _оРабочийПоток = null;
	let _чПоследнийЗагруженный = -1;

	function ПреобразоватьСледующийСегмент()
	// СОСТОЯНИЕ_НАЧАЛО_ТРАНСЛЯЦИИ:
	//   Создает рабочий поток пока сегменты закачиваются.
	//   Отсылается в рабочий поток чтобы не изменилась его позиция в очереди.
	// СОСТОЯНИЕ_ЗАВЕРШЕНИЕ_ТРАНСЛЯЦИИ:
	//   Выталкивает из рабочего потока застрявшие там сегменты.
	//   TODO Когда все сегменты будут вытолкнуты, убить рабочий поток.
	{
		let кУдалить = 0, чУдалить;
		// Нельзя преобразовывать сегменты в произвольном порядке.
		for (let чСегмент = 0, оСегмент; оСегмент = г_моОчередь[чСегмент]; ++чСегмент)
		{
			if (оСегмент.чОбработка > ОБРАБОТКА_ЗАГРУЖЕН)
			{
				continue;
			}
			if (оСегмент.чОбработка < ОБРАБОТКА_ЗАГРУЖЕН)
			{
				break;
			}


			if (_чПоследнийЗагруженный !== -1 && _чПоследнийЗагруженный + 1 !== оСегмент.чНомер)
			{
				м_Журнал.Ой(`[Преобразование] Не загружены сегменты между ${_чПоследнийЗагруженный} и ${оСегмент.чНомер}`);
				оСегмент.лРазрыв = true;
			}
			_чПоследнийЗагруженный = оСегмент.чНомер;

			if (typeof оСегмент.пДанные === 'number' && _оРабочийПоток === null)
			{
				м_Журнал.Вот(`[Преобразование] Пропускаю сегмент ${оСегмент.чНомер} Состояние=${оСегмент.пДанные}`);
				оСегмент.чОбработка = ОБРАБОТКА_ПРЕОБРАЗОВАН;
				// Создать заранее пока загружаются сегменты.
				if (оСегмент.пДанные === СОСТОЯНИЕ_НАЧАЛО_ТРАНСЛЯЦИИ)
				{
					СоздатьРабочийПоток();
				}
				continue;
			}

			if (typeof оСегмент.пДанные !== 'number')
			{
				м_Отладка.СохранитьТранспортныйПоток(оСегмент);
				м_Статистика.ОтосланИсходныйСегмент();
			}

			м_Журнал.Вот(`[Преобразование] Отсылаю сегмент ${оСегмент.чНомер}`);
			оСегмент.сВерсия = ВЕРСИЯ_РАСШИРЕНИЯ;
			_оРабочийПоток.postMessage(оСегмент, typeof оСегмент.пДанные === 'number' ? undefined : [оСегмент.пДанные]);

			if (++кУдалить === 1)
			{
				чУдалить = чСегмент;
			}
		}
		
		if (кУдалить !== 0)
		{
			г_моОчередь.Удалить(чУдалить, кУдалить);
		}

		м_Проигрыватель.ДобавитьСледующийСегмент();
	}

	const ОбработатьОкончаниеПреобразования = ДобавитьОбработчикИсключений(оСобытие =>
	{
		const мДанные = оСобытие.data;
		Проверить(Array.isArray(мДанные));
		switch (мДанные[0])
		{
		case 1:
			Проверить(мДанные.length === 2 && ЭтоОбъект(мДанные[1]));
			const оСегмент = new Сегмент(ОБРАБОТКА_ПРЕОБРАЗОВАН, мДанные[1].пДанные, мДанные[1].чДлительность, мДанные[1].лРазрыв, мДанные[1].чTwitchПрошлоВремени, мДанные[1].чНомер);
			м_Журнал.Вот(`[Преобразование] Получен сегмент ${оСегмент.чНомер} ПреобразованЗа=${м_Журнал.F0(оСегмент.пДанные.чПреобразованЗа)}мс`);
			if (typeof оСегмент.пДанные !== 'number')
			{
				м_Статистика.ПолученПреобразованныйСегмент(оСегмент);
				// Если исходный сегмент не был преобразован или преобразованный медиасегмент был
				// задержан в рабочем потоке, то приходит только статистика без медиасегмента.
				if (typeof оСегмент.пДанные.мбМедиасегмент === 'undefined')
				{
					return;
				}
				м_Отладка.СохранитьПреобразованныйСегмент(оСегмент);
			}
			г_моОчередь.Добавить(оСегмент);
			м_Проигрыватель.ДобавитьСледующийСегмент();
			return;

		case 2:
			const мсВажность = мДанные[1], мсЗаписи = мДанные[2];
			Проверить(мДанные.length === 3 && Array.isArray(мсВажность) && Array.isArray(мсЗаписи) && мсВажность.length === мсЗаписи.length);
			for (let ы = 0; ы < мсВажность.length; ++ы)
			{
				Проверить((мсВажность[ы] === 'Вот' || мсВажность[ы] === 'Окак' || мсВажность[ы] === 'Ой') && typeof мсЗаписи[ы] === 'string');
				м_Журнал[мсВажность[ы]](мсЗаписи[ы]);
			}
			return;

		case 3:
			Проверить(мДанные.length === 3 && typeof мДанные[1] === 'string' && typeof мДанные[2] === 'object');
			м_Отладка.ЗавершитьРаботуИОтправитьОтчет(мДанные[1], мДанные[2]);
			return;

		case 4:
			Проверить(мДанные.length === 2 && typeof мДанные[1] === 'string');
			м_Отладка.ЗавершитьРаботуИПоказатьСообщение(мДанные[1]);
			return;

		case 5:
			Проверить(мДанные.length === 2 && мДанные[1].byteLength);
			м_Помойка.Выбросить(мДанные[1]);
			return;

		default:
			Проверить(false);
		}
	});

	function ОбработатьОшибкуПреобразования(оСобытие)
	{
		м_Отладка.ЗавершитьРаботуИОтправитьОтчет(`Произошло событие ${оСобытие.type} в рабочем потоке в строке ${оСобытие.lineno}. ${оСобытие.message}`);
	}

	function СоздатьРабочийПоток()
	// Версии player.js и worker.js должны совпадать. Во время обновления расширения этим занимается браузер.
	{
		if (!_оРабочийПоток)
		{
			м_Журнал.Вот('[Преобразование] Создаю рабочий поток');
			_оРабочийПоток = new Worker(chrome.extension.getURL('worker_pre.js'));
			_оРабочийПоток.addEventListener('message', ОбработатьОкончаниеПреобразования);
			_оРабочийПоток.addEventListener('error', ОбработатьОшибкуПреобразования);
			_оРабочийПоток.addEventListener('messageerror', ОбработатьОшибкуПреобразования);
		}
	}

	function Остановить()
	// Не изменяет очередь.
	{
		_чПоследнийЗагруженный = -1;
		if (_оРабочийПоток)
		{
			м_Журнал.Вот('[Преобразование] Убиваю рабочий поток');
			_оРабочийПоток.terminate();
			_оРабочийПоток = null;
		}
	}

	return {
		Остановить,
		ПреобразоватьСледующийСегмент
	};
})();

const м_Загрузчик = (() =>
{
	function ЗагрузитьТекст(ооОтменаОбещания, сАдрес, чНеДольше, сНазвание, лЖурнал, оЗаголовки = null, сМетод = 'GET')
	{
		return Загрузить(ооОтменаОбещания, сМетод, сАдрес, чНеДольше, оЗаголовки, сНазвание, лЖурнал, 'text');
	}

	function ЗагрузитьJson(ооОтменаОбещания, сАдрес, чНеДольше, сНазвание, лЖурнал, оЗаголовки = null, сМетод = 'GET')
	{
		return Загрузить(ооОтменаОбещания, сМетод, сАдрес, чНеДольше, оЗаголовки, сНазвание, лЖурнал, 'json');
	}

	function Загрузить(ооОтменаОбещания, сМетод, сАдрес, чНеДольше, оЗаголовки, сНазвание, лЖурнал, пТипДанных)
	// пТипДанных:
	//   'text' - текст. Возвращает строку, возможно пустую.
	//   'json' - JSON. Возвращает результат JSON.parse(). Отсутствие тела ответа считается ошибкой.
	//   число  - длительность загружаемого сегмента в секундах. Возвращает ArrayBuffer.
	// Если лЖурнал == true:
	//   Для текста - добавлять загруженный текст в м_Журнал.
	//   Для двоичных данных - рассчитывать _чОжиданиеОтвета.
	// TODO Firefox 46, Chrome 48, Edge 15 (выход из спячки): Иногда запрос не завершается, не посылая никаких событий.
	{
		Проверить(сМетод === 'GET' || сМетод === 'PUT' || сМетод === 'DELETE');
		Проверить(typeof сАдрес === 'string' && (сАдрес.startsWith('http://') || сАдрес.startsWith('https://') || (чНеДольше === 0 && сАдрес.startsWith(chrome.extension.getURL('')))));
		Проверить(Number.isFinite(чНеДольше) && (чНеДольше === 0 || чНеДольше > 1000));
		Проверить(typeof оЗаголовки === 'object' && typeof сНазвание === 'string' && typeof лЖурнал === 'boolean');
		Проверить(пТипДанных === 'text' || пТипДанных === 'json' || Number.isFinite(пТипДанных));

		м_Журнал.Вот(`[Загрузчик] ${сМетод} ${сНазвание} не дольше ${м_Журнал.F0(чНеДольше)}мс`);

		const оЗапрос = new XMLHttpRequest();
		оЗапрос._сМетод = сМетод;
		оЗапрос._сАдрес = сАдрес;
		оЗапрос._чНеДольше = чНеДольше;
		оЗапрос._оЗаголовки = оЗаголовки;
		оЗапрос._сНазвание = сНазвание;
		оЗапрос._лЖурнал = лЖурнал;
		оЗапрос._пТипДанных = пТипДанных;
		// Если вечером изменять параметры подписки, то 503 возвращается довольно часто. Согласно документации
		// Twitch, при получении кода 503 нужно повторить запрос 1 раз. Повтор не помешает и в других случаях.
		оЗапрос._кОсталосьПопыток = typeof пТипДанных === 'number' ? 1 : 2;
		оЗапрос._чВремяОтправкиЗапроса = performance.now();
		оЗапрос._чОжиданиеОтвета = NaN;
		
		оЗапрос.addEventListener('timeout', ОбработатьОшибку);
		оЗапрос.addEventListener('error', ОбработатьОшибку);
		оЗапрос.addEventListener('abort', ОбработатьОшибку);
		оЗапрос.addEventListener('load', ОбработатьОкончаниеЗагрузки);
		if (лЖурнал && typeof пТипДанных === 'number')
		{
			оЗапрос.addEventListener('readystatechange', ОбработатьПолучениеОтвета);
		}

		return new Promise((фВыполнить, фОтказаться) =>
		{
			оЗапрос._фВыполнить = фВыполнить;
			оЗапрос._фОтказаться = фОтказаться;
			if (ооОтменаОбещания)
			{
				ооОтменаОбещания.ЗаменитьОбработчик(ПолучитьОбработчикОтменыОбещания(оЗапрос));
			}
			ПослатьЗапрос(оЗапрос, false);
		});
	}

	function ПослатьЗапрос(оЗапрос, лПовторно)
	{
		if (оЗапрос._кОсталосьПопыток === 0)
		{
			return false;
		}
		if (лПовторно)
		{
			м_Журнал.Ой(`[Загрузчик] Повторно загружаю ${оЗапрос._сНазвание}`);
		}
		оЗапрос._кОсталосьПопыток -= 1;
		оЗапрос.open(оЗапрос._сМетод, оЗапрос._сАдрес);
		// text вместо json, потому что хочется в журнале видеть, что за фигню прислал сервер.
		оЗапрос.responseType = typeof оЗапрос._пТипДанных === 'number' ? 'arraybuffer' : 'text';
		оЗапрос.timeout = оЗапрос._чНеДольше;
		if (оЗапрос._оЗаголовки)
		{
			for (let сЗаголовок of Object.keys(оЗапрос._оЗаголовки))
			{
				оЗапрос.setRequestHeader(сЗаголовок, оЗапрос._оЗаголовки[сЗаголовок]);
			}
		}
		оЗапрос.send();
		return true;
	}

	function ПолучитьОбработчикОтменыОбещания(оЗапрос)
	{
		return () =>
		{
			м_Журнал.Вот(`[Загрузчик] Отменяю загрузку ${оЗапрос._сНазвание} readyState=${оЗапрос.readyState}`);
			оЗапрос.removeEventListener('abort', ОбработатьОшибку);
			// Меняет readyState на DONE.
			// Синхронно вызывает обработчики событий readystatechange и abort.
			// Меняет readyState на UNSENT.
			оЗапрос.abort();
			оЗапрос._фОтказаться(ОтменаОбещания.ОБЕЩАНИЕ_ОТМЕНЕНО);
		};
	}


	const ОбработатьПолучениеОтвета = ДобавитьОбработчикИсключений(({target: оЗапрос}) =>
	// Событие progress посылается примерно каждые 50 мс, readystatechange посылается намного чаще.
	// Firefox 51-: Первое событие progress посылается примерно через 50 мс после получения заголовков.
	// Edge 15: Последнее событие progress может быть послано по окончании загрузки ПРЕДпоследнего блока.
	{
		if (оЗапрос.readyState >= XMLHttpRequest.HEADERS_RECEIVED)
		{
			оЗапрос.removeEventListener('readystatechange', ОбработатьПолучениеОтвета);
			Проверить(Number.isNaN(оЗапрос._чОжиданиеОтвета));
			оЗапрос._чОжиданиеОтвета = Math.round(performance.now() - оЗапрос._чВремяОтправкиЗапроса);
		}
	});

	const ОбработатьОшибку = ДобавитьОбработчикИсключений(({target: оЗапрос, type: сТипСобытия}) =>
	{

		м_Журнал.Ой(`[Загрузчик] Не удалось загрузить ${оЗапрос._сНазвание}. Произошло событие ${сТипСобытия}`
			+ ` readyState=${оЗапрос.readyState}`
			+ (оЗапрос._лЖурнал && typeof оЗапрос._пТипДанных === 'number' ? ` ОжиданиеОтвета=${оЗапрос._чОжиданиеОтвета}мс` : ``)
		);

		// Во всех браузерах window.stop() вызвает abort().
		// Chrome 49 вызывает abort() во время выгрузки страницы, засыпания компа и еще непонятно когда.
		// Firefox раньше сам вызывал abort(). Возможно, продолжит это в будущем, беря пример с Chrome.
		if (сТипСобытия === 'abort' || !ПослатьЗапрос(оЗапрос, true))
		{
			if (оЗапрос.responseType === 'arraybuffer')
			{
				м_Статистика.ЗагруженСегмент(NaN, NaN, NaN, оЗапрос._чОжиданиеОтвета);
			}
			оЗапрос._фОтказаться(`Произошло событие ${сТипСобытия}`);
		}
	});

	const ОбработатьОкончаниеЗагрузки = ДобавитьОбработчикИсключений(({target: оЗапрос}) =>
	{
		Проверить(оЗапрос.readyState === XMLHttpRequest.DONE);


		const чКод = оЗапрос.status;
		// Возможно сочетание: responseType == arraybuffer, код == 200..299, response == null. report://03794749782803_15084697088
		if (чКод >= 200 && чКод <= 299 && оЗапрос.response !== null)
		{
			const чДлительностьЗагрузки = Math.round(performance.now() - оЗапрос._чВремяОтправкиЗапроса);

			м_Журнал[чКод === 200 ? 'Вот' : 'Ой'](
				`[Загрузчик] Загрузил ${оЗапрос._сНазвание} за ${чДлительностьЗагрузки}мс`
				+ (оЗапрос._лЖурнал && typeof оЗапрос._пТипДанных === 'number' ? ` ОжиданиеОтвета=${оЗапрос._чОжиданиеОтвета}мс` : ``)
				+ (typeof оЗапрос._пТипДанных === 'number' ? ` Соотношение=${м_Журнал.F1(чДлительностьЗагрузки / оЗапрос._пТипДанных / 1000)}` : ``)
				+ (чКод === 200 ? `` : ` Код=${чКод} ${оЗапрос.statusText}`)
				+ (оЗапрос._лЖурнал && ЭтоНепустаяСтрока(оЗапрос.response) ? `\n${оЗапрос.response}`
				: ` Размер=${оЗапрос.responseType === 'arraybuffer' ? оЗапрос.response.byteLength : оЗапрос.response.length}`)
			);

			// Файл загружен не с диска?
			if (оЗапрос._чНеДольше !== 0)
			{
				м_Статистика.СкачаноНечто(ПолучитьРазмерОтвета(оЗапрос));
			}

			if (оЗапрос.responseType === 'arraybuffer')
			{
				м_Статистика.ЗагруженСегмент(оЗапрос.response.byteLength, оЗапрос._пТипДанных, чДлительностьЗагрузки, оЗапрос._чОжиданиеОтвета);
				оЗапрос._фВыполнить(оЗапрос.response);
			}
			else if (оЗапрос._пТипДанных === 'json')
			{
				try
				{
					оЗапрос._фВыполнить(JSON.parse(оЗапрос.response));
				}
				catch (пИсключение)
				{
					// Не вызывать ПослатьЗапрос().
					м_Журнал.Ой(`[Загрузчик] Не удалось разобрать ${оЗапрос._сНазвание}. ${пИсключение}`);
					оЗапрос._фОтказаться('Не удалось разобрать JSON');
				}
			}
			else
			{
				оЗапрос._фВыполнить(оЗапрос.response);
			}
		}
		else
		{
			м_Журнал.Ой(`[Загрузчик] Не удалось загрузить ${оЗапрос._сНазвание}. ${КОД_ОТВЕТА + чКод} ${оЗапрос.statusText}`
				+ (оЗапрос._лЖурнал && typeof оЗапрос._пТипДанных === 'number' ? ` ОжиданиеОтвета=${оЗапрос._чОжиданиеОтвета}мс` : ``)
				+ (ЭтоНепустаяСтрока(оЗапрос.response) ? `\n${оЗапрос.response}`
				: ` Размер=${оЗапрос.responseType === 'arraybuffer' ? оЗапрос.response.byteLength : оЗапрос.response.length}`)
			);

			// Встречается код 302, видимо без заголовка запроса location. report://02880986452199_15106536708
			if ((чКод >= 400 && чКод <= 499) || оЗапрос.response === null || !ПослатьЗапрос(оЗапрос, true))
			{
				if (оЗапрос.responseType === 'arraybuffer')
				{
					м_Статистика.ЗагруженСегмент(NaN, NaN, NaN, оЗапрос._чОжиданиеОтвета);
				}
				оЗапрос._фОтказаться(КОД_ОТВЕТА + чКод);
			}
		}
	});

	function ПолучитьРазмерОтвета(оЗапрос)
	// TODO Twitch: Часть запросов к API может кэшироваться.
	{
		let кбРазмерЗаголовков = 17 + оЗапрос.statusText.length + оЗапрос.getAllResponseHeaders().length;
		// HTTP/2 сжимает заголовки. Итоговый размер равен ≈ 0,2..0,7 и зависит от
		// содержимого заголовков и количества запросов в соединении.
		if (ЭтоHTTP2(оЗапрос))
		{
			кбРазмерЗаголовков = Math.round(кбРазмерЗаголовков * 0.5);
		}
		
		let кбРазмерТела;
		// Нам нужен размер сжатых данных. Событие progress дает размер разжатых данных.
		// Content-Length отсутствует если используется Transfer-Encoding: chunked.
		// Content-Length не обязателен для протокола HTTP/2.
		let сЗаголовок = оЗапрос.getResponseHeader('Content-Length');
		if (сЗаголовок)
		{
			кбРазмерТела = Number.parseInt(сЗаголовок, 10);
		}
		else if (оЗапрос.responseType === 'arraybuffer')
		{
			кбРазмерТела = оЗапрос.response.byteLength;
			// TODO Расширение пока не скачивает сжатые двоичные файлы.
		}
		else
		{
			// TODO Размер в байтах исходного текста в кодировке UTF-8 может быть больше.
			// Twitch: Таких файлов очень мало.
			кбРазмерТела = оЗапрос.response.length;
			сЗаголовок = оЗапрос.getResponseHeader('Content-Encoding');
			if (сЗаголовок && сЗаголовок !== 'identity')
			{
				кбРазмерТела = Math.round(кбРазмерТела * 0.35);
			}
		}
		
		return кбРазмерЗаголовков + кбРазмерТела;
	}

	function ЭтоHTTP2(оЗапрос)
	// HACK Нет стандартного способа для определения версии протокола HTTP.
	{
		return оЗапрос.statusText.length === 0;
	}

	function ЗагрузитьСледующийСегмент()
	// Начинает загрузку незагруженных сегментов и отправляет на преобразование загруженные.
	// Сегменты могут загружаться в произвольном порядке, преобразовываться - только по порядку.
	{
		// Для упрощения алгоритма, СОСТОЯНИЕ_СМЕНА_ВАРИАНТА должен быть последним в очереди.
		let ч = г_моОчередь.length - 1;
		if (ч >= 0 && г_моОчередь[ч].пДанные === СОСТОЯНИЕ_СМЕНА_ВАРИАНТА && г_моОчередь[ч].чОбработка === ОБРАБОТКА_ЗАГРУЖЕН)
		{
			г_моОчередь.ПоказатьСостояние();
			while (--ч >= 0 && г_моОчередь[ч].чОбработка <= ОБРАБОТКА_ЗАГРУЖЕН)
			{
				if (typeof г_моОчередь[ч].пДанные !== 'number')
				{
					г_моОчередь.Удалить(ч);
				}
			}
			г_моОчередь.ПоказатьСостояние();
		}
		else
		{
			let кОдновременныхЗагрузок = м_Настройки.Получить('кОдновременныхЗагрузок');
			let чДлительностьВсехЗагрузок = 0;
			for (let оСегмент of г_моОчередь)
			{
				// Загруженные сегменты могут застрять в очереди если из-за ошибки браузера завис XHR
				// и в настройках проигрывателя включена одновременная загрузка нескольких сегментов.
				if (оСегмент.чОбработка <= ОБРАБОТКА_ЗАГРУЖЕН)
				{
					чДлительностьВсехЗагрузок += оСегмент.чДлительность;
					if (оСегмент.чОбработка <= ОБРАБОТКА_ЗАГРУЖАЕТСЯ)
					{
						--кОдновременныхЗагрузок;
						if (оСегмент.чОбработка === ОБРАБОТКА_ЖДЕТ_ЗАГРУЗКИ && кОдновременныхЗагрузок >= 0)
						{
							ЗагрузитьСегмент(оСегмент);
						}
					}
				}
			}

			// TODO Можно заменить ПЕРЕПОЛНЕНИЕ_БУФЕРА на:
			// а) Текущий размер буфера + МАКС_РАСТЯГИВАНИЕ_БУФЕРА
			// б) Длительность списка воспроизведения * 2
			// Значение должно быть заметно больше, чем чЗагружатьНеДольше в ЗагрузитьСегмент(), чтобы не путать ошибку загрузки с переполнением очереди.
			if (чДлительностьВсехЗагрузок >= ПЕРЕПОЛНЕНИЕ_БУФЕРА)
			{
				м_Журнал.Ой(`[Загрузчик] Длительность всех загрузок в очереди ${м_Журнал.F1(чДлительностьВсехЗагрузок)}с >= ${ПЕРЕПОЛНЕНИЕ_БУФЕРА}с`);
				ОбработатьНеудачнуюЗагрузкуСегмента(null);
				ЗагрузитьСледующийСегмент();
				return;
			}
		}

		м_Преобразователь.ПреобразоватьСледующийСегмент();
	}

	function ЗагрузитьСегмент(оСегмент)
	{
		const чЗагружатьНеДольше = 5000                                               // Ожидание ответа.
			+ оСегмент.чДлительность * м_Настройки.Получить('кОдновременныхЗагрузок') // Если толщина сегмента и толщина канала совпадают.
			* 2                                                                       // Проблемы со связью.
			* 1000;                                                                   // Перевод в миллисекунды.
		// См. проверку на переполнение очереди в ЗагрузитьСледующийСегмент().
		Проверить(чЗагружатьНеДольше < ПЕРЕПОЛНЕНИЕ_БУФЕРА * 1000);
		const сАдрес = оСегмент.пДанные;
		оСегмент.пДанные = new ОтменаОбещания();
		оСегмент.пДанные.НачалоВыполнения();
		оСегмент.чОбработка = ОБРАБОТКА_ЗАГРУЖАЕТСЯ;
		Загрузить(оСегмент.пДанные, 'GET', сАдрес, чЗагружатьНеДольше, null, `сегмент ${оСегмент.чНомер}`, м_Статистика.ОкноПоказано(), оСегмент.чДлительность)
		.then(буфДанные =>
		{
			Проверить(г_моОчередь.includes(оСегмент));
			оСегмент.пДанные = буфДанные;
			оСегмент.чОбработка = ОБРАБОТКА_ЗАГРУЖЕН;
			ЗагрузитьСледующийСегмент();
		})
		.catch(ДобавитьОбработчикИсключений(пПричина =>
		{
			// Firefox: Во время отправки загруженного сегмента на преобразование может кинуть строковое исключение 'out of memory'.
			if (typeof пПричина === 'string' && оСегмент.чОбработка === ОБРАБОТКА_ЗАГРУЖАЕТСЯ)
			{
				Проверить(г_моОчередь.includes(оСегмент));
				// Загрузить() уже добавила подробное сообщение об ошибке.
				// На всякий случай вызываем XMLHttpRequest.abort(). Для этого не обнуляем оСегмент.пДанные.
				ОбработатьНеудачнуюЗагрузкуСегмента(пПричина.сПричина === (КОД_ОТВЕТА + 404) || пПричина.сПричина === (КОД_ОТВЕТА + 410) ? null : оСегмент);
				Проверить(!г_моОчередь.includes(оСегмент));
				ЗагрузитьСледующийСегмент();
			}
			else if (пПричина === ОтменаОбещания.ОБЕЩАНИЕ_ОТМЕНЕНО)
			{
				м_Журнал.Вот(`[Загрузчик] Отменена загрузка сегмента ${оСегмент.чНомер}`);
				Проверить(!г_моОчередь.includes(оСегмент));
			}
			else
			{
				throw пПричина;
			}
		}));
	}

	function ОбработатьНеудачнуюЗагрузкуСегмента(оНезагруженныйСегмент)
	// оНезагруженныйСегмент - сегмент, во время загрузки которого произошла ошибка.
	// оНезагруженныйСегмент == null - произошло переполнение очереди.
	{
		г_моОчередь.ПоказатьСостояние();
		const кВОчереди = г_моОчередь.length;
		if (оНезагруженныйСегмент)
		{
			г_моОчередь.Удалить(оНезагруженныйСегмент);
		}
		else
		{
			let чРазмерБуфера = м_Настройки.Получить('чРазмерБуфера');
			for (let ы = кВОчереди, оСегмент; оСегмент = г_моОчередь[--ы];)
			{
				if (оСегмент.чОбработка === ОБРАБОТКА_ЖДЕТ_ЗАГРУЗКИ)
				{
					if (чРазмерБуфера > 0)
					{
						чРазмерБуфера -= оСегмент.чДлительность;
					}
					else
					{
						г_моОчередь.Удалить(ы);
					}
				}
				else if (оСегмент.чОбработка === ОБРАБОТКА_ЗАГРУЖАЕТСЯ)
				{
					г_моОчередь.Удалить(ы);
				}
			}
		}
		г_моОчередь.ПоказатьСостояние();
		м_Статистика.НеЗагруженыСегменты(кВОчереди - г_моОчередь.length);
	}


	return {
		ЗагрузитьТекст,
		ЗагрузитьJson,
		ЗагрузитьСледующийСегмент
	};
})();

let м_Twitch = null;

function Twitch(_сКодКанала)
{
	const ИНТЕРВАЛ_ОБНОВЛЕНИЯ_МЕТАДАННЫХ_ТРАНСЛЯЦИИ = 60000; // Миллисекунды.
	const ЗАДЕРЖКА_ОБНОВЛЕНИЯ_МЕТАДАННЫХ_ЗАПИСИ = 4 * 60000; // Миллисекунды.
	const ИДЕНТИФИКАТОР_КЛИЕНТА = 'jzkbprff40iqj646a697cyrvl0zt2m6';

	const ЗАГОЛОВКИ_ЗАПРОСА =
	{
		'Client-ID': ИДЕНТИФИКАТОР_КЛИЕНТА,
		'Accept': 'application/vnd.twitchtv.v5+json'
	};

	let _сИдКанала     = '';
	let _сИдТрансляции = '';
	let _сАдресЗаписи  = '';
	let _сИдЗрителя    = '';
	let _сТокенЗрителя = '';
	let _ооОбновлениеМетаданных = new ОтменаОбещания();

	function ОчиститьДанныеТрансляции()
	{
		_сИдТрансляции = _сАдресЗаписи = '';
	}

	function ПолучитьАдресКанала(лНеПеренаправлять)
	{
		// Twitch переводит код канала и параметры в нижний регистр.
		// См. АДРЕС_НЕ_ПЕРЕНАПРАВЛЯТЬ в content.js.
		return лНеПеренаправлять
			? `https://www.twitch.tv/${_сКодКанала}?twitch5=0`
			: `https://www.twitch.tv/${_сКодКанала}`;
	}

	function ПолучитьАдресПанелиЧата()
	{
		if (м_Настройки.Получить('лПолноценныйЧат'))
		{
			return `https://www.twitch.tv/popout/${_сКодКанала}/chat`
		}
		return м_Настройки.Получить('лЗатемнитьЧат')
			? `https://www.twitch.tv/embed/${_сКодКанала}/chat?darkpopout`
			: `https://www.twitch.tv/embed/${_сКодКанала}/chat`;
	}

	function ЭтоАдресПанелиЧата(сАдрес)
	{
		const мсРазбор = сАдрес.match(/^https:\/\/www.twitch.tv\/(?:popout|embed)\/([^/]+)\/chat(?:\?|$)/);
		return мсРазбор && мсРазбор[1] === _сКодКанала;
	}

	function ПолучитьАдресКаталогаИгры(сНазваниеИгры)
	{
		return 'https://www.twitch.tv/directory' + (сНазваниеИгры ? '/game/' + encodeURIComponent(сНазваниеИгры) : '');
	}

	function ИзменитьПодпискуЗрителяНаКанал(чПодписка)
	{
		Проверить(Number.isInteger(чПодписка));
		ПолучитьИлиИзменитьПодпискуЗрителяНаКанал(чПодписка);
	}

	function ПолучитьИлиИзменитьПодпискуЗрителяНаКанал(чПодписка)
	{
		Проверить(_сИдЗрителя && _сИдКанала && _сТокенЗрителя);
		if (_сИдЗрителя === _сИдКанала)
		{
			Проверить(чПодписка === undefined);
			м_События.ОбработатьСобытие('twitch-полученыметаданныезрителя', {чПодписка: ПОДПИСКА_НЕДОСТУПНА});
			return;
		}
		let сМетод, сПараметры;
		switch (чПодписка)
		{
			case undefined:             сМетод = 'GET';    сПараметры = ''; break;
			case ПОДПИСКА_НЕОФОРМЛЕНА:  сМетод = 'DELETE'; сПараметры = ''; break;
			case ПОДПИСКА_НЕУВЕДОМЛЯТЬ: сМетод = 'PUT';    сПараметры = '?notifications=false'; break;
			case ПОДПИСКА_УВЕДОМЛЯТЬ:   сМетод = 'PUT';    сПараметры = '?notifications=true';  break;
			default: Проверить(false);
		}
		// ЗагрузитьJson() считает ошибкой отсутствие тела ответа.
		м_Загрузчик.ЗагрузитьТекст(null,
			`https://api.twitch.tv/kraken/users/${_сИдЗрителя}/follows/channels/${_сИдКанала}${сПараметры}`,
			ЗАГРУЖАТЬ_МЕТАДАННЫЕ_НЕ_ДОЛЬШЕ, `подписка ${чПодписка}`, true,
			чПодписка === undefined ? ЗАГОЛОВКИ_ЗАПРОСА :
			{
				'Client-ID': ИДЕНТИФИКАТОР_КЛИЕНТА,
				'Accept': 'application/vnd.twitchtv.v5+json',
				'Authorization': `OAuth ${_сТокенЗрителя}`
			},
			сМетод
		)
		.then(сРезультат =>
		{
			// После DELETE код ответа 204.
			if (чПодписка === ПОДПИСКА_НЕОФОРМЛЕНА)
			{
				Проверить(сРезультат === '');
				м_События.ОбработатьСобытие('twitch-полученыметаданныезрителя', {чПодписка: ПОДПИСКА_НЕОФОРМЛЕНА});
				return;
			}
			let оРезультат;
			try
			{
				оРезультат = JSON.parse(сРезультат);
			}
			catch (пИсключение)
			{
				throw String(пИсключение);
			}
			Проверить(ЭтоНепустаяСтрока(оРезультат.created_at));
			Проверить(typeof оРезультат.notifications === 'boolean');
			// После смены уведомления, оРезультат.notifications иногда содержит предыдущее значение.
			// Это ошибка Twitch или сделано специально?
			м_События.ОбработатьСобытие('twitch-полученыметаданныезрителя',
			{
				чПодписка: чПодписка !== undefined ? чПодписка : оРезультат.notifications ? ПОДПИСКА_УВЕДОМЛЯТЬ : ПОДПИСКА_НЕУВЕДОМЛЯТЬ
			});
		})
		.catch(ДобавитьОбработчикИсключений(пПричина =>
		{
			// После GET код ответа 404 если зритель не подписан на канал.
			if (пПричина === (КОД_ОТВЕТА + 404))
			{
				Проверить(чПодписка === undefined);
				м_События.ОбработатьСобытие('twitch-полученыметаданныезрителя', {чПодписка: ПОДПИСКА_НЕОФОРМЛЕНА});
			}
			// TODO Обновить метаданные, если ошибка произошла из-за протухшего токена.
			else if (typeof пПричина === 'string')
			{
				м_Журнал.Ой(`[Twitch] Не удалось обновить подписку. ${пПричина}`);
				м_События.ОбработатьСобытие('twitch-полученыметаданныезрителя', {чПодписка: ПОДПИСКА_НЕДОСТУПНА});
			}
			// Отмены обещания в этой цепочке пока нет.
			else
			{
				throw пПричина;
			}
		}));
	}

	const ПолученИдКанала = ДобавитьОбработчикИсключений(() =>
	{
		ПолучитьМетаданныеКанала();
		ПолучитьМетаданныеЗрителя();
	});

	function ПолучитьАбсолютныйАдресСпискаВариантов(ооОтменаОбещания, bHttp = false)
	// Загрузка по http меньше нагружает центральный процессор, но имеет недостатки:
	// - Этот протокол проще блокировать (report://03705462433077_15281664376).
	// - Могут мешать другие расширения браузера (report://07273043908108_15276834036).
	{
		return м_Загрузчик.ЗагрузитьТекст(ооОтменаОбещания,
			// TODO Хорошо бы передавать в запросе _сИдКанала вместо _сКодКанала, но похоже API пока этого не позволяет.
			`https://api.twitch.tv/api/channels/${_сКодКанала}/access_token?adblock=false&need_https=${bHttp ? 'false' : 'true'}&platform=web&player_type=site`,
			ЗАГРУЖАТЬ_СПИСОК_ВАРИАНТОВ_НЕ_ДОЛЬШЕ, 'токен трансляции', true, {'Client-ID': ИДЕНТИФИКАТОР_КЛИЕНТА}
		)
		.then(
			сРезультат =>
			{
				// ЗагрузитьJson() не подходит, потому что если не удастся разобрать ответ, то хорошо бы послать отчет об ошибке.
				const оРезультат = JSON.parse(сРезультат);
				// Если в коде канала есть знак вопроса, то Twitch вместо токена возвращает какую-то фигню.
				if (ЭтоОбъект(оРезультат) && ЭтоНепустаяСтрока(оРезультат.token) && ЭтоНепустаяСтрока(оРезультат.sig))
				{
					const оТокен = JSON.parse(оРезультат.token);
					if (оТокен.channel === _сКодКанала)
					{
						if (_сИдКанала === '')
						{
							Проверить(оТокен.hasOwnProperty('channel_id'));
							// В access token это число. В helix и части kraken это строка. Второй вариант более логичный.
							_сИдКанала = String(оТокен.channel_id);
							// Сначала загружаем видео, которое важнее метаданных.
							setImmediate(ПолученИдКанала);
						}
						else
						{
							// TODO Теоретически проверка может сработать, если во время трансляции канал поменяет код, другой
							// канал возьмет себе старый код, и метаданные трансляции не успеют получить новый код?
							Проверить(_сИдКанала === String(оТокен.channel_id));
						}
						// Этот адрес есть в <head> файла player.html.
						return `${bHttp ? 'http' : 'https'}://usher.ttvnw.net/api/channel/hls/${_сКодКанала}.m3u8?allow_source=true&player_backend=mediaplayer&sig=${encodeURIComponent(оРезультат.sig)}&token=${encodeURIComponent(оРезультат.token)}`;
					}
				}
				м_Отладка.ЗавершитьРаботуИПоказатьСообщение('J0203');
			},
			пПричина =>
			{
				// Канала не существует || запрещенное название канала?
				if (пПричина === (КОД_ОТВЕТА + 404) || пПричина === (КОД_ОТВЕТА + 422))
				{
					м_Отладка.ЗавершитьРаботуИПоказатьСообщение('J0203');
				}
				else
				{
					throw пПричина;
				}
			}
		);
	}

	function ПолучитьМетаданныеКанала()
	{
		Проверить(_сИдКанала);
		м_Загрузчик.ЗагрузитьJson(null,
			`https://api.twitch.tv/kraken/channels/${_сИдКанала}`,
			ЗАГРУЖАТЬ_МЕТАДАННЫЕ_НЕ_ДОЛЬШЕ, 'метаданные канала', true, ЗАГОЛОВКИ_ЗАПРОСА
		)
		.then(оРезультат =>
		{
			const дКаналСоздан = new Date(оРезультат.created_at); // ISO 8601
			Проверить(
				оРезультат._id === _сИдКанала
				&& Number.isFinite(оРезультат.followers)
				&& Number.isFinite(оРезультат.views)
				&& !Number.isNaN(дКаналСоздан.getTime())
			);
			м_События.ОбработатьСобытие('twitch-полученыметаданныеканала',
			{
				сИмя: оРезультат.display_name || оРезультат.name,
				сАватар: оРезультат.logo || 'glitch.svg#avatar',
				сОписание: оРезультат.description,
				сКодЯзыка: оРезультат.broadcaster_language === 'other' ? null : оРезультат.broadcaster_language,
				кПодписчиков: оРезультат.followers,
				кПросмотров: оРезультат.views,
				дКаналСоздан
			});
		})
		.catch(пПричина =>
		{
			if (typeof пПричина === 'string')
			{
				м_Журнал.Ой(`[Twitch] Не удалось получить метаданные канала. ${пПричина}`);
			}
			// Отмены обещания в этой цепочке пока нет.
			else
			{
				м_Отладка.ПойманоИсключение(пПричина);
			}
		});

		м_Загрузчик.ЗагрузитьJson(null,
			`https://api.twitch.tv/kraken/channels/${_сИдКанала}/communities`,
			ЗАГРУЖАТЬ_МЕТАДАННЫЕ_НЕ_ДОЛЬШЕ, 'сообщества канала', true, ЗАГОЛОВКИ_ЗАПРОСА
		)
		.then(оРезультат =>
		{
			Проверить(Array.isArray(оРезультат.communities));
			for (let оСообщество of оРезультат.communities)
			{
				Проверить(ЭтоНепустаяСтрока(оСообщество.name));
				оСообщество.сИмя = оСообщество.display_name || оСообщество.name;
				оСообщество.сОписание = оСообщество.description;
				оСообщество.сАдрес = `https://www.twitch.tv/communities/${encodeURIComponent(оСообщество.name)}`;
			}
			м_События.ОбработатьСобытие('twitch-полученыметаданныеканала', {моСообщества: оРезультат.communities});
		})
		.catch(пПричина =>
		{
			if (typeof пПричина === 'string')
			{
				м_Журнал.Ой(`[Twitch] Не удалось получить сообщества канала. ${пПричина}`);
			}
			// Отмены обещания в этой цепочке пока нет.
			else
			{
				м_Отладка.ПойманоИсключение(пПричина);
			}
		});

		м_Загрузчик.ЗагрузитьJson(null,
			`https://api.twitch.tv/kraken/channels/${_сИдКанала}/teams`,
			ЗАГРУЖАТЬ_МЕТАДАННЫЕ_НЕ_ДОЛЬШЕ, 'команды канала', true, ЗАГОЛОВКИ_ЗАПРОСА
		)
		.then(оРезультат =>
		{
			Проверить(Array.isArray(оРезультат.teams));
			for (let оКоманда of оРезультат.teams)
			{
				Проверить(ЭтоНепустаяСтрока(оКоманда.name));
				оКоманда.сИмя = оКоманда.display_name || оКоманда.name;
				if (оКоманда.info)
				{
					оКоманда.сОписание = ПреобразоватьРазметкуВТекст(оКоманда.info);
				}
				оКоманда.сАдрес = `https://www.twitch.tv/team/${encodeURIComponent(оКоманда.name)}`;
			}
			м_События.ОбработатьСобытие('twitch-полученыметаданныеканала', {моКоманды: оРезультат.teams});
		})
		.catch(пПричина =>
		{
			if (typeof пПричина === 'string')
			{
				м_Журнал.Ой(`[Twitch] Не удалось получить команды канала. ${пПричина}`);
			}
			// Отмены обещания в этой цепочке пока нет.
			else
			{
				м_Отладка.ПойманоИсключение(пПричина);
			}
		});
	}

	function ПолучитьМетаданныеЗрителя()
	{
		let сИмя;
		м_Загрузчик.ЗагрузитьJson(null, 'https://api.twitch.tv/kraken/user',
			ЗАГРУЖАТЬ_МЕТАДАННЫЕ_НЕ_ДОЛЬШЕ, 'метаданные зрителя', true,
			ЗАГОЛОВКИ_ЗАПРОСА
		)
		.then(оРезультат =>
		{
			Проверить(ЭтоНепустаяСтрока(оРезультат._id));
			Проверить(ЭтоНепустаяСтрока(оРезультат.name));
			_сИдЗрителя = оРезультат._id;
			сИмя = оРезультат.display_name || оРезультат.name;
			return м_Загрузчик.ЗагрузитьJson(null, 'https://api.twitch.tv/api/viewer/token.json',
				ЗАГРУЖАТЬ_МЕТАДАННЫЕ_НЕ_ДОЛЬШЕ, 'токен зрителя',
				false,
				{'Client-ID': ИДЕНТИФИКАТОР_КЛИЕНТА}
			);
		})
		.then(оРезультат =>
		{
			Проверить(ЭтоНепустаяСтрока(оРезультат.token));
			_сТокенЗрителя = оРезультат.token;
			м_События.ОбработатьСобытие('twitch-полученыметаданныезрителя', {сИмя});
			ПолучитьИлиИзменитьПодпискуЗрителяНаКанал();
		})
		.catch(ДобавитьОбработчикИсключений(пПричина =>
		{
			if (typeof пПричина === 'string')
			{
				// Считаем, что зритель не авторизован на сайте Twitch.tv.
				м_Журнал.Ой(`[Twitch] Не удалось получить метаданные зрителя. ${пПричина}`);
				_сИдЗрителя = _сТокенЗрителя = '';
				м_События.ОбработатьСобытие('twitch-полученыметаданныезрителя', {сИмя: ''});
			}
			// Отмены обещания в этой цепочке пока нет.
			else
			{
				throw пПричина;
			}
		}));
	}

	function ОбновитьМетаданныеТрансляции(чЧерез)
	{
		Проверить(_сИдКанала);
		м_Журнал.Вот(`[Twitch] Загрузка метаданных трансляции начнется через ${м_Журнал.F0(чЧерез)}мс`);
		Ждать(_ооОбновлениеМетаданных, чЧерез)
		.then(() =>
		{
			return м_Загрузчик.ЗагрузитьJson(_ооОбновлениеМетаданных,
				`https://api.twitch.tv/kraken/streams/${_сИдКанала}`,
				ЗАГРУЖАТЬ_МЕТАДАННЫЕ_НЕ_ДОЛЬШЕ, 'метаданные трансляции', true, ЗАГОЛОВКИ_ЗАПРОСА
			);
		})
		.then(оРезультат =>
		{
			// Данные отсутствуют если трансляция скрыта или только началась.
			if (!ЭтоОбъект(оРезультат) || !ЭтоОбъект(оРезультат.stream))
			{
				throw 'В загруженном JSON нет метаданных';
			}
			const чДлительностьТрансляции = Date.now() - Date.parse(оРезультат.stream.created_at); // ISO 8601
			Проверить(
				String(оРезультат.stream.channel._id) === _сИдКанала
				&& оРезультат.stream.hasOwnProperty('_id')
				&& ЭтоНепустаяСтрока(оРезультат.stream.stream_type)
				&& Number.isFinite(оРезультат.stream.viewers)
				&& Number.isFinite(чДлительностьТрансляции)
			);
			// Менять здесь: https://passport.twitch.tv/logins/new
			if (_сКодКанала !== оРезультат.stream.channel.name)
			{
				м_Журнал.Ой(`[Twitch] Изменился код канала с ${_сКодКанала} на ${оРезультат.stream.channel.name}`);
				_сКодКанала = оРезультат.stream.channel.name;
			}
			// live - прямая трансляция, rerun - повтор трансляции.
			const лЗапись = оРезультат.stream.stream_type !== 'live';
			const оМетаданные =
			{
				сНазваниеТрансляции: оРезультат.stream.channel.status || Текст('J0103'),
				сНазваниеИгры: лЗапись ? null : оРезультат.stream.game || Текст('J0104'),
				сАдресИгры: ПолучитьАдресКаталогаИгры(оРезультат.stream.game),
				кЗрителей: оРезультат.stream.viewers,
				чДлительностьТрансляции
			};
			// Теоретически возможна ситуация, когда сервер начал другую трансляцию, а старая еще не досмотрена
			// (часть находится в буфере проигрывателя). Поэтому не перезаписываем _сИдТрансляции.
			if (_сИдТрансляции === '')
			{
				м_Журнал.Окак(`[Twitch] Идентификатор трансляции: ${оРезультат.stream._id}`);
				_сИдТрансляции = String(оРезультат.stream._id);
				оМетаданные.лЗапись = лЗапись;
				оМетаданные.сАдресЗаписи = '';
				if (!лЗапись)
				{
					ПолучитьАдресЗаписиТрансляции(чДлительностьТрансляции);
				}
			}
			м_События.ОбработатьСобытие('twitch-полученыметаданныетрансляции', оМетаданные);
			ОбновитьМетаданныеТрансляции(ИНТЕРВАЛ_ОБНОВЛЕНИЯ_МЕТАДАННЫХ_ТРАНСЛЯЦИИ);
		})
		.catch(ДобавитьОбработчикИсключений(пПричина =>
		{
			// Не удалось загрузить или разобрать файл?
			if (typeof пПричина === 'string')
			{
				м_Журнал.Ой(`[Twitch] Не удалось загрузить метаданные трансляции. ${пПричина}`);
				ОбновитьМетаданныеТрансляции(ИНТЕРВАЛ_ОБНОВЛЕНИЯ_МЕТАДАННЫХ_ТРАНСЛЯЦИИ / 2);
			}
			// Загрузка отменена?
			else if (пПричина === ОтменаОбещания.ОБЕЩАНИЕ_ОТМЕНЕНО)
			{
				м_Журнал.Вот('[Twitch] Отменено обновление метаданных трансляции');
			}
			else
			{
				throw пПричина;
			}
		}));
	}

	function ПолучитьАдресЗаписиТрансляции(чДлительностьТрансляции)
	{
		Проверить(_сИдКанала && _сИдТрансляции);
		// _ооОбновлениеМетаданных использовать нельзя, потому что ОтменаОбещания может отменить только одну цепочку обещаний.
		const сИдТрансляции = _сИдТрансляции;
		// Запись доступна только через несколько минут после начала трансляции.
		// Возможна отрицательная чДлительностьТрансляции, если время на компьютере пользователя установлено неправильно.
		const чЖдать = Math.max(ЗАДЕРЖКА_ОБНОВЛЕНИЯ_МЕТАДАННЫХ_ЗАПИСИ - Math.max(чДлительностьТрансляции, 0), 0);
		м_Журнал.Вот(`[Twitch] Получение записи трансляции начнется через ${м_Журнал.F0(чЖдать)}мс`);
		Ждать(null, чЖдать)
		.then(() =>
		{
			if (сИдТрансляции !== _сИдТрансляции)
			{
				throw 'Трансляция завершена';
			}
			// По broadcast_id фильровать не умеет.
			return м_Загрузчик.ЗагрузитьJson(null,
				`https://api.twitch.tv/kraken/channels/${_сИдКанала}/videos?broadcast_type=archive&limit=3`,
				ЗАГРУЖАТЬ_МЕТАДАННЫЕ_НЕ_ДОЛЬШЕ, 'запись трансляции', true, ЗАГОЛОВКИ_ЗАПРОСА
			);
		})
		.then(оРезультат =>
		{
			if (сИдТрансляции !== _сИдТрансляции)
			{
				throw 'Трансляция завершена';
			}
			for (let оЗапись of оРезультат.videos)
			{
				if (String(оЗапись.broadcast_id) === сИдТрансляции)
				{
					Проверить(оЗапись.broadcast_type === 'archive');
					Проверить(String(оЗапись.channel._id) === _сИдКанала);
					Проверить(ЭтоНепустаяСтрока(оЗапись.url));
					_сАдресЗаписи = оЗапись.url;
					м_События.ОбработатьСобытие('twitch-полученыметаданныетрансляции',
					{
						лЗапись: false,
						сАдресЗаписи: _сАдресЗаписи
					});
					break;
				}
			}
		})
		.catch(пПричина =>
		{
			if (typeof пПричина === 'string')
			{
				м_Журнал.Ой(`[Twitch] Не удалось загрузить запись трансляции. ${пПричина}`);
			}
			// Отмены обещания в этой цепочке пока нет.
			else
			{
				м_Отладка.ПойманоИсключение(пПричина);
			}
		});
	}

	function НачатьСборМетаданныхТрансляции()
	{
		ОчиститьДанныеТрансляции();
		_ооОбновлениеМетаданных.НачалоВыполнения();
		ОбновитьМетаданныеТрансляции(0);
	}

	function ЗавершитьСборМетаданныхТрансляции(лТрансляцияЗавершена)
	{
		м_Журнал.Вот(`[Twitch] Отменяю обновление метаданных трансляции ТрансляцияЗавершена=${лТрансляцияЗавершена}`);
		// Не менять _сИдТрансляции после постановки на паузу, чтобы не прерывать работу
		// ПолучитьАдресЗаписиТрансляции(), а также чтобы была возможность создать клип.
		if (лТрансляцияЗавершена)
		{
			ОчиститьДанныеТрансляции();
		}
		_ооОбновлениеМетаданных.Отменить();
	}

	function ПолучитьАдресЗаписиДляТекущейПозиции()
	{
		const чПозиция = м_Проигрыватель.ПолучитьПозициюВоспроизведенияТрансляции(false);
		if (_сАдресЗаписи === '' || чПозиция === -1)
		{
			м_Журнал.Ой(`[Twitch] Недостаточно данных для получения адреса записи АдресЗаписи=${_сАдресЗаписи} Позиция=${чПозиция}`);
			return '';
		}
		return `${_сАдресЗаписи}?t=${Math.floor(чПозиция / 60 / 60)}h${Math.floor(чПозиция / 60 % 60)}m${Math.floor(чПозиция % 60)}s`;
	}

	function СоздатьКлип()
	// TODO Проверять авторизацию, например _сИдЗрителя. Пока она обновляется только во время загрузки
	// страницы, а также использует недокументированые возможности. Вреда может быть больше, чем пользы.
	{
		const чПозиция = м_Проигрыватель.ПолучитьПозициюВоспроизведенияТрансляции(true);
		if (_сИдТрансляции === '' || чПозиция === -1)
		{
			м_Журнал.Ой(`[Twitch] Недостаточно данных для создания клипа ИдЗрителя=${_сИдЗрителя} ИдТрансляции=${_сИдТрансляции} Позиция=${чПозиция}`);
			return false;
		}
		м_Журнал.Окак(`[Twitch] Создаю клип ИдЗрителя=${_сИдЗрителя} ИдТрансляции=${_сИдТрансляции} Позиция=${чПозиция}`);
		Узел('создатьклип-канал').value = _сКодКанала;
		Узел('создатьклип-трансляция').value = _сИдТрансляции;
		Узел('создатьклип-позиция').value = Math.floor(чПозиция);
		try
		{
			// Firefox 60: Если расширению не разрешено открывать всплывающие окна и создание клипа запущено
			// нажатием комбинации клавиш на клавиатуре, то будет кинуто исключение и показано уведомление.
			Узел('создатьклип-форма').submit();
		}
		catch (пИсключение)
		{
			м_Журнал.Ой(`[Twitch] Не удалось отправить форму для создания клипа: ${пИсключение}`);
			return false;
		}
		return true;
	}

	function ПолучитьАбсолютныйАдресСпискаСегментов(сАбсолютныйАдресСпискаСегментов)
	{
		return сАбсолютныйАдресСпискаСегментов;
	}

	Проверить(ЭтоНепустаяСтрока(_сКодКанала));

	return {
		ПолучитьАбсолютныйАдресСпискаВариантов, ПолучитьАбсолютныйАдресСпискаСегментов,
		ПолучитьАдресКанала, ПолучитьАдресПанелиЧата, ЭтоАдресПанелиЧата,
		НачатьСборМетаданныхТрансляции, ЗавершитьСборМетаданныхТрансляции,
		ИзменитьПодпискуЗрителяНаКанал,
		ПолучитьАдресЗаписиДляТекущейПозиции,
		СоздатьКлип
	};
}


//
// Запускалка.
//

function ЗавершитьРаботу(лБыстро)
{
	try
	{
		м_Журнал.Окак('[Запускалка] Завершаю работу');
		м_Настройки.Остановить();
		if (!лБыстро)
		{
			м_Статистика.Остановить();
			м_Преобразователь.Остановить();
			м_Проигрыватель.Остановить();
			м_Помойка.Сжечь();
		}
		м_Журнал.Окак('[Запускалка] Работа завершена');
	}
	catch (и)
	{}
	finally
	{
		// Изменяем в последнюю очередь, чтобы код выше мог выполнить функции завернутые в ДобавитьОбработчикИсключений().
		г_лРаботаЗавершена = true;
		// Если разбор страницы не завершен, не вставлять оставшиеся <script>.
		// Chrome 49, 68: Синхронно прерывает выполнение всех XMLHttpRequest. Посылает событие abort.
		// Firefox 52, 61: Прерывает выполнение всех XMLHttpRequest позже. Посылает событие error.
		// Edge 16: Не прерывает выполнение XMLHttpRequest.
		window.stop();
	}
}

ДобавитьОбработчикИсключений(() =>
{
	function ВыделитьКанал(оАдрес)
	{
		// Канала с названием channel не существует.
		const сКанал = РазобратьПараметры(оАдрес).get('channel') || 'channel';
		// Вместо кода канала пользователь мог вставить название канала.
		return сКанал.includes(':') ? сКанал : сКанал.toLowerCase();
	}

	function ЭтотКаналУжеОткрыт(сКанал)
	// Используются сообщения вместо getViews(), потому что последняя жутко глючит в Edge:
	// Edge 15: У отключенного расширения доступна страница, но не работает getViews().
	// https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/12290588/
	// Edge 15: После установки расширения, getViews() не работает до перезапуска браузера.
	// https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/13131564/
	// Edge 16: getViews() кидает исключение, если открыта другая вкладка расширения, которая еще не начала загружаться.
	// Edge 16: Иногда вместо окна расширения getViews() возвращает фрейм, который находится в этом окне.
	{
		Проверить(ЭтоНепустаяСтрока(сКанал));
		chrome.runtime.sendMessage(
			{
				сЗапрос: 'ЭтотКаналУжеОткрыт',
				сКанал
			},
			undefined,
			пОтвет =>
			{
				// Firefox 60: chrome.runtime.lastError == null и пОтвет == undefined если произошла ошибка.
				if (пОтвет === true)
				{
					м_Отладка.ЗавершитьРаботуИПоказатьСообщение('J0211');
				}
			}
		);
		chrome.runtime.onMessage.addListener(ДобавитьОбработчикИсключений((оСообщение, оОтправитель, фОтветить) =>
		{
			if (оСообщение.сЗапрос === 'ЭтотКаналУжеОткрыт')
			{
				м_Журнал.Окак(`[Запускалка] Открыт канал ${оСообщение.сКанал}`);
				if (оСообщение.сКанал === сКанал)
				{
					фОтветить(true);
				}
			}
		}));
	}

	function ПолучитьТекущуюВкладку()
	{
		return new Promise((фВыполнить, фОтказаться) =>
		{
			chrome.tabs.getCurrent(оВкладка =>
			{
				try
				{
					Проверить(!chrome.runtime.lastError);
					Проверить(Number.isInteger(оВкладка.id) && оВкладка.id >= 0);
					г_чИдВкладки = оВкладка.id;
					фВыполнить();
				}
				catch (пИсключение)
				{
					фОтказаться(пИсключение);
				}
			});
		});
	}

	function ЖдатьЗагрузкуСтраницы()
	{
		return new Promise((фВыполнить, фОтказаться) =>
		{
			if (document.readyState === 'complete')
			{
				м_Журнал.Ой('[Запускалка] document.readyState=complete');
				фВыполнить();
			}
			else
			{
				м_Журнал.Вот(`[Запускалка] document.readyState=${document.readyState}`);
				window.addEventListener('load', function ОбработатьЗагрузкуСтраницы()
				{
					try
					{
						window.removeEventListener('load', ОбработатьЗагрузкуСтраницы);
						Проверить(document.readyState === 'complete');
						м_Журнал.Вот('[Запускалка] window.onload');
						фВыполнить();
					}
					catch (пИсключение)
					{
						фОтказаться(пИсключение);
					}
				});
			}
		});
	}

	function ОбработатьВыгрузкуСтраницы()
	{
		м_Журнал.Окак('[Запускалка] window.beforeunload');
		ЗавершитьРаботу(true);
	}

	function НачатьРаботу()
	{
		Проверить(!г_лРаботаЗавершена);
		м_Журнал.Вот(`[Запускалка] Начало работы ${performance.now().toFixed()}мс`);
		window.addEventListener('beforeunload', ОбработатьВыгрузкуСтраницы);
		м_Управление.Запустить();
		if (м_Проигрыватель.Запустить())
		{
			м_Список.Запустить();
		}
		else
		{
			м_Управление.ОстановитьПросмотрТрансляции();
		}
		м_Статистика.Запустить();
	}

	// Edge 15 не дает запускать проигрыватель во фрейме на обычном сайте.
	if (window.top !== window)
	{
		return;
	}

	if (navigator.userAgent.includes('Gecko/') || navigator.userAgent.includes('Edge/'))
	{
		м_Отладка.ЗавершитьРаботуИПоказатьСообщение('J0204');
	}

	const сКанал = ВыделитьКанал(window.location);
	м_Журнал.Вот(`[Запускалка] Канал ${сКанал}`);
	ЭтотКаналУжеОткрыт(сКанал);
	м_Twitch = Twitch(сКанал);

	Promise.all(
	[
		м_Настройки.Восстановить(),
		м_Оформление.ЗапуститьАсинхронно(),
		ПолучитьТекущуюВкладку(),
		// Ждем загрузку остальных <script>.
		ЖдатьЗагрузкуСтраницы()
	])
	.then(НачатьРаботу)
	.catch(м_Отладка.ПойманоИсключение);

	м_i18n.TranslateDocument(document);
})();

function fitVideo() {
	const video = document.getElementById('глаз'),
		wHeight = window.innerHeight,
		wWidth = window.innerWidth
	let vWidth = video.videoWidth,
		vHeight = video.videoHeight

	let sw = false
	if (vHeight > wHeight) { 
		vHeight = wHeight
		sw = true
	}
	if (vWidth > wWidth) {
		vWidth = wWidth
		sw = true
	}
	if (sw) video.style.objectFit = 'fill'

	video.style.width = vWidth + 'px'
	video.style.height = vHeight + 'px'
}