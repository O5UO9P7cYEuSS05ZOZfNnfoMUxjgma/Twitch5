﻿(function(window){
'use strict';

const document = window.document, performance = window.performance

// Формат версии: https://developer.chrome.com/extensions/manifest/version
// В моем случае это UTC-дата выкладывания данной версии для скачивания.
// 1 - год >= 2016
// 2 - месяц 1..12
// 3 - день месяца 1..31
// 4 - указывается только для версий, выпущенных в один день. >= 1, по умолчанию 0.
// Edge 15: Последнее число должно быть нулем.
// https://docs.microsoft.com/en-us/microsoft-edge/extensions/guides/packaging/creating-and-testing-extension-packages#json-manifest-template-values
const ВЕРСИЯ_РАСШИРЕНИЯ = '2018.5.18';
const ВЕРСИЯ_ДВИЖКА_БРАУЗЕРА = Number.parseInt(/Chrome\/(\d+)/.exec(navigator.userAgent)[1], 10);
//const ЭТО_ПЛАНШЕТ = false;

// Chrome 59 + Windows + аппаратное декодирование: Для завершения перемотки и начала воспроизведения нужно не менее
// 4 кадров, не исключено, что иногда и больше. Без аппаратного декодирования достаточно 2 кадров.
const МИН_РАЗМЕР_БУФЕРА         = 1.5; // Секунды.
const МАКС_РАЗМЕР_БУФЕРА        =  30; // Секунды. TODO Измерять в сегментах?
const МИН_РАСТЯГИВАНИЕ_БУФЕРА   =   9; // Секунды. TODO Измерять в сегментах?
const МАКС_РАСТЯГИВАНИЕ_БУФЕРА  =  30; // Секунды. TODO Измерять в сегментах?
const ПЕРЕПОЛНЕНИЕ_БУФЕРА       = МАКС_РАЗМЕР_БУФЕРА + МАКС_РАСТЯГИВАНИЕ_БУФЕРА; // TODO Избавиться от ПЕРЕПОЛНЕНИЕ_БУФЕРА.

// Если в удаляемом диапазоне есть ключевой кадр, то будут удалены все последующие кадры до ключевого кадра, не входящего
// в удаляемый диапазон. Таким образом возможна ситуация, когда будет удалено всё просмотренное видео и часть
// непросмотренного, что приведет к остановке воспроизведения. Чтобы этого не произошло, МИН_ДЛИТЕЛЬНОСТЬ_ПОВТОРА должна
// превышать расстояние между ключевыми кадрами. Чем больше видео в буфере, тем выше расход памяти, до 150 МиБ.
const МИН_ДЛИТЕЛЬНОСТЬ_ПОВТОРА  = 30;  // Секунды.
const МАКС_ДЛИТЕЛЬНОСТЬ_ПОВТОРА = 300; // Секунды.

// По стандарту HLS минимальный интервал равен 50.
const МИН_ИНТЕРВАЛ_ОБНОВЛЕНИЯ_СПИСКОВ      = 40;    // Процент target duration.

const ЗАГРУЖАТЬ_МЕТАДАННЫЕ_НЕ_ДОЛЬШЕ       = 15000; // Миллисекунды.
const ЗАГРУЖАТЬ_СПИСОК_ВАРИАНТОВ_НЕ_ДОЛЬШЕ = 15000; // Миллисекунды.
const ЗАГРУЖАТЬ_СПИСОК_СЕГМЕНТОВ_НЕ_ДОЛЬШЕ =  6000; // Миллисекунды.

// Edge 15 во всплывающей подсказке показывает текущее целое значение громкости,
// поэтому для интерфейса не подходит "родной" диапазон 0..1.
const МИНИМАЛЬНАЯ_ГРОМКОСТЬ            = 1;
const МАКСИМАЛЬНАЯ_ГРОМКОСТЬ           = 100;
const ШАГ_ПОВЫШЕНИЯ_ГРОМКОСТИ_КЛАВОЙ   = 4;
const ШАГ_ПОНИЖЕНИЯ_ГРОМКОСТИ_КЛАВОЙ   = 2;
const ШАГ_ИЗМЕНЕНИЯ_ГРОМКОСТИ_МЫШЬЮ    = 1;
const ШАГ_ПОВЫШЕНИЯ_ГРОМКОСТИ_КОЛЕСОМ  = 5;
const ШАГ_ПОНИЖЕНИЯ_ГРОМКОСТИ_КОЛЕСОМ  = 3;

const ОБРАБОТКА_ЖДЕТ_ЗАГРУЗКИ          = 1;
const ОБРАБОТКА_ЗАГРУЖАЕТСЯ            = 2;
const ОБРАБОТКА_ЗАГРУЖЕН               = 3;
const ОБРАБОТКА_ПРЕОБРАЗОВАН           = 4;

// Эти константы также определены в player.css.
const СОСТОЯНИЕ_ЗАПУСК                 = 1;
const СОСТОЯНИЕ_НАЧАЛО_ТРАНСЛЯЦИИ      = 2;
const СОСТОЯНИЕ_ЗАВЕРШЕНИЕ_ТРАНСЛЯЦИИ  = 3;
const СОСТОЯНИЕ_ЗАГРУЗКА               = 4;
const СОСТОЯНИЕ_НАЧАЛО_ВОСПРОИЗВЕДЕНИЯ = 5;
const СОСТОЯНИЕ_ВОСПРОИЗВЕДЕНИЕ        = 6;
const СОСТОЯНИЕ_ОСТАНОВКА              = 7;
const СОСТОЯНИЕ_ПОВТОР                 = 8;

// Эти константы также определены в player.css.
const ПОДПИСКА_ОБНОВЛЯЕТСЯ             = -1;
const ПОДПИСКА_НЕДОСТУПНА              = 0;
const ПОДПИСКА_НЕОФОРМЛЕНА             = 1;
const ПОДПИСКА_НЕУВЕДОМЛЯТЬ            = 2;
const ПОДПИСКА_УВЕДОМЛЯТЬ              = 3;

const КОД_ОТВЕТА                       = 'Сервер вернул код ';

const МИН_ЗНАЧЕНИЕ_НАСТРОЙКИ           = Number.MIN_SAFE_INTEGER + 1000; // На будущее.
const МАКС_ЗНАЧЕНИЕ_НАСТРОЙКИ          = Number.MAX_SAFE_INTEGER - 1000; // На будущее.
const АВТОНАСТРОЙКА                    = Number.MIN_SAFE_INTEGER;        // См. комментарий в Настройка.ПроверитьЗначение().

// MouseEvent.button.
const ЛЕВАЯ_КНОПКА                     = 0;
const СРЕДНЯЯ_КНОПКА                   = 1;
const ПРАВАЯ_КНОПКА                    = 2;

// Эти константы также определены в player.html.
const ЧАТ_ВЫГРУЖЕН                     = 0;
const ЧАТ_СКРЫТ                        = 1;
const ЧАТ_ПАНЕЛЬ                       = 2;

// Эти константы также определены в player.html.
const ВЕРХНЯЯ_СТОРОНА                  = 1;
const ПРАВАЯ_СТОРОНА                   = 2;
const НИЖНЯЯ_СТОРОНА                   = 3;
const ЛЕВАЯ_СТОРОНА                    = 4;

const ЗАСТРЕВАЕТ_СЕГМЕНТОВ_В_РАБОЧЕМ_ПОТОКЕ = ВЕРСИЯ_ДВИЖКА_БРАУЗЕРА < 50 ? 1 : 0;

let г_лРаботаЗавершена = false;
let г_чИдВкладки = NaN;

function Текст(сКод, сПодстановка)
{
	return м_i18n.GetMessage(сКод, сПодстановка);
}

function ЭтоОбъект(пЗначение)
{
	return typeof пЗначение === 'object' && пЗначение !== null;
}

function ЭтоЧисло(пЗначение)
{
	return typeof пЗначение === 'number' && пЗначение === пЗначение;
}

function Округлить(чЗначение, чТочность)
{
	Проверить(typeof чЗначение === 'number' && Number.isInteger(чТочность) && чТочность >= 0 && чТочность <= 20);
	if (чТочность === 0)
	{
		return Math.round(чЗначение);
	}
	var ч = Math.pow(10, чТочность);
	return Math.round(чЗначение * ч) / ч;
}

function Ограничить(чЗначение, чМинимум, чМаксимум)
{
	Проверить(Number.isFinite(чЗначение) && Number.isFinite(чМинимум) && Number.isFinite(чМаксимум) && чМинимум <= чМаксимум);
	return Math.min(Math.max(чЗначение, чМинимум), чМаксимум);
}

function StripHtmlTags(sText)
{
	Проверить(typeof sText === 'string');
	const elTemplate = document.createElement('template');
	// Commentary for AMO reviewers: <template> does not "load" or "execute" anything.
	elTemplate.innerHTML = sText;
	return elTemplate.content.textContent;
}

function ПреобразоватьРазметкуВТекст(сРазметка)
{
	Проверить(typeof сРазметка === 'string');
	сРазметка = сРазметка.replace(/[\t\r\n]/g, ' ').replace(/<\s*br[\s\/]*>/gi, '\n');
	сРазметка = StripHtmlTags(сРазметка);
	// Удаляет ведущие и конечные пробелы у всех строк. Удаляет пустые строки.
	сРазметка = сРазметка.replace(/^\s+|[^\S\r\n]+$/gm, '');
	return сРазметка.replace(/[^\S\r\n]{2,}/g, ' ');
}

function ResolveRelativeUrl(sRelativeUrl, sAbsoluteBaseUrl)
{
	return (new URL(sRelativeUrl, sAbsoluteBaseUrl)).href;
}

function РазобратьПараметры(оАдрес)
{
	// Edge 15 не поддерживает Location.searchParams и HTMLAnchorElement.searchParams.
	return оАдрес.searchParams || new URLSearchParams(оАдрес.search.slice(1));
}

function ИзменитьЗаголовокДокумента(сЗаголовок)
{
	// HACK Выполнить ПЕРЕД изменением заголовка, чтобы это изменение было отражено в browsing history браузера.
	history.replaceState(null, '');
	document.title = сЗаголовок;
}

function ЗаписатьТекстВЛокальныйФайл(сТекст, сТипДанных, сИмяФайла)
{
	Проверить(typeof сТекст === 'string' && ЭтоНепустаяСтрока(сТипДанных) && ЭтоНепустаяСтрока(сИмяФайла));
	const узСсылка = document.createElement('a');
	// Протокол data: оставляет в истории загрузок браузера сТекст. Не нужно нам таких подарочков.
	узСсылка.setAttribute('href', URL.createObjectURL(new Blob([сТекст], {type: сТипДанных})));
	узСсылка.setAttribute('download', сИмяФайла);
	// click() не работает пока ссылка не вставлена в документ.
	узСсылка.dispatchEvent(new MouseEvent('click'));
}

function ЭтоСобытиеДляСсылки(оСобытие)
{
	let уз = оСобытие.target;
	do
	{
		if (уз.nodeName === 'A')
		{
			return true;
		}
	}
	while (уз = уз.parentElement);
	return false;
}

function ЭлементВЭтойТочкеМожноПрокрутить(x, y)
{
	for (var узЭлемент = document.elementFromPoint(x, y); узЭлемент; узЭлемент = узЭлемент.parentElement)
	{
		if (ЭтотЭлементМожноПрокрутить(узЭлемент))
		{
			return true;
		}
	}
	return false;
}

function ЭтотЭлементМожноПрокрутить(узЭлемент)
{
	const оСтиль = getComputedStyle(узЭлемент);
	return (оСтиль.overflowY === 'scroll' || оСтиль.overflowY === 'auto') && (узЭлемент.clientHeight < узЭлемент.scrollHeight);
}

function ЭлементПолностьюПрокручен(узЭлемент)
{
	// На всякий случай сравниваем не с 0. Из-за дробных rem возможны округления и нестыковки.
	return узЭлемент.scrollHeight - узЭлемент.scrollTop - узЭлемент.clientHeight < 2;
}

function ЭтотЭлементМожноВыделить(узЭлемент)
// Firefox 59: Вопреки стандарту, getComputedStyle() не учитывает значение родительских элементов. Делаем это самостоятельно.
// https://bugzilla.mozilla.org/show_bug.cgi?id=1328475
{
	do
	{
		const оСтиль = getComputedStyle(узЭлемент);
		const сЗначение = оСтиль.getPropertyValue('user-select') || оСтиль.getPropertyValue('-webkit-user-select') || оСтиль.getPropertyValue('-moz-user-select');
		Проверить(сЗначение);
		if (сЗначение !== 'auto')
		{
			return сЗначение !== 'none';
		}
	}
	while (узЭлемент = узЭлемент.parentElement);
	return true;
}

function ПоказатьЭлемент(пЭлемент, лПоказать)
{
	Проверить(ЭтоОбъект(пЭлемент) || ЭтоНепустаяСтрока(пЭлемент));
	if (typeof пЭлемент === 'string')
	{
		пЭлемент = document.getElementById(пЭлемент);
	}
	if (лПоказать)
	{
		пЭлемент.removeAttribute('hidden');
	}
	else
	{
		пЭлемент.setAttribute('hidden', '');
	}
	return пЭлемент;
}

function ЭлементПоказан(пЭлемент)
{
	if (typeof пЭлемент === 'string')
	{
		пЭлемент = document.getElementById(пЭлемент);
	}
	return !пЭлемент.hasAttribute('hidden');
}

const м_Отладка = (() =>
{
	var _сСписокВариантов = '';
	var _мСпискиСегментов = [];

	function ВставитьСсылкиДляСкачиванияФайлов(узФорма)
	{
	}

	function ПоказатьСтраницу()
	{
		м_Управление.ОтключитьПолноэкранныйРежим();

		document.body.textContent = '';
		for (let уз of document.querySelectorAll('link[rel="stylesheet"], style'))
		{
			уз.remove();
		}
		for (let уз of [document.documentElement, document.body])
		{
			уз.removeAttribute('class');
			уз.removeAttribute('style');
			уз.removeAttribute('hidden');
		}

		return new Promise((фВыполнить, фОтказаться) =>
		{
			const уз = document.createElement('iframe');
			уз.style.position = 'fixed';
			уз.style.top      = '0';
			уз.style.left     = '0';
			уз.style.width    = '100%';
			уз.style.height   = '100%';
			уз.style.zIndex   = '100500';
			уз.style.border   = '0';
			уз.src = 'report.html';
			уз.addEventListener('load', function ОбработатьОкончаниеЗагрузки()
			{
				уз.removeEventListener('load', ОбработатьОкончаниеЗагрузки);
				м_i18n.TranslateDocument(уз.contentDocument);
				фВыполнить(уз.contentDocument);
			});
			document.body.appendChild(уз);
		});
	}

	function ПоказатьФорму(оДокумент, сИдентификаторФормы, лНастроитьФон)
	{
		if (лНастроитьФон)
		{
			// HACK Chrome 63+: Если повесить определение цвета фона на body, то у формы #отладка-сообщение
			// фон останется белым. Влияет на это центровка по вертикали и еще черт знает что.
			оДокумент.documentElement.classList.add(сИдентификаторФормы);
		}

		// Chrome 50-: Итераторы я добавил только для текущего контекста.
		// Edge 16: HTMLCollection из другого контекста (iframe) не работает в for...of.
		for (let сузПоказатьИлиСкрыть = оДокумент.forms, ы = 0, узПоказатьИлиСкрыть; узПоказатьИлиСкрыть = сузПоказатьИлиСкрыть[ы]; ++ы)
		{
			if (узПоказатьИлиСкрыть.id === сИдентификаторФормы)
			{
				ПоказатьЭлемент(узПоказатьИлиСкрыть, true);
				const узФокус = узПоказатьИлиСкрыть.querySelector('*[autofocus]');
				if (узФокус)
				{
					узФокус.focus();
				}
			}
			else
			{
				ПоказатьЭлемент(узПоказатьИлиСкрыть, false);
			}
		}
	}

	function ПоказатьСообщение(сСообщение)
	{
		ПоказатьСтраницу()
		.then(оДокумент =>
		{
			оДокумент.getElementById('отладка-текстсообщения').textContent = сСообщение;
			ПоказатьФорму(оДокумент, 'отладка-сообщение', true);
		});
	}

	function ПоказатьИОтправитьОтчет(оОтчет, буфОтправить)
	{
		ПоказатьСтраницу()
		.then(оДокумент =>
		{
			let узФорма;
			if (оОтчет.ПричинаЗавершенияРаботы === 'ОТПРАВИТЬ ОТЗЫВ')
			{
				узФорма = оДокумент.getElementById('отладка-отзыв');
			}
			else
			{
				узФорма = оДокумент.getElementById('отладка-ошибка');
				ВставитьСсылкиДляСкачиванияФайлов(узФорма);
			}
			узФорма.elements["отладка-отчет"].value = JSON.stringify(оОтчет);
			ПоказатьФорму(оДокумент, узФорма.id, true);

			оДокумент.addEventListener('reset', оСобытие =>
			{
				оСобытие.preventDefault();
				window.location.reload();
			});

			let оЗапрос, оДанные, лПолучилось = false;
			// Нажимать кнопки можно клавишей ENTER.
			оДокумент.addEventListener('submit', оСобытие =>
			{
				оСобытие.preventDefault();
				switch (оСобытие.target.id)
				{
				case 'отладка-идетотправка':
					лПолучилось = true;
					// Синхронно вызывает обработчик события loadend.
					оЗапрос.abort();
					break;

				case 'отладка-сбойотправки':
					узФорма.querySelector('*[type="submit"]').click();
					break;

				default:
					оДокумент.getElementById('отладка-ходотправки').value = 0;
					ПоказатьФорму(оДокумент, 'отладка-идетотправка', false);
		
					if (!оЗапрос)
					{
						оЗапрос = new XMLHttpRequest();
						оЗапрос.upload.addEventListener('progress', оСобытие =>
						{
							оДокумент.getElementById('отладка-ходотправки').value = оСобытие.loaded / оСобытие.total;
						});
						оЗапрос.addEventListener('load', оСобытие =>
						{
							лПолучилось = оСобытие.target.status >= 200 && оСобытие.target.status <= 299;
							// Ждем loadend.
						});
						оЗапрос.addEventListener('loadend', () =>
						{
							if (лПолучилось)
							{
								window.location.reload();
							}
							else
							{
								ПоказатьФорму(оДокумент, 'отладка-сбойотправки', false);
							}
						});

						оДанные = new FormData(оСобытие.target);
						if (буфОтправить)
						{
							оДанные.append('отладка-транспортныйпоток-0', new Blob([буфОтправить], {type: 'video/mp2t'}));
						}
					}

					оЗапрос.open('POST', 'http://r90354g8.beget.tech/tw5/report3.php');
					оЗапрос.send(оДанные);
				}
			});
		});
	}

	function СохранитьСписокВариантов(сСписокВариантов)
	{
		if (!г_лРаботаЗавершена)
		{
			_сСписокВариантов = ОграничитьДлинуСтроки(сСписокВариантов, 15000);
		}
	}

	function СохранитьСписокСегментов(сСписокСегментов)
	{
		if (!г_лРаботаЗавершена)
		{
			if (_мСпискиСегментов.length === 3)
			{
				_мСпискиСегментов.shift();
			}
			_мСпискиСегментов.push(ОграничитьДлинуСтроки(сСписокСегментов, 15000));
		}
	}

	function СохранитьТранспортныйПоток(оСегмент)
	{
	}

	function СохранитьПреобразованныйСегмент(оСегмент)
	{
	}

	function ОбнюхатьОперативку(фВызвать)
	{
		try
		{
			chrome.system.memory.getInfo(оОперативка =>
			{
				фВызвать(chrome.runtime.lastError ? undefined : оОперативка);
			});
		}
		catch (и)
		{
			фВызвать();
		}
	}

	function ОбнюхатьПроцессор(фВызвать)
	{
		try
		{
			chrome.system.cpu.getInfo(оПроцессор =>
			{
				фВызвать(chrome.runtime.lastError ? undefined : оПроцессор);
			});
		}
		catch (и)
		{
			фВызвать();
		}
	}

	function ОбнюхатьВидюху()
	{
		try
		{
			var oContext = document.createElement('canvas').getContext('webgl');
			var oExtension = oContext.getExtension('WEBGL_debug_renderer_info');
			return oContext.getParameter(oExtension.UNMASKED_VENDOR_WEBGL) + ' | ' + oContext.getParameter(oExtension.UNMASKED_RENDERER_WEBGL);
		}
		catch (и) {}
	}

	function ПолучитьЯзык()
	{
		try
		{
			return Текст('J0103');
		}
		catch (и) {}
	}

	function СоздатьПоказатьИОтправитьОтчет(сПричинаЗавершенияРаботы, буфОтправить)
	{
		ОбнюхатьОперативку(пОперативка =>
		{
			ОбнюхатьПроцессор(пПроцессор =>
			{
				ПоказатьИОтправитьОтчет(
					// В JSON не попадут свойства со значением undefined.
					{
						ПричинаЗавершенияРаботы:  сПричинаЗавершенияРаботы,
						ВерсияРасширения:         ВЕРСИЯ_РАСШИРЕНИЯ,
						Оборзеватель:             navigator.userAgent,
						Время:                    (new Date()).toISOString(),
						Адрес:                    window.location.href,
						Инкогнито:                chrome.extension.inIncognitoContext,
						Оперативка:               пОперативка,
						Процессор:                пПроцессор,
						Видюха:                   ОбнюхатьВидюху(),
						Язык:                     ПолучитьЯзык(),
						ОтклонениеПульса:         _чМаксимальноеОтклонениеПульса,
						Экран:
						{
							top:                  window.screen.top,
							left:                 window.screen.left,
							width:                window.screen.width,
							height:               window.screen.height,
							availTop:             window.screen.availTop,
							availLeft:            window.screen.availLeft,
							availWidth:           window.screen.availWidth,
							availHeight:          window.screen.availHeight,
							// Firefox 47 Windows: Возвращает реальные значения.
							// Chrome 51 Windows: Всегда возвращает 24.
							colorDepth:           window.screen.colorDepth,
							pixelDepth:           window.screen.pixelDepth,
							orientation:          typeof window.screen.orientation === 'object' ? window.screen.orientation.type : undefined,
							screenX:              window.screenX,
							screenY:              window.screenY,
							outerWidth:           window.outerWidth,
							outerHeight:          window.outerHeight,
							innerWidth:           window.innerWidth,
							innerHeight:          window.innerHeight,
							devicePixelRatio:     window.devicePixelRatio
						},
						Фокусник:                 м_Фокусник.ПолучитьСостояние(),
						Настройки:                м_Настройки.ПолучитьДанныеДляОтчета(),
						Статистика:               м_Статистика.ПолучитьДанныеДляОтчета(),
						СписокВариантов:          _сСписокВариантов,
						СпискиСегментов:          _мСпискиСегментов,
						Журнал:                   м_Журнал.ПолучитьДанныеДляОтчета()
					},
					буфОтправить
				);
			});
		});
	}

	function ЗавершитьРаботуИПоказатьСообщение(сКодСообщения)
	{
		if (!г_лРаботаЗавершена)
		{
			console.error(сКодСообщения);
			ЗавершитьРаботу(false);
			ПоказатьСообщение(Текст(сКодСообщения));
		}
		throw undefined;
	}

	function ЗавершитьРаботуИОтправитьОтчет(сПричинаЗавершенияРаботы, буфОтправить)
	{
		if (!г_лРаботаЗавершена)
		{
			console.error(сПричинаЗавершенияРаботы);
			сПричинаЗавершенияРаботы = String(сПричинаЗавершенияРаботы);
			// Firefox 47 x86 + Windows: При нехватке памяти (commit) может кинуть исключение out of memory в player.js, worker.js и worker.onerror.
			// Chrome 52 x64 + Windows: При нехватке памяти (commit) процесс сразу падает.
			if (сПричинаЗавершенияРаботы.includes('out of memory'))
			{
				ЗавершитьРаботуИПоказатьСообщение('J0200');
			}
			try
			{
				м_Проигрыватель.ПоказатьСостояние('Вот', '[Отладка] Завершаю работу');
				г_моОчередь.ПоказатьСостояние();
			}
			catch (и) {}
			ЗавершитьРаботу(false);
			СоздатьПоказатьИОтправитьОтчет(сПричинаЗавершенияРаботы, буфОтправить);
		}
		throw undefined;
	}

	function ПойманоИсключение(пИсключение)
	{
		ЗавершитьРаботуИОтправитьОтчет(
			пИсключение instanceof Error ? пИсключение.stack
			: `[typeof ${typeof пИсключение}] ${new Error(пИсключение).stack}`
		);
	}

	function ЗавершитьРаботуИОтправитьОтзыв()
	{
		try
		{
			ЗавершитьРаботуИОтправитьОтчет('ОТПРАВИТЬ ОТЗЫВ');
		}
		catch (и) {}
	}

	const ИНТЕРВАЛ_ПУЛЬСА                = 500;
	const МАКС_ОТКЛОНЕНИЕ_ВРЕМЕНИ_ПУЛЬСА = 200;
	const МАКС_ОТКЛОНЕНИЕ_ДАТЫ_ПУЛЬСА    = 40;
	var _чТаймерПульса                   = 0;
	var _чМаксимальноеОтклонениеПульса   = 0;
	var _чВремяНачалаПульса;
	var _чДатаНачалаПульса;

	const ПроверитьПульс = ДобавитьОбработчикИсключений(() =>
	{
		var чВремя = performance.now();
		var чДата = Date.now();
		if (м_Управление.ПолучитьСостояние() !== СОСТОЯНИЕ_ОСТАНОВКА && м_Управление.ПолучитьСостояние() !== СОСТОЯНИЕ_ПОВТОР)
		{
			var чПрошлоВремени = чВремя - _чВремяНачалаПульса;
			var чОтклонениеВремени = чПрошлоВремени - (document.hidden ? Math.max(ИНТЕРВАЛ_ПУЛЬСА, 1000) : ИНТЕРВАЛ_ПУЛЬСА);
			var чОтклонениеДаты = чДата - _чДатаНачалаПульса - чПрошлоВремени;
			if (чОтклонениеВремени > МАКС_ОТКЛОНЕНИЕ_ВРЕМЕНИ_ПУЛЬСА || Math.abs(чОтклонениеДаты) > МАКС_ОТКЛОНЕНИЕ_ДАТЫ_ПУЛЬСА)
			{
				м_Журнал.Ой(`[Пульс] ${м_Журнал.F0(чОтклонениеВремени)} ${м_Журнал.F0(чОтклонениеДаты)}`);
			}
			_чМаксимальноеОтклонениеПульса = Math.max(_чМаксимальноеОтклонениеПульса, чОтклонениеВремени);
		}
		_чВремяНачалаПульса = чВремя;
		_чДатаНачалаПульса = чДата;
		_чТаймерПульса = setTimeout(ПроверитьПульс, ИНТЕРВАЛ_ПУЛЬСА);
	});

	function Запустить()
	{
		Проверить(_чТаймерПульса === 0);
		_чВремяНачалаПульса = performance.now();
		_чДатаНачалаПульса = Date.now();
		_чТаймерПульса = setTimeout(ПроверитьПульс, ИНТЕРВАЛ_ПУЛЬСА);
	}

	function Остановить()
	{
		if (_чТаймерПульса !== 0)
		{
			clearInterval(_чТаймерПульса);
			_чТаймерПульса = 0;
		}
	}


	return {
		Запустить, Остановить,
		ЗавершитьРаботуИПоказатьСообщение, ЗавершитьРаботуИОтправитьОтчет, ЗавершитьРаботуИОтправитьОтзыв,
		ПойманоИсключение,
		СохранитьСписокВариантов, СохранитьСписокСегментов, СохранитьТранспортныйПоток, СохранитьПреобразованныйСегмент
	};
})();

//
// ОтменаОбещания
//

function ОтменаОбещания()
{
	this._лВыполняется = false; // Для отладки.
	this._фОбработчик = null;
}

// TODO new DOMException('', 'AbortError') пока есть только в черновиках стандарта.
// Сообщение нам не нужно, поэтому используем более простой вариант.
ОтменаОбещания.ОБЕЩАНИЕ_ОТМЕНЕНО = new Error('ОБЕЩАНИЕ ОТМЕНЕНО');

ОтменаОбещания.prototype.НачалоВыполнения = function()
{
	Проверить(!this._лВыполняется);
	this._лВыполняется = true;
};

ОтменаОбещания.prototype.Отменить = function()
{
	this._лВыполняется = false;
	if (this._фОбработчик)
	{
		this._фОбработчик();
		this._фОбработчик = null;
	}
};
	
ОтменаОбещания.prototype.ЗаменитьОбработчик = function(фОбработчик)
{
	Проверить(this._лВыполняется);
	Проверить(typeof фОбработчик === 'function' || фОбработчик === null);
	this._фОбработчик = фОбработчик;
};

function Ждать(ооОтменаОбещания, чМиллисекунды)
{
	Проверить(Number.isFinite(чМиллисекунды));
	чМиллисекунды = Math.round(чМиллисекунды);
	Проверить(чМиллисекунды >= 0 && чМиллисекунды <= 0x7fffffff);
	// Если чМиллисекунды == 0, то нельзя вместо setTimeout() вызывать Promise.resolve(),
	// потому что это помешает отменить обещание сразу после вызова Ждать().
	return new Promise((фВыполнить, фОтказаться) =>
	{
		const чТаймер = setTimeout(фВыполнить, чМиллисекунды);
		if (ооОтменаОбещания)
		{
			ооОтменаОбещания.ЗаменитьОбработчик(() =>
			{
				clearTimeout(чТаймер);
				фОтказаться(ОтменаОбещания.ОБЕЩАНИЕ_ОТМЕНЕНО);
			});
		}
	});
}

//
// Сегмент
//

function Сегмент(чОбработка, пДанные, чДлительность, лРазрыв, чTwitchПрошлоВремени, чНомер)
// Существует легенда: создание объекта вызовом new ускоряет доступ к членам (смещение вместо хеша).
{
	Проверить(typeof чОбработка === 'number' && чОбработка >= ОБРАБОТКА_ЖДЕТ_ЗАГРУЗКИ && чОбработка <= ОБРАБОТКА_ПРЕОБРАЗОВАН);
	Проверить((typeof пДанные === 'number' && пДанные >= СОСТОЯНИЕ_НАЧАЛО_ТРАНСЛЯЦИИ && пДанные <= СОСТОЯНИЕ_ПОВТОР) || ЭтоОбъект(пДанные) || (typeof пДанные === 'string' && чОбработка === ОБРАБОТКА_ЖДЕТ_ЗАГРУЗКИ));

	switch (arguments.length)
	{
	case 2:
		чДлительность = 0;
		лРазрыв = true;
		чTwitchПрошлоВремени = NaN;
		//
	case 5:
		Проверить(Number.isFinite(чДлительность) && чДлительность >= 0);
		Проверить(typeof лРазрыв === 'boolean');
		Проверить(typeof чTwitchПрошлоВремени === 'number');
		чНомер = ++Сегмент._чНомер
		//
	case 6:
		Проверить(Number.isFinite(чНомер));
		break;

	default:
		Проверить(false);
	}

	if (typeof пДанные === 'number')
	{
		м_Журнал.Окак(`[Очередь] Добавлен сегмент ${чНомер} Состояние=${пДанные} Обработка=${чОбработка}`);
	}

	this.чОбработка = чОбработка;
	this.пДанные = пДанные;
	this.чДлительность = чДлительность;
	this.лРазрыв = лРазрыв;
	this.чTwitchПрошлоВремени = чTwitchПрошлоВремени;
	this.чНомер = чНомер;
}

Сегмент._чНомер = 0;

Сегмент.prototype.toString = function()
{
	if (this.пДанные === СОСТОЯНИЕ_НАЧАЛО_ТРАНСЛЯЦИИ)
	{
		return `${this.чНомер}-${this.чОбработка}-Н`;
	}
	if (this.пДанные === СОСТОЯНИЕ_ЗАВЕРШЕНИЕ_ТРАНСЛЯЦИИ)
	{
		return `${this.чНомер}-${this.чОбработка}-К`;
	}
	if (this.лРазрыв)
	{
		return `${this.чНомер}-${this.чОбработка}-Р`;
	}
	return `${this.чНомер}-${this.чОбработка}`;
};

//
// г_моОчередь
//

let г_моОчередь = [];

г_моОчередь.ПолучитьКоличествоПреобразованныхСегментов = function()
{
	var кКоличество = 0, чДлительность = 0;
	for (; кКоличество < this.length && this[кКоличество].чОбработка === ОБРАБОТКА_ПРЕОБРАЗОВАН; ++кКоличество)
	{
		if (typeof this[кКоличество].пДанные !== 'number')
		{
			чДлительность += this[кКоличество].чДлительность;
		}
	}
	return {кКоличество, чДлительность};
};

г_моОчередь.Добавить = function(оСегмент)
{
	Проверить(оСегмент instanceof Сегмент);
	for (var о of this)
	{
		Проверить(о.чНомер !== оСегмент.чНомер);
	}
	if (оСегмент.чОбработка !== ОБРАБОТКА_ПРЕОБРАЗОВАН)
	{
		// Сегменты хранятся в очереди в порядке добавления, не в порядке обработки.
		this.push(оСегмент);
	}
	else
	{
		var оПреобразовано = this.ПолучитьКоличествоПреобразованныхСегментов();
		// Сегменты воспроизводятся медленнее, чем загружаются. Возможные причины:
		// - Остановка воспроизведения из-за ошибки браузера после endOfStream().
		// - Chrome 57-58: Очень медленная работа appendBuffer() из-за ошибки браузера во время работы в фоновой вкладке.
		if (оПреобразовано.чДлительность > ПЕРЕПОЛНЕНИЕ_БУФЕРА * 1.5)
		{
			м_Отладка.ЗавершитьРаботуИПоказатьСообщение('J0208');
		}
		this.splice(оПреобразовано.кКоличество, 0, оСегмент);
	}
	return оСегмент;
};

г_моОчередь.Удалить = function(пЭлемент, кКоличество /* = 1 */)
{
	if (кКоличество === 0)
	{
		return;
	}
	if (кКоличество === undefined)
	{
		кКоличество = 1;
	}
	else
	{
		Проверить(Number.isInteger(кКоличество) && кКоличество >= 1);
	}

	if (typeof пЭлемент === 'number')
	{
		Проверить(Number.isInteger(пЭлемент) && пЭлемент >= 0);
		var чИндекс = пЭлемент;
	}
	else if ((чИндекс = this.indexOf(пЭлемент)) === -1)
	{
		Проверить(пЭлемент instanceof Сегмент);
		return;
	}

	while (--кКоличество >= 0)
	{
		Проверить(чИндекс < this.length);

		switch (this[чИндекс].чОбработка)
		{
		case ОБРАБОТКА_ЗАГРУЖАЕТСЯ:
			if (ЭтоОбъект(this[чИндекс].пДанные))
			{
				м_Журнал.Вот(`[Очередь] Отменяю загрузку ${this[чИндекс]}`);
				this[чИндекс].пДанные.Отменить();
			}
			break;

		case ОБРАБОТКА_ЗАГРУЖЕН:
			м_Помойка.Выбросить(this[чИндекс].пДанные);
			break;

		case ОБРАБОТКА_ПРЕОБРАЗОВАН:
			if (ЭтоОбъект(this[чИндекс].пДанные))
			{
				м_Помойка.Выбросить(this[чИндекс].пДанные.мбСегментИнициализации);
				м_Помойка.Выбросить(this[чИндекс].пДанные.мбМедиасегмент);
			}
			break;
		}

		м_Журнал.Вот(`[Очередь] Удаляю ${this[чИндекс]}`);
		this.splice(чИндекс, 1);
	}
};

г_моОчередь.Очистить = function()
{
	this.Удалить(0, this.length);
};

г_моОчередь.ПоказатьСостояние = function()
{
	м_Журнал.Вот(`[Очередь] ${г_моОчередь.join(' ')}`);
};

//
// ВводЧисла
//

function ВводЧисла(сИмяНастройки, чШаг, чТочность, сУзел)
{
	Проверить(чТочность >= 0);

	this._сИмяНастройки = сИмяНастройки;
	this._оПараметрыНастройки = м_Настройки.ПолучитьПараметрыНастройки(сИмяНастройки);
	this._чШаг = чШаг;
	this._чТочность = чТочность;

	this._чТаймер = 0;
	this._кИнтервал = 0;
	this._чДобавить = 0;

	this._узУзел = document.getElementById(сУзел);
	this._узУзел.addEventListener('mousedown', this);

	this._Показать();
}

ВводЧисла.prototype._Показать = function(чЗначение = м_Настройки.Получить(this._сИмяНастройки))
{
	this._узУзел.children[1].value = чЗначение === АВТОНАСТРОЙКА
		? Текст(this._оПараметрыНастройки.сАвтонастройка)
		: м_i18n.ФорматироватьЧисло(чЗначение, this._чТочность);
};

ВводЧисла.prototype.handleEvent = ДобавитьОбработчикИсключений(function(оСобытие)
{
	const ИНТЕРВАЛ_ИЗМЕНЕНИЯ_ЗНАЧЕНИЯ = 130; // Миллисекунды.

	switch (оСобытие.type)
	{
	case 'mousedown':
		if (оСобытие.button === ЛЕВАЯ_КНОПКА && this._чТаймер === 0 && м_Фокусник.ПолучитьСостояние().лАктивен)
		{
			switch (оСобытие.target.className)
			{
				case 'вводчисла-минус': this._чДобавить = -this._чШаг; break;
				case 'вводчисла-плюс':  this._чДобавить =  this._чШаг; break;
				default: return;
			}
			document.addEventListener('mouseup', this);
			м_События.ДобавитьОбработчик('фокусник-изменилосьсостояние', this);
			this._чТаймер = setInterval(() => this._ОбработатьТаймер(), ИНТЕРВАЛ_ИЗМЕНЕНИЯ_ЗНАЧЕНИЯ);
			this._кИнтервал = 0;
			this._ОбработатьТаймер();
		}
		return;

	case 'фокусник-изменилосьсостояние':
		if (оСобытие.data.лАктивен)
		{
			return;
		}
		break;
	}
			
	// Реагируем на отпускание любой кнопки.
	if (this._чТаймер !== 0)
	{
		document.removeEventListener('mouseup', this);
		м_События.УдалитьОбработчик('фокусник-изменилосьсостояние', this);
		clearInterval(this._чТаймер);
		this._чТаймер = 0;
	}
});

ВводЧисла.prototype._ОбработатьТаймер = ДобавитьОбработчикИсключений(function()
{
	const ЗАДЕРЖКА_ИЗМЕНЕНИЯ_ЗНАЧЕНИЯ = 3; // Количество ИНТЕРВАЛ_ИЗМЕНЕНИЯ_ЗНАЧЕНИЯ.

	if (++this._кИнтервал === 1 || this._кИнтервал > ЗАДЕРЖКА_ИЗМЕНЕНИЯ_ЗНАЧЕНИЯ)
	{
		const чЗначение = м_Настройки.Получить(this._сИмяНастройки);
		let чНовоеЗначение;
		if ((this._оПараметрыНастройки.сАвтонастройка && this._чДобавить < 0 && чЗначение === this._оПараметрыНастройки.чМинимальное)
		||  (this._оПараметрыНастройки.сАвтонастройка && this._чДобавить > 0 && чЗначение === this._оПараметрыНастройки.чМаксимальное))
		{
			чНовоеЗначение = АВТОНАСТРОЙКА;
		}
		else if (чЗначение === АВТОНАСТРОЙКА && this._чДобавить > 0)
		{
			чНовоеЗначение = this._оПараметрыНастройки.чМинимальное;
		}
		else if (чЗначение === АВТОНАСТРОЙКА && this._чДобавить < 0)
		{
			чНовоеЗначение = this._оПараметрыНастройки.чМаксимальное;
		}
		else
		{
			чНовоеЗначение = чЗначение + this._чДобавить;
		}
		if (чНовоеЗначение !== АВТОНАСТРОЙКА)
		{
			чНовоеЗначение = Ограничить(Округлить(чНовоеЗначение, this._чТочность), this._оПараметрыНастройки.чМинимальное, this._оПараметрыНастройки.чМаксимальное);
		}
		if (чНовоеЗначение !== чЗначение)
		{
			м_Настройки.Изменить(this._сИмяНастройки, чНовоеЗначение);
			this._Показать(чНовоеЗначение);
			this.ПослеИзменения(чНовоеЗначение);
		}
	}
});

ВводЧисла.prototype.Обновить = function()
// Вызвать, если настройка, к которой привязан объект, была изменена.
{
	this._Показать();
};

ВводЧисла.prototype.ПослеИзменения = ЗАГЛУШКА;

const м_Помойка = (() =>
{
	function ПомойкаВКаналеСообщений()
	{
		this._оПомойка = null;
	}

	ПомойкаВКаналеСообщений.prototype.Выбросить = function(оБарахло)
	// HACK Освобождение памяти посылкой transferable буфера в disentangled порт.
	// https://html.spec.whatwg.org/multipage/comms.html#dom-messageport-postmessage
	{
		if (ЭтоОбъект(оБарахло))
		{
			if (оБарахло.buffer)
			{
				оБарахло = оБарахло.buffer;
			}
			if (оБарахло.byteLength)
			{
				м_Журнал.Вот(`[Помойка] Выбрасываю ${оБарахло.byteLength} байтов`);
				if (this._оПомойка === null)
				{
					this._оПомойка = new MessageChannel();
					this._оПомойка.port2.close();
				}
				this._оПомойка.port1.postMessage(оБарахло, [оБарахло]);
			}
		}
	};

	ПомойкаВКаналеСообщений.prototype.Сжечь = function()
	{
		this._оПомойка = null;
	};

	function ПомойкаВРабочемПотоке()
	{
		this._сАдрес = '';
		this._оПомойка = null;
		this._кбВПомойке = 0;
	}

	ПомойкаВРабочемПотоке.prototype.Выбросить = function(оБарахло)
	// HACK Для освобождение памяти transferable буфер посылается в рабочий поток, затем рабочий
	// поток уничтожается, что приводит к быстрому сбору всего мусора, который в нем накопился.
	{
		const ВМЕСТИМОСТЬ_ПОМОЙКИ = 10000000; // Байты.
		if (ЭтоОбъект(оБарахло))
		{
			if (оБарахло.buffer)
			{
				оБарахло = оБарахло.buffer;
			}
			if (оБарахло.byteLength)
			{
				м_Журнал.Вот(`[Помойка] Выбрасываю ${оБарахло.byteLength} байтов`);
				if (this._оПомойка === null)
				{
					if (this._сАдрес === '')
					{
						this._сАдрес = URL.createObjectURL(new Blob(
							[`
								'use strict';
								self.onmessage = оСобытие =>
								{
									if (!оСобытие.data)
									{
										self.close();
									}
								};
							`],
							{type: 'application/javascript'}
						));
					}
					this._оПомойка = new Worker(this._сАдрес);
				}
				this._кбВПомойке += оБарахло.byteLength;
				this._оПомойка.postMessage(оБарахло, [оБарахло]);
				if (this._кбВПомойке > ВМЕСТИМОСТЬ_ПОМОЙКИ)
				{
					this.Сжечь();
				}
			}
		}
	};

	ПомойкаВРабочемПотоке.prototype.Сжечь = function()
	{
		if (this._оПомойка !== null)
		{
			м_Журнал.Вот(`[Помойка] Сжигаю ${this._кбВПомойке} байтов`);
			// terminate() не подходит, нужно дождаться когда барахло попадет в рабочий поток.
			this._оПомойка.postMessage(null);
			this._оПомойка = null;
			this._кбВПомойке = 0;
		}
	};

	function ПомойкаОтсутствует() {}
	ПомойкаОтсутствует.prototype.Выбросить = ЗАГЛУШКА;
	ПомойкаОтсутствует.prototype.Сжечь = ЗАГЛУШКА;

	// В Chrome 64 уже нет проблем с освобожданием памяти. Точно не знаю в какой версии это исправили.
	return new ПомойкаОтсутствует();
})();

const м_События = (() =>
{
	var _Обработчики = new Map();

	function ДобавитьОбработчик(сСобытие, фОбработчик)
	{
		Проверить(ЭтоНепустаяСтрока(сСобытие));
		Проверить(typeof фОбработчик === 'function' || ЭтоОбъект(фОбработчик));
		var мноСобытие = _Обработчики.get(сСобытие);
		if (мноСобытие === undefined)
		{
			мноСобытие = new Set();
			_Обработчики.set(сСобытие, мноСобытие);
		}
		мноСобытие.add(фОбработчик);
	}

	function УдалитьОбработчик(сСобытие, фОбработчик)
	{
		Проверить(ЭтоНепустаяСтрока(сСобытие));
		Проверить(typeof фОбработчик === 'function' || ЭтоОбъект(фОбработчик));
		var мноСобытие = _Обработчики.get(сСобытие);
		if (мноСобытие !== undefined)
		{
			мноСобытие.delete(фОбработчик);
			if (мноСобытие.size === 0)
			{
				_Обработчики.delete(сСобытие);
			}
		}
	}

	function ОбработатьСобытие(сСобытие, пДанные)
	{
		if (г_лРаботаЗавершена)
		{
			return;
		}
		Проверить(ЭтоНепустаяСтрока(сСобытие));
		м_Журнал.Вот(`[События] Произошло событие ${сСобытие}`);
		const мноСобытие = _Обработчики.get(сСобытие);
		if (мноСобытие !== undefined)
		{
			Проверить(мноСобытие.size !== 0);
			for (var фОбработчик of мноСобытие.values())
			{
				if (typeof фОбработчик === 'function')
				{
					фОбработчик(сСобытие, пДанные);
				}
				else
				{
					if (оСобытие === undefined)
					{
						var оСобытие =
						{
							type: сСобытие,
							data: пДанные
						};
					}
					фОбработчик.handleEvent(оСобытие);
				}
			}
		}
	}

	return {
		ДобавитьОбработчик,
		УдалитьОбработчик,
		ОбработатьСобытие
	};
})();

const м_Фокусник = (() =>
{
	var _оСостояние = null;

	function ПолучитьСостояние()
	{
		return _оСостояние;
	}

	function ПолучитьНовоеСостояние()
	{
		const лПоказан = !document.hidden;
		const лАктивен = лПоказан && document.hasFocus();
		return {лПоказан, лАктивен};
	}

	const ОбновитьСостояние = ДобавитьОбработчикИсключений(() =>
	{
		const оНовоеСостояние = ПолучитьНовоеСостояние();
		if (_оСостояние.лПоказан !== оНовоеСостояние.лПоказан || _оСостояние.лАктивен !== оНовоеСостояние.лАктивен)
		{
			м_Журнал.Окак(`[Фокусник] Новое состояние ${м_Журнал.O(оНовоеСостояние)}`);
			_оСостояние = оНовоеСостояние;
			м_События.ОбработатьСобытие('фокусник-изменилосьсостояние', оНовоеСостояние);
		}
	});

	const ОбработатьСобытие = ДобавитьОбработчикИсключений(оСобытие =>
	{
		м_Журнал.Вот(`[Фокусник] Событие ${оСобытие.type}, старое состояние ${м_Журнал.O(_оСостояние)}`);
		// https://bugs.chromium.org/p/chromium/issues/detail?id=654908
		setImmediate(ОбновитьСостояние);
	});

	document.addEventListener('visibilitychange', ОбработатьСобытие);
	window.addEventListener('focus', ОбработатьСобытие);
	window.addEventListener('blur', ОбработатьСобытие);

	_оСостояние = ПолучитьНовоеСостояние();
	м_Журнал.Вот(`[Фокусник] Начальное состояние ${м_Журнал.O(_оСостояние)}`);

	return {ПолучитьСостояние};
})();

const м_Тащилка = (() =>
// Edge 16, вопреки стандарту, во время перетаскивания не подавляет события клавиатуры.
{
	const МИНИМАЛЬНЫЙ_ИНТЕРВАЛ_DRAGOVER = 50; // Миллисекунды.

	let _амОбработчики = new Map();

	let _узТащится = null;
	let _фОбработчик;
	let _чВремяПоследнегоDragOver;
	let _чМышьX1, _чМышьY1;
	let _чМышьX2, _чМышьY2;

	let _чОкноX, _чОкноY;

	function ИзменитьПоложениеОкна(чШаг, узТащится, чИзменениеX, чИзменениеY)
	{
		switch (чШаг)
		{
		case 1:
			const оСтиль = getComputedStyle(узТащится);
			_чОкноX = Number.parseInt(оСтиль.left, 10);
			_чОкноY = Number.parseInt(оСтиль.top,  10);
			break;

		case 2:
			узТащится.style.left = `${_чОкноX - чИзменениеX}px`;
			узТащится.style.top  = `${_чОкноY - чИзменениеY}px`;
			break;

		case 3:
			break;

		default:
			Проверить(false);
		}
	}

	const ОбработатьDragStart = ДобавитьОбработчикИсключений(оСобытие =>
	{
		Проверить(_узТащится === null);
		const узТащится = оСобытие.target;
		_фОбработчик = _амОбработчики.get(узТащится.id);
		// Тащить могут ссылку, текст, и даже кнопку из панели инструментов (Firefox 44).
		// Не вызывать оСобытие.preventDefault(), чтобы не мешать перетаскивать ссылки и текст средствами браузера.
		if (_фОбработчик)
		{
			_узТащится = узТащится;
			м_Журнал.Окак(`[Тащилка] Начинаю тащить ${_узТащится.id} X=${оСобытие.clientX} Y=${оСобытие.clientY}`);
			Проверить(_узТащится.getAttribute('draggable') === 'true');
			// Задержка для Chrome 59. Другим браузерам тоже не повредит.
			setImmediate(() =>
			{
				if (_узТащится)
				{
					document.body.classList.add('js-тащилка-страница');
				}
			});
			_узТащится.classList.add('js-тащилка-элемент');
			_фОбработчик(1, _узТащится);
			_чВремяПоследнегоDragOver = 0;
			_чМышьX1 = _чМышьX2 = оСобытие.clientX;
			_чМышьY1 = _чМышьY2 = оСобытие.clientY;
			// Firefox 44: Без этой строки перетаскивание не начнется.
			// Edge 15 поддерживает только текст.
			оСобытие.dataTransfer.setData('text', '');
			оСобытие.dataTransfer.effectAllowed = 'move';
			// Не рисовать перетаскиваемый элемент.
			if (оСобытие.dataTransfer.setDragImage)
			{
				// document.head невидимый.
				оСобытие.dataTransfer.setDragImage(document.head, 0, 0);
			}
			else
			{
				// HACK Edge 15 не поддерживает setDragImage(). Кратковременное скрытие выглядит
				// не слишком красиво, но это единственный способ.
				узТащится.classList.add('js-тащилка-скрыть');
				setImmediate(() =>
				{
					// Переменная _узТащится уже может быть изменена.
					узТащится.classList.remove('js-тащилка-скрыть');
				});
			}
		}
	});

	const ОбработатьDragEnterИDrop = ДобавитьОбработчикИсключений(оСобытие =>
	{
		if (_узТащится)
		{
			оСобытие.preventDefault();
		}
	});

	const ОбработатьDragOver = ДобавитьОбработчикИсключений(оСобытие =>
	{
		if (_узТащится)
		{
			оСобытие.preventDefault();

			// Как и mousemove, событие dragover посылается с очень высокой частотой,
			// не давая процессору заниматься более важными вещами.
			const чВремя = performance.now();
			if (чВремя - _чВремяПоследнегоDragOver < МИНИМАЛЬНЫЙ_ИНТЕРВАЛ_DRAGOVER)
			{
				return;
			}
			_чВремяПоследнегоDragOver = чВремя;

			const лИзменилсяX = _чМышьX2 !== оСобытие.clientX;
			const лИзменилсяY = _чМышьY2 !== оСобытие.clientY;
			if (лИзменилсяX || лИзменилсяY)
			{
				_чМышьX2 = оСобытие.clientX;
				_чМышьY2 = оСобытие.clientY;
				_фОбработчик(2, _узТащится, _чМышьX1 - _чМышьX2, _чМышьY1 - _чМышьY2, лИзменилсяX, лИзменилсяY);
			}
		}
	});

	const ОбработатьDragEnd = ДобавитьОбработчикИсключений(оСобытие =>
	{
		if (_узТащится)
		{
			м_Журнал.Окак(`[Тащилка] Заканчиваю тащить ${_узТащится.id} X=${_чМышьX2} Y=${_чМышьY2} dropEffect=${оСобытие.dataTransfer.dropEffect}`);
			// Firefox 59: dropEffect всегда не равен none.
			// Edge 16: dropEffect всегда равен none.
			ЗавершитьПеретаскивание(false);
		}
	});

	function ОтменитьПеретаскивание(сИдентификаторУзла)
	{
		Проверить(сИдентификаторУзла === undefined || ЭтоНепустаяСтрока(сИдентификаторУзла));
		if (_узТащится && (сИдентификаторУзла === undefined || сИдентификаторУзла === _узТащится.id))
		{
			м_Журнал.Окак(`[Тащилка] Отказываюсь тащить ${_узТащится.id}`);
			ЗавершитьПеретаскивание(true);
		}
	}

	function ЗавершитьПеретаскивание(лОтмена)
	// В API нет способа программно отменить перетаскивание.
	// лОтмена можно передавать в _фОбработчик.
	{
		_фОбработчик(3, _узТащится);
		document.body.classList.remove('js-тащилка-страница');
		_узТащится.classList.remove('js-тащилка-элемент');
		_узТащится = null;
	}

	function ДобавитьОбработчик(сИдентификаторУзла, фОбработчик)
	{
		if (фОбработчик === null)
		{
			фОбработчик = ИзменитьПоложениеОкна;
		}
		Проверить(typeof фОбработчик === 'function');
		const узУзел = document.getElementById(сИдентификаторУзла);
		узУзел.setAttribute('draggable', 'true');
		_амОбработчики.set(сИдентификаторУзла, фОбработчик);
		if (_амОбработчики.size === 1)
		{
			document.addEventListener('dragstart', ОбработатьDragStart);
			document.addEventListener('dragenter', ОбработатьDragEnterИDrop);
			document.addEventListener('dragover', ОбработатьDragOver);
			document.addEventListener('drop', ОбработатьDragEnterИDrop);
			document.addEventListener('dragend', ОбработатьDragEnd);
		}
		return узУзел;
	}

	return {
		ДобавитьОбработчик,
		ОтменитьПеретаскивание
	};
})();

const м_Оформление = (() =>
{
	const СЕЛЕКТОР_ВВОДА_ЦВЕТА = 'input[type="color"]';

	var _сШаблон       = '';
	var _оПрозрачность = null;

	function ОбновитьОкноНастроек()
	{
		for (var узКнопка of document.querySelectorAll(СЕЛЕКТОР_ВВОДА_ЦВЕТА))
		{
			узКнопка.value = м_Настройки.Получить(узКнопка.id);
		}
		_оПрозрачность.Обновить();
	}

	const ОбработатьВводЦвета = ДобавитьОбработчикИсключений(оСобытие =>
	// Это событие послает пока только Firefox.
	{
		if (оСобытие.target.matches(СЕЛЕКТОР_ВВОДА_ЦВЕТА))
		{
			ОбновитьСтили();
		}
	});

	const ОбработатьИзменениеЦвета = ДобавитьОбработчикИсключений(оСобытие =>
	{
		if (оСобытие.target.matches(СЕЛЕКТОР_ВВОДА_ЦВЕТА))
		{
			м_Настройки.Изменить(оСобытие.target.id, оСобытие.target.value);
		}
	});

	function ЗаполнитьШаблон(сШаблон, оПеременные)
	{
		return сШаблон.replace(/{{.*?}}/g, сИмя =>
		{
			const пЗначение = оПеременные[сИмя.slice(2, -2)];
			if (typeof пЗначение === 'string')
			{
				return пЗначение;
			}
			Проверить(Number.isFinite(пЗначение));
			// 2 знака для opacity.
			return String(Округлить(пЗначение, 2));
		});
	}

	function ОбновитьСтили()
	{
		Проверить(_сШаблон);

		const чНепрозрачность = 1 - м_Настройки.Получить('чПрозрачность') / 100;
		const оПеременные =
		{
			чНепрозрачность: чНепрозрачность,
			чНепрозрачностьОкна: Ограничить(чНепрозрачность, 0.85, 1)
		};

		for (var узКнопка of document.querySelectorAll(СЕЛЕКТОР_ВВОДА_ЦВЕТА))
		{
			оПеременные[узКнопка.id] =
				Number.parseInt(узКнопка.value.slice(1, 3), 16) + ',' +
				Number.parseInt(узКнопка.value.slice(3, 5), 16) + ',' +
				Number.parseInt(узКнопка.value.slice(5, 7), 16);
		}

		
		document.getElementById('стиль').textContent = ЗаполнитьШаблон(_сШаблон, оПеременные);
	}

	function ОбработатьИзменениеПредустановкиОформления()
	{
		ОбновитьОкноНастроек();
		ОбновитьСтили();
	}

	function Запустить()
	{
		_оПрозрачность = new ВводЧисла('чПрозрачность', 5, 0, 'прозрачность');
		_оПрозрачность.ПослеИзменения = ОбновитьСтили;

		document.addEventListener('input', ОбработатьВводЦвета);
		document.addEventListener('change', ОбработатьИзменениеЦвета);

		м_События.ДобавитьОбработчик('настройки-измениласьпредустановка-оформление', ОбработатьИзменениеПредустановкиОформления);
		ОбработатьИзменениеПредустановкиОформления();
	}

	function ЗапуститьАсинхронно()
	{
		return м_Загрузчик.ЗагрузитьТекст(null, chrome.extension.getURL('player.css'), 0, 'шаблон', false)
		.then(сРезультат =>
		{
			Проверить(!_сШаблон && сРезультат);
			_сШаблон = сРезультат;
		});
	}
	
	return {ЗапуститьАсинхронно, Запустить};
})();

const м_Настройки = (() =>
{
	/***
	ВЕРСИЯ_НАСТРОЕК  Версия расширения  Изменения
	              1         2017.09.11  Добавлены предустановки
	              2         2017.11.06  чПоложениеПанелиЧата +ЛЕВАЯ_СТОРОНА +ВЕРХНЯЯ_СТОРОНА
	              2         2018.01.07  Добавлена проверка значений
	              2         2018.03.17  Добавлена лЗатемнитьЧат
	              2         2018.04.06  Добавлены чСостояниеЗакрытогоЧата, лАвтоПоложениеЧата, чГоризонтальноеПоложениеЧата, чВертикальноеПоложениеЧата, чИнтервалАвтоскрытия
	              2         2018.05.18  Добавлена лПолноценныйЧат
	***/
	const ВЕРСИЯ_НАСТРОЕК = 2;

	const _амПредустановкиБуферизации = new Map(
	[
		[
			'J0126',
			{
				кОдновременныхЗагрузок: 1,
				чНачалоВоспроизведения: 3,
				чРазмерБуфера:          5,
				чРастягиваниеБуфера:    15,
				кЗаначка:               0,
				чИнтервалОпроса:        МИН_ИНТЕРВАЛ_ОБНОВЛЕНИЯ_СПИСКОВ
			}
		],
		[
			'J0127',
			{
				кОдновременныхЗагрузок: 2,
				чНачалоВоспроизведения: 3,   // 1..2 сегментов.
				чРазмерБуфера:          8.5, // 3..5 сегментов.
				чРастягиваниеБуфера:    20,
				кЗаначка:               1,
				чИнтервалОпроса:        АВТОНАСТРОЙКА
			}
		],
		[
			'J0128',
			{
				кОдновременныхЗагрузок: 2,
				чНачалоВоспроизведения: 17,
				чРазмерБуфера:          9.5,
				чРастягиваниеБуфера:    30,
				кЗаначка:               0,
				чИнтервалОпроса:        АВТОНАСТРОЙКА
			}
		]
	]);

	const _амПредустановкиОформления = new Map(
	[
		[
			'J0122',
			{
				сЦветФона:      '#282828',
				сЦветГрадиента: '#ffffff',
				сЦветКнопок:    '#d3be96',
				сЦветЗаголовка: '#cdbdec',
				сЦветВыделения: '#ff9428',
				чПрозрачность:  25
			}
		],
		[
			'J0121',
			{
				сЦветФона:      '#425e7b',
				сЦветГрадиента: '#ffffff',
				сЦветКнопок:    '#ffffff',
				сЦветЗаголовка: '#d1f0fa',
				сЦветВыделения: '#ffaa33',
				чПрозрачность:  30
			}
		],
		[
			'J0138',
			{
				сЦветФона:      '#4b4b4b',
				сЦветГрадиента: '#aaaaaa',
				сЦветКнопок:    '#bad4f8',
				сЦветЗаголовка: '#e2ebb4',
				сЦветВыделения: '#75a9f0',
				чПрозрачность:  5
			}
		],
		[
			'J0125',
			{
				сЦветФона:      '#141414',
				сЦветГрадиента: '#c8c8c8',
				сЦветКнопок:    '#f0f0f0',
				сЦветЗаголовка: '#b6c3c3',
				сЦветВыделения: '#6cb6ff',
				чПрозрачность:  10
			}
		]
	]);

	const _моМетаданныеПредустановок =
	[
		{
			амДанные:       _амПредустановкиБуферизации,
			сНастраиваемая: 'J0129',
			сВыбрана:       'сПредустановкаВыбрана_буферизация',
			сЗаполнена:     'лПредустановкаЗаполнена_буферизация',
			сСписок:        'предустановка-буферизация',
			сСобытие:       'настройки-измениласьпредустановка-буферизация'
		},
		{
			амДанные:       _амПредустановкиОформления,
			сНастраиваемая: 'J0123',
			сВыбрана:       'сПредустановкаВыбрана_оформление',
			сЗаполнена:     'лПредустановкаЗаполнена_оформление',
			сСписок:        'предустановка-оформление',
			сСобытие:       'настройки-измениласьпредустановка-оформление'
		}
	];

	const _мноПостоянныеНастройки = new Set(
	[
		'чСлучайноеЧисло',
		'сПредыдущаяВерсия',
		'чВерсияНастроек'
	]);

	function Настройка(пНачальное, мпПеречисление, чМинимальное, чМаксимальное, сАвтонастройка)
	{
		this.пТекущее = undefined;
		this.пНачальное = пНачальное;
		this.мпПеречисление = мпПеречисление;
		this.чМинимальное = чМинимальное;
		this.чМаксимальное = чМаксимальное;
		this.сАвтонастройка = сАвтонастройка;
	}

	Настройка.Создать = function(пНачальное)
	{
		return new this(пНачальное, null, МИН_ЗНАЧЕНИЕ_НАСТРОЙКИ, МАКС_ЗНАЧЕНИЕ_НАСТРОЙКИ, '');
	};

	Настройка.СоздатьПеречисление = function(пНачальное, мпПеречисление)
	{
		return new this(пНачальное, мпПеречисление, МИН_ЗНАЧЕНИЕ_НАСТРОЙКИ, МАКС_ЗНАЧЕНИЕ_НАСТРОЙКИ, '');
	};

	Настройка.СоздатьДиапазон = function(пНачальное, чМинимальное, чМаксимальное, сАвтонастройка = '')
	{
		return new this(пНачальное, null, чМинимальное, чМаксимальное, сАвтонастройка);
	};

	Настройка.ПроверитьЗначение = function(пЗначение)
	// В отладочных данных настройки хранятся в JSON.
	// Object и null в значениях запрещены.
	{
		Проверить(
			   пЗначение === пЗначение
			&& пЗначение !== Infinity
			&& пЗначение !== -Infinity
			&& пЗначение !== undefined
			&& typeof пЗначение !== 'function'
			&& typeof пЗначение !== 'symbol'
			&& typeof пЗначение !== 'object'
		);
	}

	Настройка.prototype.ИсправитьЗначение = function(пЗначение)
	{
		Настройка.ПроверитьЗначение(пЗначение);
		Проверить(typeof пЗначение === typeof this.пНачальное);
		if (this.мпПеречисление)
		{
			if (!this.мпПеречисление.includes(пЗначение))
			{
				пЗначение = this.пНачальное;
			}
		}
		else if (typeof пЗначение === 'number')
		{
			if (пЗначение === АВТОНАСТРОЙКА)
			{
				if (this.сАвтонастройка === '')
				{
					пЗначение = this.пНачальное;
				}
			}
			else if (пЗначение < this.чМинимальное)
			{
				пЗначение = this.чМинимальное;
			}
			else if (пЗначение > this.чМаксимальное)
			{
				пЗначение = this.чМаксимальное;
			}
		}
		return пЗначение;
	}

	const _оНастройки =
	{
		чСлучайноеЧисло:                     Настройка.Создать(Math.random()),
		сПредыдущаяВерсия:                   Настройка.Создать('2000.1.1'),
		чВерсияНастроек:                     Настройка.Создать(ВЕРСИЯ_НАСТРОЕК),
		чГромкость2:                         Настройка.СоздатьДиапазон(МАКСИМАЛЬНАЯ_ГРОМКОСТЬ / 2, МИНИМАЛЬНАЯ_ГРОМКОСТЬ, МАКСИМАЛЬНАЯ_ГРОМКОСТЬ), // Проценты.
		лПриглушить:                         Настройка.Создать(false),
		сНазваниеВарианта:                   Настройка.Создать('CoolCmd'),
		чДлительностьПовтора2:               Настройка.СоздатьДиапазон(60, МИН_ДЛИТЕЛЬНОСТЬ_ПОВТОРА, МАКС_ДЛИТЕЛЬНОСТЬ_ПОВТОРА, 'J0124'), // Секунды.
		чСостояниеЧата:                      Настройка.СоздатьПеречисление(ЧАТ_ВЫГРУЖЕН, [ЧАТ_ВЫГРУЖЕН, ЧАТ_СКРЫТ, ЧАТ_ПАНЕЛЬ]),
		чСостояниеЗакрытогоЧата:             Настройка.СоздатьПеречисление(ЧАТ_ВЫГРУЖЕН, [ЧАТ_ВЫГРУЖЕН, ЧАТ_СКРЫТ]),
		лАвтоПоложениеЧата:                  Настройка.Создать(false),
		чГоризонтальноеПоложениеЧата:        Настройка.СоздатьПеречисление(ПРАВАЯ_СТОРОНА, [ПРАВАЯ_СТОРОНА, ЛЕВАЯ_СТОРОНА]),
		чВертикальноеПоложениеЧата:          Настройка.СоздатьПеречисление(НИЖНЯЯ_СТОРОНА, [ВЕРХНЯЯ_СТОРОНА, НИЖНЯЯ_СТОРОНА]),
		чПоложениеПанелиЧата:                Настройка.СоздатьПеречисление(ПРАВАЯ_СТОРОНА, [ВЕРХНЯЯ_СТОРОНА, ПРАВАЯ_СТОРОНА, НИЖНЯЯ_СТОРОНА, ЛЕВАЯ_СТОРОНА]),
		                                     // Минимальный размер задается в player.css.
		чШиринаПанелиЧата:                   Настройка.СоздатьДиапазон(340, 100, МАКС_ЗНАЧЕНИЕ_НАСТРОЙКИ), // CSS пикселы.
		                                     // Минимальный размер задается в player.css.
		                                     // Должна влезать покупка bits.
		чВысотаПанелиЧата:                   Настройка.СоздатьДиапазон(310, 100, МАКС_ЗНАЧЕНИЕ_НАСТРОЙКИ), // CSS пикселы.
		лПолноценныйЧат:                     Настройка.Создать(true),
		лЗатемнитьЧат:                       Настройка.Создать(false),
		чРазмерИнтерфейса:                   Настройка.СоздатьДиапазон(100, 75, 200),
		чИнтервалАвтоскрытия:                Настройка.СоздатьДиапазон(4, 0.5, 60),
		лАнимацияИнтерфейса:                 Настройка.Создать(true),
		лМенятьГромкостьКолесом:             Настройка.Создать(true),
		лПоказатьСтатистику:                 Настройка.Создать(false),
		//
		// Предустановки буферизации.
		//
		сПредустановкаВыбрана_буферизация:   Настройка.Создать('J0127'),
		лПредустановкаЗаполнена_буферизация: Настройка.Создать(false),
		кОдновременныхЗагрузок:              Настройка.СоздатьДиапазон(0, 1, 3), // Сегменты.
		                                     // TODO Измерять в сегментах?
		чНачалоВоспроизведения:              Настройка.СоздатьДиапазон(0, МИН_РАЗМЕР_БУФЕРА, МАКС_РАЗМЕР_БУФЕРА), // Секунды.
		                                     // TODO Измерять в сегментах?
		                                     // TODO Добавить зависимость от кОдновременныхЗагрузок?
		                                     // TODO Можно сделать 2 значения и постепенный рост с первого до второго.
		чРазмерБуфера:                       Настройка.СоздатьДиапазон(0, МИН_РАЗМЕР_БУФЕРА, МАКС_РАЗМЕР_БУФЕРА), // Секунды.
		                                     // TODO Измерять в сегментах?
		чРастягиваниеБуфера:                 Настройка.СоздатьДиапазон(0, МИН_РАСТЯГИВАНИЕ_БУФЕРА, МАКС_РАСТЯГИВАНИЕ_БУФЕРА), // Секунды.
		                                     // TODO Измерять в секундах и ограничить по времени.
		кЗаначка:                            Настройка.СоздатьДиапазон(0, 0, 2), // Сегменты.
		чИнтервалОпроса:                     Настройка.СоздатьДиапазон(0, МИН_ИНТЕРВАЛ_ОБНОВЛЕНИЯ_СПИСКОВ, 250, 'J0120'), // Проценты.
		//
		// Предустановки оформления.
		//
		сПредустановкаВыбрана_оформление:    Настройка.Создать('J0122'),
		лПредустановкаЗаполнена_оформление:  Настройка.Создать(false),
		сЦветФона:                           Настройка.Создать(''),
		сЦветГрадиента:                      Настройка.Создать('#ffffff'),
		сЦветКнопок:                         Настройка.Создать(''),
		сЦветЗаголовка:                      Настройка.Создать(''),
		сЦветВыделения:                      Настройка.Создать(''),
		чПрозрачность:                       Настройка.СоздатьДиапазон(0, 0, 80)
	};
	
	const ОТКЛАДЫВАТЬ_СОХРАНЕНИЕ_НА = 500; // Миллисекунды. Не увеличивать слишком сильно, чтобы новое
	                                       // окно с проигрывателем не подхватило старые настройки.
	let _чТаймерОтложенногоСохранения = 0;
	let _оОтложенноеСохранение = null;

	function ПроверитьРезультатСохранения()
	{
		if (chrome.runtime.lastError)
		{
			console.error(chrome.runtime.lastError.message);
			м_Отладка.ЗавершитьРаботуИПоказатьСообщение('J0212');
		}
	}

	function Сохранить(оСохранить, лОстальноеУдалить)
	{
		if (лОстальноеУдалить)
		{
			chrome.storage.local.clear(ПроверитьРезультатСохранения);
			м_Журнал.Вот('[Настройки] Все настройки удалены из хранилища');
		}
		chrome.storage.local.set(оСохранить, ПроверитьРезультатСохранения);
		м_Журнал.Вот(`[Настройки] Настройки записаны в хранилище: ${м_Журнал.O(оСохранить)}`);
	}

	function Восстановить()
	{
		м_Журнал.Вот('[Настройки] Восстанавливаю настройки');
		return new Promise((фВыполнить, фОтказаться) =>
		{
			chrome.storage.local.get(null, оВосстановленныеНастройки =>
			{
				try
				{
					if (chrome.runtime.lastError)
					{
						console.error(chrome.runtime.lastError.message);
						м_Отладка.ЗавершитьРаботуИПоказатьСообщение('J0209');
					}
					else
					{
						м_Журнал.Вот(`[Настройки] Настройки прочитаны из хранилища: ${м_Журнал.O(оВосстановленныеНастройки)}`);
						ЗавершитьВосстановление(оВосстановленныеНастройки);
						фВыполнить();
					}
				}
				catch (пИсключение)
				{
					фОтказаться(пИсключение);
				}
			});
		});
	}

	function НачатьСохранение(оСохранить, лОстальноеУдалить)
	// Функция не позволяет сбрасывать настройки на диск слишком часто. Например, громкость может изменяться каждую миллисекунду.
	// Также функция объединяет последовательность вызовов Изменить() в одну атомарную операцию сохранения.
	// Меняет оСохранить.
	{
		Проверить(ЭтоОбъект(оСохранить));
		if (!лОстальноеУдалить && Object.keys(оСохранить).length === 0)
		{
			return;
		}
		if (_чТаймерОтложенногоСохранения === 0)
		{
			if (лОстальноеУдалить)
			{
				Сохранить(оСохранить, лОстальноеУдалить);
			}
			else
			{
				м_Журнал.Вот(`[Настройки] Откладываю сохранение настроек на ${ОТКЛАДЫВАТЬ_СОХРАНЕНИЕ_НА}мс`);
				_чТаймерОтложенногоСохранения = setTimeout(ЗавершитьОтложенноеСохранение, ОТКЛАДЫВАТЬ_СОХРАНЕНИЕ_НА);
				_оОтложенноеСохранение = оСохранить;
			}
		}
		else
		{
			if (лОстальноеУдалить)
			{
				clearTimeout(_чТаймерОтложенногоСохранения);
				_чТаймерОтложенногоСохранения = 0;
				_оОтложенноеСохранение = null;
				Сохранить(оСохранить, лОстальноеУдалить);
			}
			else
			{
				Object.assign(_оОтложенноеСохранение, оСохранить);
			}
		}
	}

	const ЗавершитьОтложенноеСохранение = ДобавитьОбработчикИсключений(() =>
	{
		м_Журнал.Вот('[Настройки] Завершаю отложенное сохранение');
		Проверить(_чТаймерОтложенногоСохранения !== 0 && ЭтоОбъект(_оОтложенноеСохранение));
		Сохранить(_оОтложенноеСохранение, false);
		_чТаймерОтложенногоСохранения = 0;
		_оОтложенноеСохранение = null;
	});

	function Остановить()
	{
		if (_чТаймерОтложенногоСохранения !== 0)
		{
			clearTimeout(_чТаймерОтложенногоСохранения);
			ЗавершитьОтложенноеСохранение();
		}
	}

	function ПроверитьВерсиюНастроек(оНастройки, оСохранить)
	// оНастройки и оСохранить могут указывать на один объект, если информация в оСохранить не нужна.
	// Возвращает true, если версия настроек не совместима с ВЕРСИЯ_НАСТРОЕК, большая часть настроек
	// удалена, и их также необходимо удалить из хранилища расширения.
	{
		// Это ранняя версия расширения без чВерсияНастроек или первый запуск расширения после установки?
		if (оНастройки.чВерсияНастроек === undefined)
		{
			// Оставляем только постоянные настройки, формат которых пока не менялся.
			for (let сИмя of Object.keys(оНастройки))
			{
				if (_мноПостоянныеНастройки.has(сИмя))
				{
					оСохранить[сИмя] = оНастройки[сИмя];
				}
				else
				{
					delete оНастройки[сИмя];
				}
			}
			return true;
		}

		// Был сделан переход на расширение более ранней версии? Совместимость настроек в этом случае
		// не поддерживается. Удаляем все настройки.
		if (оНастройки.чВерсияНастроек > ВЕРСИЯ_НАСТРОЕК)
		{
			for (let сИмя of Object.keys(оНастройки))
			{
				delete оНастройки[сИмя];
			}
			return true;
		}

		// Проверить имена выбранных предустановок. С этой проверкой добавлять
		// и удалять предустановки можно не изменяя ВЕРСИЯ_НАСТРОЕК.
		for (let оМетаданные of _моМетаданныеПредустановок)
		{
			let сИмя = оНастройки[оМетаданные.сВыбрана];
			if (сИмя !== undefined && сИмя !== оМетаданные.сНастраиваемая)
			{
				for (let сИмяПредустановки of оМетаданные.амДанные.keys())
				{
					if (сИмя === сИмяПредустановки)
					{
						сИмя = undefined;
						break;
					}
				}
				if (сИмя !== undefined)
				{
					оСохранить[оМетаданные.сВыбрана] = оНастройки[оМетаданные.сВыбрана] = _оНастройки[оМетаданные.сВыбрана].пНачальное;
				}
			}
		}

		// В ранних версиях не было настройки чСостояниеЗакрытогоЧата.
		if (оНастройки.чСостояниеЗакрытогоЧата !== оНастройки.чСостояниеЧата
		&& (оНастройки.чСостояниеЧата === ЧАТ_ВЫГРУЖЕН || оНастройки.чСостояниеЧата === ЧАТ_СКРЫТ))
		{
			оСохранить.чСостояниеЗакрытогоЧата = оНастройки.чСостояниеЗакрытогоЧата = оНастройки.чСостояниеЧата;
		}

		if (оНастройки.чВерсияНастроек === ВЕРСИЯ_НАСТРОЕК)
		{
			return false;
		}

		// Сюда можно добавить преобразование настроек старых версий.

		оСохранить.чВерсияНастроек = оНастройки.чВерсияНастроек = ВЕРСИЯ_НАСТРОЕК;
		return false;
	}

	function ЗавершитьВосстановление(оВосстановленныеНастройки)
	{
		Проверить(ЭтоОбъект(оВосстановленныеНастройки));
		Проверить(!_оНастройки.чВерсияНастроек.пТекущее);

		const оСохранить = {};
		const лОстальноеУдалить = ПроверитьВерсиюНастроек(оВосстановленныеНастройки, оСохранить);

		// Не переносим устаревшие настройки, добавляем новые, добавляем и сохраняем постоянные и исправленные.
		for (let сИмя of Object.keys(_оНастройки))
		{
			if (оВосстановленныеНастройки.hasOwnProperty(сИмя))
			{
				const пЗначение = _оНастройки[сИмя].ИсправитьЗначение(оВосстановленныеНастройки[сИмя]);
				if (пЗначение !== оВосстановленныеНастройки[сИмя])
				{
					оСохранить[сИмя] = пЗначение;
				}
				_оНастройки[сИмя].пТекущее = пЗначение;
			}
			else
			{
				if (_мноПостоянныеНастройки.has(сИмя))
				{
					оСохранить[сИмя] = _оНастройки[сИмя].пНачальное;
				}
				_оНастройки[сИмя].пТекущее = _оНастройки[сИмя].пНачальное;
			}
		}

		НачатьСохранение(оСохранить, лОстальноеУдалить);
		НастроитьСпискиПредустановок();
	}

	function Сбросить()
	{
		м_Журнал.Окак('[Настройки] Сбрасываю настройки');

		const оСохранить = {};
		for (let сИмя of _мноПостоянныеНастройки)
		{
			оСохранить[сИмя] = _оНастройки[сИмя].пТекущее;
		}

		НачатьСохранение(оСохранить, true);
		window.location.reload();
	}

	function Экспорт()
	{
		м_Журнал.Окак('[Настройки] Экспортирую настройки');
		Проверить(_оНастройки.чВерсияНастроек.пТекущее);
		
		const оЭкспорт =
		{
			чВерсияНастроек: ВЕРСИЯ_НАСТРОЕК
		};
		for (let сИмя of Object.keys(_оНастройки))
		{
			// Экспортируемые настройки могут попасть на другой компьютер, поэтому постоянные настойки пропускаем.
			if (!_мноПостоянныеНастройки.has(сИмя))
			{
				оЭкспорт[сИмя] = _оНастройки[сИмя].пТекущее;
			}
		}
		м_Журнал.Вот(`[Настройки] Отобраны настройки для экспорта: ${м_Журнал.O(оЭкспорт)}`);

		ЗаписатьТекстВЛокальныйФайл(JSON.stringify(оЭкспорт), 'application/json', Текст('J0133'));
	}

	function Импорт(оИзФайла)
	{
		м_Журнал.Окак(`[Настройки] Импортирую настройки из файла ${оИзФайла.name}`);
		Проверить(_оНастройки.чВерсияНастроек.пТекущее);

		if (оИзФайла.size === 0 || оИзФайла.size > 10000)
		{
			м_Журнал.Ой(`[Настройки] Размер файла: ${оИзФайла.size}`);
			alert(Текст('J0134'));
			return;
		}

		const оЧиталка = new FileReader();
		оЧиталка.addEventListener('loadend', ДобавитьОбработчикИсключений(() =>
		{
			if (!ЭтоНепустаяСтрока(оЧиталка.result))
			{
				м_Журнал.Ой(`[Настройки] Результат чтения файла: ${оЧиталка.result}`);
				alert(Текст('J0135') + оИзФайла.name);
				return;
			}
			м_Журнал.Вот(`[Настройки] Настройки прочитаны из файла: ${оЧиталка.result}`);

			let оСохранить;

			try
			{
				оСохранить = JSON.parse(оЧиталка.result);
				if (!ЭтоОбъект(оСохранить))
				{
					throw 1;
				}

				if (ПроверитьВерсиюНастроек(оСохранить, оСохранить))
				{
					throw 2;
				}

				for (let сИмя of Object.keys(оСохранить))
				{
					if (!_оНастройки.hasOwnProperty(сИмя)
					|| (оСохранить[сИмя] = _оНастройки[сИмя].ИсправитьЗначение(оСохранить[сИмя])) === _оНастройки[сИмя].пНачальное)
					{
						delete оСохранить[сИмя];
					}
				}
			}
			catch (пИсключение)
			{
				м_Журнал.Ой(`[Настройки] Поймано исключение во время разбора настроек: ${пИсключение}`);
				alert(Текст('J0134'));
				return;
			}

			for (let сИмя of _мноПостоянныеНастройки)
			{
				оСохранить[сИмя] = _оНастройки[сИмя].пТекущее;
			}

			НачатьСохранение(оСохранить, true);
			window.location.reload();
		}));
		оЧиталка.readAsText(оИзФайла);
	}

	function Получить2(сИмя)
	{
		Проверить(typeof сИмя === 'string');
		Проверить(_оНастройки.hasOwnProperty(сИмя));
		for (let оМетаданные of _моМетаданныеПредустановок)
		{
			const оПредустановка = оМетаданные.амДанные.get(_оНастройки[оМетаданные.сВыбрана].пТекущее);
			if (оПредустановка)
			{
				const пЗначение = оПредустановка[сИмя];
				if (пЗначение !== undefined)
				{
					return пЗначение;
				}
			}
		}
		return _оНастройки[сИмя].пТекущее;
	}

	function Получить(сИмя)
	{
		// Если чНачалоВоспроизведения > чРазмерБуфера, то чРазмерБуфера по-прежнему используется для загрузки сегментов,
		// а размер буфера проигрывателя равен чНачалоВоспроизведения. Возможно, в будущем имеет смысл разнести размеры
		// для загрузки и воспроизведения по разным настройкам.
		if (сИмя === 'чМаксРазмерБуфера')
		{
			return Math.max(Получить2('чНачалоВоспроизведения'), Получить2('чРазмерБуфера'));
		}
		return Получить2(сИмя);
	}

	function Изменить(сИмя, пЗначение, лНеСохранять = false)
	{
		// См. комментарий в ЗавершитьРаботу().
		if (г_лРаботаЗавершена)
		{
			return;
		}

		Проверить(typeof сИмя === 'string');
		Проверить(_оНастройки[сИмя].ИсправитьЗначение(пЗначение) === пЗначение);
		const оСохранить = {};

		for (let оМетаданные of _моМетаданныеПредустановок)
		{
			const оПредустановка = оМетаданные.амДанные.get(_оНастройки[оМетаданные.сВыбрана].пТекущее);
			if (оПредустановка && оПредустановка.hasOwnProperty(сИмя))
			{
				if (пЗначение === оПредустановка[сИмя])
				{
					return;
				}
				// Такой вариант пока не использовался и не тестировался.
				Проверить(!лНеСохранять);
				оСохранить[оМетаданные.сВыбрана  ] = _оНастройки[оМетаданные.сВыбрана  ].пТекущее = оМетаданные.сНастраиваемая;
				оСохранить[оМетаданные.сЗаполнена] = _оНастройки[оМетаданные.сЗаполнена].пТекущее = true;
				for (let сИмяПредустановки of Object.keys(оПредустановка))
				{
					оСохранить[сИмяПредустановки] = _оНастройки[сИмяПредустановки].пТекущее = оПредустановка[сИмяПредустановки];
				}
				ОбновитьСписокПредустановок(оМетаданные);
				// м_События.ОбработатьСобытие() вызывать не нужно.
				break;
			}
		}

		if (_оНастройки[сИмя].пТекущее !== пЗначение)
		{
			оСохранить[сИмя] = _оНастройки[сИмя].пТекущее = пЗначение;
		}

		if (!лНеСохранять)
		{
			НачатьСохранение(оСохранить, false);
		}
	}

	function ОбновитьСписокПредустановок(оМетаданные)
	{
		const узСписок = document.getElementById(оМетаданные.сСписок);
		узСписок.length = 0;
		const сВыбрать = _оНастройки[оМетаданные.сВыбрана].пТекущее;
		for (let сИмя of оМетаданные.амДанные.keys())
		{
			узСписок.add(new Option(Текст(сИмя), сИмя, сИмя === сВыбрать, сИмя === сВыбрать));
		}
		if (_оНастройки[оМетаданные.сЗаполнена].пТекущее)
		{
			узСписок.add(new Option(Текст(оМетаданные.сНастраиваемая), оМетаданные.сНастраиваемая, оМетаданные.сНастраиваемая === сВыбрать, оМетаданные.сНастраиваемая === сВыбрать));
		}
		Проверить(узСписок.value);
		return узСписок;
	}

	const ОбработатьИзменениеПредустановки = ДобавитьОбработчикИсключений(оСобытие =>
	{
		for (let оМетаданные of _моМетаданныеПредустановок)
		{
			if (оМетаданные.сСписок === оСобытие.target.id)
			{
				Проверить(оСобытие.target.value);
				Изменить(оМетаданные.сВыбрана, оСобытие.target.value);
				м_События.ОбработатьСобытие(оМетаданные.сСобытие);
				return;
			}
		}
		Проверить(false);
	});

	function НастроитьСпискиПредустановок()
	{
		for (let оМетаданные of _моМетаданныеПредустановок)
		{
			ОбновитьСписокПредустановок(оМетаданные)
			.addEventListener('change', ОбработатьИзменениеПредустановки);
		}
	}

	function ПолучитьПараметрыНастройки(сИмя)
	// TODO По хорошему, в возвращаемом объекте не должно быть свойства пТекущее.
	{
		Проверить(typeof сИмя === 'string');
		Проверить(_оНастройки.hasOwnProperty(сИмя));
		return _оНастройки[сИмя];
	}

	function ПолучитьДанныеДляОтчета()
	{
		const оОтчет = {};
		for (let сИмя of Object.keys(_оНастройки))
		{
			if (_мноПостоянныеНастройки.has(сИмя) || _оНастройки[сИмя].пТекущее !== _оНастройки[сИмя].пНачальное)
			{
				оОтчет[сИмя] = _оНастройки[сИмя].пТекущее;
			}
		}
		return оОтчет;
	}

	return {
		Восстановить, Сбросить,
		Экспорт, Импорт,
		Получить, Изменить,
		ПолучитьПараметрыНастройки,
		ПолучитьДанныеДляОтчета,
		Остановить
	};
})();

const м_Статистика = (() =>
{
	const ЧАСТОТА_ОБНОВЛЕНИЯ_СТАТИСТИКИ  = 3;     // Количество обновлений в секунду.
	const РАЗМЕР_ИСТОРИИ_СПИСКА          = 30;    // Количество.
	const РАЗМЕР_ИСТОРИИ_ЗАГРУЗКИ        = 30;    // Количество.
	const РАЗМЕР_ИСТОРИИ_БУФЕРА          = 40;    // Количество.

	const ВЫДЕЛИТЬ_ИНТЕРВАЛ_ОБНОВЛЕНИЯ   = 150;   // Процент target duration.
	const ВЫДЕЛИТЬ_СЕКУНД_ДОБАВЛЕНО      = 0.5;   // Часть target duration.
	const ВЫДЕЛИТЬ_ОЖИДАНИЕ_ОТВЕТА       = 1.0;   // Секунды.
	const ВЫДЕЛИТЬ_ПРЕОБРАЗОВАНО         = 2;     // Количество преобразованных сегментов.
	const ВЫДЕЛИТЬ_НЕ_ПРОСМОТРЕНО_МИН    = 1.5;   // Секунды.
	const ВЫДЕЛИТЬ_НЕ_ПРОСМОТРЕНО_МАКС   = 0.5;   // Отношение. TODO Подобрать подходящее значение.
	const ВЫДЕЛИТЬ_ПРОПУЩЕННЫЕ_КАДРЫ     = 100;	  // Количество.
	const ВЫДЕЛИТЬ_ЧАСТОТУ_КАДРОВ        = 0.85;  // Отношение. TODO Подобрать подходящее значение.
	const ВЫДЕЛИТЬ_ПОТЕРЮ_ВИДЕО_ОТН      = 1 / 5; // Отношение. TODO Подобрать подходящее значение.
	const ВЫДЕЛИТЬ_ПОТЕРЮ_ВИДЕО_АБС      = 300;   // Миллисекунды. TODO Подобрать подходящее значение.
	const ВЫДЕЛИТЬ_ИСЧЕРПАНИЕ_БУФЕРА     = 5;     // Количество. TODO Подобрать подходящее значение.

	var _чТаймер                      = 0;
	var _nTargetDuration              = 0;
	var _кСегментовВСписке            = 0;
	var _чМинДлительностьВидеосемпла  = -Infinity;
	var _чМаксДлительностьВидеосемпла = +Infinity;
	var _оИнтервалОбновления          = null;
	var _оСегментовДобавлено          = null;
	var _оСекундДобавлено             = null;
	var _оТолщинаСегмента             = null;
	var _оТолщинаКанала               = null;
	var _оОжиданиеОтвета              = null;
	var _оНеПросмотрено               = null;
	var _кбВсегоСкачано               = 0;
	var _кИсходныхСегментов           = 0;
	var _кЗабраковано                 = 0;
	var _кПотерьВидео                 = 0;
	var _кПотерьЗвука                 = 0;
	var _кОшибокЗагрузки              = 0;
	var _кНезагруженныхСегментов      = 0;
	var _кПереполненийБуфера          = 0;
	var _чПропущеноВБуфере            = 0;
	var _кИсчерпанийБуфера            = 0;
	var _кИсчерпанийБуфераДосрочно    = 0;

	var _чВремяПоследнегоОбновления;
	var _чНеПросмотреноСек;
	var _кНеПросмотреноСек;

	function ВыделитьИнтервалОбновления(чЧисло)
	{
		return чЧисло >= ВЫДЕЛИТЬ_ИНТЕРВАЛ_ОБНОВЛЕНИЯ;
	}
	
	function ВыделитьСегментовДобавлено(чЧисло)
	{
		return чЧисло === 0 || чЧисло > 2;
	}

	function ВыделитьОжиданиеОтвета(чЧисло)
	{
		return чЧисло >= ВЫДЕЛИТЬ_ОЖИДАНИЕ_ОТВЕТА;
	}

	function ВыделитьНеПросмотрено(чЧисло)
	{
		return чЧисло < ВЫДЕЛИТЬ_НЕ_ПРОСМОТРЕНО_МИН
		    || чЧисло >= м_Настройки.Получить('чМаксРазмерБуфера') + м_Настройки.Получить('чРастягиваниеБуфера') * ВЫДЕЛИТЬ_НЕ_ПРОСМОТРЕНО_МАКС;
	}

	function Анализ(сИдентификатор, чРазмерИстории, чТочность)
	{
		Проверить(чРазмерИстории > 0 && чТочность >= 0);
		this._узПоказать = document.getElementById(сИдентификатор);
		this._мчИстория  = new Array(чРазмерИстории); // Кольцевой буфер.
		this._млВыделить = new Array(чРазмерИстории); // Кольцевой буфер.
		this._чТочность  = чТочность;
		this._Очистить();
	}

	Анализ.prototype.Освободить = function()
	{
		this._узПоказать.textContent = '';
		this._узПоказать = null;
	};

	Анализ.prototype._Очистить = function()
	{
		this._кЗаполнено = 0;
		this._чИндекс    = -1;

		var узФрагмент = document.createDocumentFragment();
		узФрагмент.appendChild(document.createElement('td'))
		.className = 'анализ-минимум';
		узФрагмент.appendChild(document.createElement('td'))
		.textContent = '\u2009<\u2009';
		узФрагмент.lastChild.className = 'статистика-символ';
		узФрагмент.appendChild(document.createElement('td'))
		.className = 'анализ-среднее';
		узФрагмент.appendChild(document.createElement('td'))
		.textContent = '\u2009<\u2009';
		узФрагмент.lastChild.className = 'статистика-символ';
		узФрагмент.appendChild(document.createElement('td'))
		.className = 'анализ-максимум';
		for (var ы = 0; ы < this._мчИстория.length; ++ы)
		{
			узФрагмент.appendChild(document.createElement('td'))
			.setAttribute('class', 'анализ-история статистика-подробно');
		}
		this._узПоказать.textContent = '';
		this._узПоказать.appendChild(узФрагмент);
	};

	Анализ.prototype._ВСтроку = function(чЧисло)
	{
		// Не использовать пустую строку, чтобы не сработал селектор :empty.
		return Number.isFinite(чЧисло) ? чЧисло.toFixed(this._чТочность) : '\u00A0';
	};

	Анализ.prototype.Очистить = function()
	{
		if (this._кЗаполнено !== 0)
		{
			this._Очистить();
		}
	};

	Анализ.prototype.ПолучитьПоследнееЧисло = function(чЗаглушка)
	{
		return this._кЗаполнено === 0 ? чЗаглушка : this._мчИстория[this._чИндекс];
	};

	Анализ.prototype.ДобавитьЧисло = function(чЧисло, пВыделить, пВыделитьСреднее)
	{
		const НАЧАЛО_ИСТОРИИ = 5;

		var лВыделить = Boolean(typeof пВыделить === 'function' ? пВыделить(чЧисло) : пВыделить);

		if (this._кЗаполнено !== 0)
		{
			this._узПоказать.children[НАЧАЛО_ИСТОРИИ + this._чИндекс].classList.add('статистика-подробно');
		}

		if (this._кЗаполнено !== this._мчИстория.length)
		{
			++this._кЗаполнено;
		}
		if (++this._чИндекс === this._мчИстория.length)
		{
			this._чИндекс = 0;
		}
		this._мчИстория[this._чИндекс] = чЧисло;
		this._млВыделить[this._чИндекс] = лВыделить;

		var чМинимальноеЧисло = Infinity, лВыделитьМинимальное = false;
		var чМаксимальноеЧисло = -Infinity, лВыделитьМаксимальное = false;
		var чСреднееЧисло = 0, кЧисел = 0;
		for (var ы = 0; ы < this._кЗаполнено; ++ы)
		{
			if (Number.isFinite(this._мчИстория[ы]))
			{
				if (this._мчИстория[ы] < чМинимальноеЧисло || (this._мчИстория[ы] === чМинимальноеЧисло && this._млВыделить[ы]))
				{
					чМинимальноеЧисло = this._мчИстория[ы];
					лВыделитьМинимальное = this._млВыделить[ы];
				}
				if (this._мчИстория[ы] > чМаксимальноеЧисло || (this._мчИстория[ы] === чМаксимальноеЧисло && this._млВыделить[ы]))
				{
					чМаксимальноеЧисло = this._мчИстория[ы];
					лВыделитьМаксимальное = this._млВыделить[ы];
				}
				чСреднееЧисло += this._мчИстория[ы];
				++кЧисел;
			}
		}

		if (кЧисел === 0)
		{
			чСреднееЧисло = NaN;
			var лВыделитьСреднее = false;
		}
		else
		{
			чСреднееЧисло /= кЧисел;
			var лВыделитьСреднее = Boolean(typeof пВыделитьСреднее === 'function' ? пВыделитьСреднее(чСреднееЧисло) : пВыделитьСреднее);
		}

		ОбновитьЗначение(this._узПоказать.children[0], this._ВСтроку(чМинимальноеЧисло),лВыделитьМинимальное);
		ОбновитьЗначение(this._узПоказать.children[2], this._ВСтроку(чСреднееЧисло), лВыделитьСреднее);
		ОбновитьЗначение(this._узПоказать.children[4], this._ВСтроку(чМаксимальноеЧисло), лВыделитьМаксимальное);
		ОбновитьЗначение(this._узПоказать.children[НАЧАЛО_ИСТОРИИ + this._чИндекс], this._ВСтроку(чЧисло), лВыделить)
		.classList.remove('статистика-подробно');

		return чСреднееЧисло;
	};

	function ОбновитьЗначение(пУзел, пЗначение, лВыделить)
	{
		var узУзел = typeof пУзел === 'string' ? document.getElementById(пУзел) : пУзел;
		узУзел.classList.toggle('статистика-выделить', лВыделить);
		узУзел.textContent = пЗначение;
		return узУзел;
	}

	function ПолучитьНазваниеПрофиляH264(nProfileIndication, nConstraintSetFlag)
	// ITU-T H.264:2014 A.2 Profiles
	{
		switch (nProfileIndication)
		{
			case 66: return (nConstraintSetFlag & 0x40) === 0 ? 'Baseline' : 'Constrained Baseline'; // constraint_set1_flag
			case 77: return 'Main';
			case 88: return 'Extended';
			case 100:
				switch (nConstraintSetFlag & 0x0C)
				{
					case 0x08: return 'Progressive High'; // constraint_set4_flag
					case 0x0C: return 'Constrained High'; // constraint_set4_flag | constraint_set5_flag
				}
				return 'High';
			case 110: return (nConstraintSetFlag & 0x10) === 0 ? 'High 10' : 'High 10 Intra'; // constraint_set3_flag
			case 122: return (nConstraintSetFlag & 0x10) === 0 ? 'High 4:2:2' : 'High 4:2:2 Intra'; // constraint_set3_flag
			case 244: return (nConstraintSetFlag & 0x10) === 0 ? 'High 4:4:4 Predictive' : 'High 4:4:4 Intra'; // constraint_set3_flag
			case 44:  return 'CAVLC 4:4:4 Intra';
		}
		м_Журнал.Ой(`[Статистика] Неизвестный профиль H.264 ProfileIndication=${nProfileIndication} ConstraintSetFlag=${nConstraintSetFlag}`);
		return `P${nProfileIndication}C${nConstraintSetFlag}`;
	}

	const ОбновитьСтатистику = ДобавитьОбработчикИсключений(() =>
	{
		document.getElementById('статистика-длительностьпросмотра').textContent = м_i18n.ПеревестиСекундыВСтроку(performance.now() / 1000, true);

		var оПропущенныеКадры = м_Проигрыватель.ПолучитьКоличествоПропущенныхКадров();
		ОбновитьЗначение('статистика-пропущено', оПропущенныеКадры.droppedVideoFrames, оПропущенныеКадры.droppedVideoFrames >= ВЫДЕЛИТЬ_ПРОПУЩЕННЫЕ_КАДРЫ)
		.nextElementSibling.nextElementSibling.textContent = оПропущенныеКадры.totalVideoFrames;

		var кЖдетЗагрузки = 0, чЖдетЗагрузки = 0, чЗагружается = 0, кПреобразовано = 0, чПреобразовано = 0;
		for (var оСегмент of г_моОчередь)
		{
			switch (оСегмент.чОбработка)
			{
			case ОБРАБОТКА_ЖДЕТ_ЗАГРУЗКИ:
				++кЖдетЗагрузки;
				чЖдетЗагрузки += оСегмент.чДлительность;
				break;
				
			case ОБРАБОТКА_ЗАГРУЖАЕТСЯ:
			case ОБРАБОТКА_ЗАГРУЖЕН:
				чЗагружается += оСегмент.чДлительность;
				break;

			case ОБРАБОТКА_ПРЕОБРАЗОВАН:
				++кПреобразовано;
				чПреобразовано += оСегмент.чДлительность;
				break;

			default:
				Проверить(false);
			}
		}

		var оВБуфере = м_Проигрыватель.ПолучитьЗаполненностьБуфера();

		var уз = ОбновитьЗначение('статистика-очередь', чЖдетЗагрузки.toFixed(1), кЖдетЗагрузки > _кСегментовВСписке);
		уз = уз.nextElementSibling.nextElementSibling;
		уз.textContent = чЗагружается.toFixed(1);
		уз = уз.nextElementSibling;
		ОбновитьЗначение(уз, чПреобразовано.toFixed(1), кПреобразовано >= ВЫДЕЛИТЬ_ПРЕОБРАЗОВАНО);
		уз = уз.nextElementSibling;
		ОбновитьЗначение(уз, оВБуфере.чНеПросмотрено.toFixed(1), ВыделитьНеПросмотрено(оВБуфере.чНеПросмотрено));
		уз = уз.nextElementSibling.nextElementSibling;
		уз.textContent = оВБуфере.чПросмотрено.toFixed(1);

		if ([СОСТОЯНИЕ_ЗАГРУЗКА, СОСТОЯНИЕ_НАЧАЛО_ВОСПРОИЗВЕДЕНИЯ, СОСТОЯНИЕ_ВОСПРОИЗВЕДЕНИЕ].includes(м_Управление.ПолучитьСостояние()))
		{
			_чНеПросмотреноСек = Math.min(_чНеПросмотреноСек, оВБуфере.чНеПросмотрено);
			_кНеПросмотреноСек = (_кНеПросмотреноСек + 1) % ЧАСТОТА_ОБНОВЛЕНИЯ_СТАТИСТИКИ;
			if (_кНеПросмотреноСек === 0)
			{
				_оНеПросмотрено.ДобавитьЧисло(_чНеПросмотреноСек, ВыделитьНеПросмотрено, ВыделитьНеПросмотрено);
				_чНеПросмотреноСек = Infinity;
			}
		}
	});

	function ОкноПоказано()
	{
		return _чТаймер !== 0;
	}

	function ОткрытьОкно()
	{
		if (ОкноПоказано())
		{
			return;
		}

		_оИнтервалОбновления = new Анализ('статистика-интервалобновления', РАЗМЕР_ИСТОРИИ_СПИСКА,   0);
		_оСегментовДобавлено = new Анализ('статистика-сегментовдобавлено', РАЗМЕР_ИСТОРИИ_СПИСКА,   0);
		_оСекундДобавлено    = new Анализ('статистика-секунддобавлено',    РАЗМЕР_ИСТОРИИ_СПИСКА,   1);
		_оТолщинаСегмента    = new Анализ('статистика-толщинасегмента',    РАЗМЕР_ИСТОРИИ_ЗАГРУЗКИ, 1);
		_оТолщинаКанала      = new Анализ('статистика-толщинаканала',      РАЗМЕР_ИСТОРИИ_ЗАГРУЗКИ, 1);
		_оОжиданиеОтвета     = new Анализ('статистика-ожиданиеответа',     РАЗМЕР_ИСТОРИИ_ЗАГРУЗКИ, 1);
		_оНеПросмотрено      = new Анализ('статистика-непросмотрено',      РАЗМЕР_ИСТОРИИ_БУФЕРА,   1);

		_чВремяПоследнегоОбновления = NaN;
		_чНеПросмотреноСек          = Infinity;
		_кНеПросмотреноСек          = 0;

		//
		// Вывод редко изменяемых показаний.
		//
		ОбновитьЗначение('статистика-забраковано', _кЗабраковано, _кЗабраковано !== 0);
		ОбновитьЗначение('статистика-потерьвидео', _кПотерьВидео, _кПотерьВидео !== 0);
		ОбновитьЗначение('статистика-потерьзвука', _кПотерьЗвука, _кПотерьЗвука !== 0);
		document.getElementById('статистика-исходных').textContent = _кИсходныхСегментов;
		ОбновитьЗначение('статистика-незагружено', _кОшибокЗагрузки, _кОшибокЗагрузки !== 0)
		.nextElementSibling.nextElementSibling.textContent = _кНезагруженныхСегментов;
		ОбновитьЗначение('статистика-переполнено', _кПереполненийБуфера, _кПереполненийБуфера !== 0)
		.nextElementSibling.nextElementSibling.textContent = _чПропущеноВБуфере.toFixed(1);
		ОбновитьЗначение('статистика-исчерпано', _кИсчерпанийБуфера, _кИсчерпанийБуфера >= ВЫДЕЛИТЬ_ИСЧЕРПАНИЕ_БУФЕРА);

		_чТаймер = setInterval(ОбновитьСтатистику, 1000 / ЧАСТОТА_ОБНОВЛЕНИЯ_СТАТИСТИКИ);
		ОбновитьСтатистику();

		м_Тащилка.ДобавитьОбработчик('статистика', null);
		ПоказатьЭлемент('статистика', true);

		м_Настройки.Изменить('лПоказатьСтатистику', true);
	}

	function ЗакрытьОкно()
	{
		if (!ОкноПоказано())
		{
			return;
		}

		clearInterval(_чТаймер);
		_чТаймер = 0;

		ПоказатьЭлемент('статистика', false);

		_оИнтервалОбновления.Освободить(); _оИнтервалОбновления = null;
		_оСегментовДобавлено.Освободить(); _оСегментовДобавлено = null;
		_оСекундДобавлено.Освободить();    _оСекундДобавлено    = null;
		_оТолщинаСегмента.Освободить();    _оТолщинаСегмента    = null;
		_оТолщинаКанала.Освободить();      _оТолщинаКанала      = null;
		_оОжиданиеОтвета.Освободить();     _оОжиданиеОтвета     = null;
		_оНеПросмотрено.Освободить();      _оНеПросмотрено      = null;

		for (var уз of document.querySelectorAll('*[data-очистить]'))
		{
			уз.textContent = '';
		}

		м_Настройки.Изменить('лПоказатьСтатистику', false);
	}

	function ОчиститьИсторию()
	// Вызвать после изменения настроек, которые влияют на загрузку сегментов.
	{
		if (_оИнтервалОбновления !== null)
		{
			_оИнтервалОбновления.Очистить();
			_оСегментовДобавлено.Очистить();
			_оСекундДобавлено.Очистить();
			_оТолщинаСегмента.Очистить();
			_оТолщинаКанала.Очистить();
			_оОжиданиеОтвета.Очистить();
			_оНеПросмотрено.Очистить();

			_чВремяПоследнегоОбновления = NaN;
			_чНеПросмотреноСек          = Infinity;
			_кНеПросмотреноСек          = 0;
		}
		ОбновитьЗначение('статистика-незагружено', _кОшибокЗагрузки = 0, false)
		.nextElementSibling.nextElementSibling.textContent = _кНезагруженныхСегментов = 0;
		ОбновитьЗначение('статистика-переполнено', _кПереполненийБуфера = 0, false)
		.nextElementSibling.nextElementSibling.textContent = (_чПропущеноВБуфере = 0).toFixed(1);
		ОбновитьЗначение('статистика-исчерпано', _кИсчерпанийБуфера = 0, false);
	}

	function ПолучитьTargetDuration()
	{
		return _nTargetDuration;
	}

	function ПолучитьДлительностьКадраВСекундах()
	// Часто в исходном видео длительность кадров округлена до целых миллисекунд.
	{
		return {
			// Edge 15: Минимальные интервалы для перемотки: -17 мс и +16 мс.
			чМинимальная: Math.max(17, _чМинДлительностьВидеосемпла) / 1000,
			чМаксимальная: Math.min(1000 / 25, _чМаксДлительностьВидеосемпла) / 1000
		};
	}

	function ПолучитьДанныеДляОтчета()
	{
		return {
			ОкноПоказано:             ОкноПоказано(),
			Сервер:                   document.getElementById('статистика-сервер').textContent,
			ПараметрыВидео:           document.getElementById('статистика-разрешениевидео').textContent + ' ' + document.getElementById('статистика-сжатиевидео').textContent,
			ПараметрыЗвука:           document.getElementById('статистика-сжатиезвука').textContent,
			ВсегоСкачано:             _кбВсегоСкачано,
			Забраковано:              _кЗабраковано,
			ПотерьВидео:              _кПотерьВидео,
			ПотерьЗвука:              _кПотерьЗвука,
			ОшибокЗагрузки:           _кОшибокЗагрузки,
			НезагруженныхСегментов:   _кНезагруженныхСегментов,
			ПереполненийБуфера:       _кПереполненийБуфера,
			ПропущеноВБуфере:         _чПропущеноВБуфере,
			ИсчерпанийБуфера:         _кИсчерпанийБуфера,
			ИсчерпанийБуфераДосрочно: _кИсчерпанийБуфераДосрочно
		};
	}

	function СкачаноНечто(кбСкачано)
	{
		if (Number.isFinite(кбСкачано))
		{
			_кбВсегоСкачано += кбСкачано;
			if (ОкноПоказано())
			{
				document.getElementById('статистика-скачано').textContent = (_кбВсегоСкачано / 1024 / 1024).toFixed();
			}
		}
	}

	function ВыбранВариантТрансляции(сСобытие, мДанные)
	{
		const моСписокВариантов = мДанные[0], чВыбранныйВариант = мДанные[1];
		if (моСписокВариантов)
		{
			document.getElementById('статистика-сервер').textContent =
				(new URL(моСписокВариантов[чВыбранныйВариант].сАбсолютныйАдресСпискаСегментов)).host;
		}
	}

	function РазобранСписокСегментов(nTargetDuration, кСегментовВСписке, чДлительностьСписка)
	{
		if (ОкноПоказано())
		{
			var уз = document.getElementById('статистика-список');
			уз.textContent = `${кСегментовВСписке} × ${(чДлительностьСписка / кСегментовВСписке).toFixed(1)} = ${чДлительностьСписка.toFixed(1)}`;
			ОбновитьЗначение(уз.nextElementSibling.nextElementSibling, nTargetDuration, nTargetDuration !== _nTargetDuration);
		}
		_nTargetDuration = nTargetDuration;
		_кСегментовВСписке = кСегментовВСписке;
	}

	function ДобавленыСегментыВОчередь(кСегментовДобавлено, кСекундДобавлено)
	{
		if (ОкноПоказано())
		{
			// Рассчитываем интервал после получения списка сегментов, а не перед получением,
			// чтобы продолжительность получения была отражена в статистике.
			var чВремя = performance.now();
			_оИнтервалОбновления.ДобавитьЧисло((чВремя - _чВремяПоследнегоОбновления) / _nTargetDuration / 10,
				ВыделитьИнтервалОбновления, ВыделитьИнтервалОбновления);
			_чВремяПоследнегоОбновления = чВремя;

			var чВСреднемСегментовДобавлено = _оСегментовДобавлено.ДобавитьЧисло(кСегментовДобавлено,
				ВыделитьСегментовДобавлено, ВыделитьСегментовДобавлено);

			_оСекундДобавлено.ДобавитьЧисло(кСекундДобавлено,
				кСекундДобавлено / кСегментовДобавлено < _nTargetDuration * ВЫДЕЛИТЬ_СЕКУНД_ДОБАВЛЕНО,
				чЧисло => чЧисло / чВСреднемСегментовДобавлено < _nTargetDuration * ВЫДЕЛИТЬ_СЕКУНД_ДОБАВЛЕНО
			);
		}
	}

	function ЗагруженСегмент(чРазмерСегмента, чДлительностьСегмента, чДлительностьЗагрузки, чОжиданиеОтвета)
	{
		if (ОкноПоказано())
		{
			var чСредняяТолщинаСегмента = _оТолщинаСегмента.ДобавитьЧисло(чРазмерСегмента * 8 / 1000000 / чДлительностьСегмента);

			чДлительностьЗагрузки /= 1000;
			_оТолщинаКанала.ДобавитьЧисло(
				чРазмерСегмента * 8 / 1000000 / чДлительностьЗагрузки,
				чДлительностьЗагрузки > чДлительностьСегмента,
				чЧисло => чЧисло < чСредняяТолщинаСегмента
			);

			_оОжиданиеОтвета.ДобавитьЧисло(чОжиданиеОтвета / 1000, ВыделитьОжиданиеОтвета, ВыделитьОжиданиеОтвета);
		}
	}

	function НеЗагруженыСегменты(кНезагруженныхСегментов)
	{
		Проверить(кНезагруженныхСегментов > 0);
		++_кОшибокЗагрузки;
		_кНезагруженныхСегментов += кНезагруженныхСегментов;
		if (ОкноПоказано())
		{
			ОбновитьЗначение('статистика-незагружено', _кОшибокЗагрузки, true)
			.nextElementSibling.nextElementSibling.textContent = _кНезагруженныхСегментов;
		}
	}

	function ОтосланИсходныйСегмент()
	{
		++_кИсходныхСегментов;
		if (ОкноПоказано())
		{
			document.getElementById('статистика-исходных').textContent = _кИсходныхСегментов;
		}
	}

	function ПолученПреобразованныйСегмент(оСегмент)
	{
		var лОкноПоказано = ОкноПоказано();
		var оДанные = оСегмент.пДанные;

		if (оСегмент.лРазрыв)
		{
			document.getElementById('статистика-разрешениевидео').textContent = `${оДанные.чШиринаКартинки}x${оДанные.чВысотаКартинки}`;

			var сСжатиеВидео = 'H.264'
				+ `\u2002${ПолучитьНазваниеПрофиляH264(оДанные.nProfileIndication, оДанные.nConstraintSetFlag)}`
				+ `\u2002L${(оДанные.nLevelIndication / 10).toFixed(1)}`
				+ `\u2002RF${оДанные.nMaxNumberReferenceFrames}`;
			if (оДанные.чДиапазон !== -1)
			{
				сСжатиеВидео += оДанные.чДиапазон === 0 ? '\u200216-235' : '\u20020-255';
			}
			if (оДанные.лЧересстрочное)
			{
				сСжатиеВидео += '\u2002чересстрочное';
			}
			if (оДанные.чЧастотаКадров !== 0)
			{
				// Twitch: Иногда чЧастотаКадров равна 1000 при фактической 60.
				сСжатиеВидео += `\u2002${оДанные.чЧастотаКадров < 0 ? '≈' : ''}${Math.abs(оДанные.чЧастотаКадров).toFixed(2)} к/с`;
			}
			document.getElementById('статистика-сжатиевидео').textContent = сСжатиеВидео;

			document.getElementById('статистика-сжатиезвука').textContent =
				['AAC-Main', 'AAC-LC', 'AAC-SSR', 'AAC-LTP'][оДанные.nAudioObjectType - 1]
				+ `\u2002${оДанные.чЧастотаДискретизации} Гц`
				+ `\u2002${оДанные.чКоличествоКаналов} канал.`;
		}

		if (Number.isFinite(оДанные.чСредняяДлительностьВидеоСемпла))
		{
			_чМинДлительностьВидеосемпла = оДанные.чМинДлительностьВидеоСемпла;
			_чМаксДлительностьВидеосемпла = оДанные.чМаксДлительностьВидеоСемпла;
			Проверить(_чМинДлительностьВидеосемпла <= _чМаксДлительностьВидеосемпла);

			// В идеале среднее арифметическое нужно заменить чем-нибудь более преближенным к исходной частоте кадров. Но нагружать процессор этими расчетами не хочется.
			var чОтносительноеОтклонение = оДанные.чСредняяДлительностьВидеоСемпла / оДанные.чМаксДлительностьВидеоСемпла;
			var чАбсолютноеОтклонение = оДанные.чМаксДлительностьВидеоСемпла - оДанные.чСредняяДлительностьВидеоСемпла;

			if (чОтносительноеОтклонение <= ВЫДЕЛИТЬ_ПОТЕРЮ_ВИДЕО_ОТН && чАбсолютноеОтклонение >= ВЫДЕЛИТЬ_ПОТЕРЮ_ВИДЕО_АБС)
			{
				м_Журнал.Ой(`[Статистика] Превышено отклонение длительности кадра в сегменте ${оСегмент.чНомер}`
					+ ` СредняяДлительностьКадра=${м_Журнал.F0(оДанные.чСредняяДлительностьВидеоСемпла)}мс`
					+ ` АбсолютноеОтклонение=${м_Журнал.F0(чАбсолютноеОтклонение)}мс`
					+ ` ОтносительноеОтклонение=${м_Журнал.F2(чОтносительноеОтклонение)}`);
				оДанные.лПотериВидео = true;
			}
		}

		if (лОкноПоказано)
		{
			if (Number.isFinite(оДанные.чСредняяДлительностьВидеоСемпла))
			{
				ОбновитьЗначение(
					'статистика-частотакадров',
					`@${(1000 / оДанные.чСредняяДлительностьВидеоСемпла).toFixed(0)}`
					+ `\u2002−${(100 - оДанные.чСредняяДлительностьВидеоСемпла / оДанные.чМаксДлительностьВидеоСемпла * 100).toFixed()}%`
					+ `\u2002+${(оДанные.чСредняяДлительностьВидеоСемпла  / оДанные.чМинДлительностьВидеоСемпла * 100 - 100).toFixed()}%`,
					чОтносительноеОтклонение <= ВЫДЕЛИТЬ_ЧАСТОТУ_КАДРОВ
				);
			}
			if (ЭтоЧисло(оДанные.чБитрейтЗвука))
			{
				document.getElementById('статистика-битрейтзвука').textContent = `${оДанные.чБитрейтЗвука.toFixed()} кбит/с`;
			}
			if (ЭтоЧисло(оДанные.чПреобразованЗа))
			{
				document.getElementById('статистика-преобразованоза').textContent = оДанные.чПреобразованЗа.toFixed();
			}
		}

		if (оДанные.лПотериВидео)
		{
			++_кПотерьВидео;
			if (лОкноПоказано)
			{
				ОбновитьЗначение('статистика-потерьвидео', _кПотерьВидео, true);
			}
		}

		if (оДанные.лПотериЗвука)
		{
			++_кПотерьЗвука;
			if (лОкноПоказано)
			{
				ОбновитьЗначение('статистика-потерьзвука', _кПотерьЗвука, true);
			}
		}

		if (оДанные.лЗабраковано)
		{
			++_кЗабраковано;
			if (лОкноПоказано)
			{
				ОбновитьЗначение('статистика-забраковано', _кЗабраковано, true);
			}
		}
	}

	function ПереполненБуферПроигрывателя(сСобытие, чПропущено)
	{
		++_кПереполненийБуфера;
		_чПропущеноВБуфере += чПропущено;
		if (ОкноПоказано())
		{
			ОбновитьЗначение('статистика-переполнено', _кПереполненийБуфера, true)
			.nextElementSibling.nextElementSibling.textContent = _чПропущеноВБуфере.toFixed(1);
		}
	}

	function ИсчерпанБуферПроигрывателя(лДосрочно)
	{
		++_кИсчерпанийБуфера;
		if (лДосрочно)
		{
			++_кИсчерпанийБуфераДосрочно;
		}
		if (ОкноПоказано())
		{
			ОбновитьЗначение('статистика-исчерпано', _кИсчерпанийБуфера, _кИсчерпанийБуфера >= ВЫДЕЛИТЬ_ИСЧЕРПАНИЕ_БУФЕРА);
		}
	}

	м_События.ДобавитьОбработчик('список-выбранварианттрансляции', ВыбранВариантТрансляции);
	м_События.ДобавитьОбработчик('проигрыватель-переполненбуфер', ПереполненБуферПроигрывателя);

	return {
		ОкноПоказано, ОткрытьОкно, ЗакрытьОкно,
		ОбновитьЗначение,
		ОчиститьИсторию,
		ПолучитьTargetDuration, ПолучитьДлительностьКадраВСекундах,
		ПолучитьДанныеДляОтчета,
		СкачаноНечто,
		РазобранСписокСегментов,
		ДобавленыСегментыВОчередь,
		ЗагруженСегмент,
		НеЗагруженыСегменты,
		ОтосланИсходныйСегмент,
		ПолученПреобразованныйСегмент,
		ИсчерпанБуферПроигрывателя
	};
})();

const м_Чат = (() =>
{
	let _узЧат = null; // iframe
	let _лБоковаяПанельДоступна = false;
	let _сИмяКанала = ''; // Кэшируемое имя канала для заголовка боковой панели.

	function ПолучитьПоложениеПанели()
	// Возвращает текущую сторону даже если включено автоположение панели.
	{
		switch (getComputedStyle(document.getElementById('проигрывательичат')).flexDirection)
		{
			case 'column-reverse': return ВЕРХНЯЯ_СТОРОНА;
			case 'row': return ПРАВАЯ_СТОРОНА;
			case 'column': return НИЖНЯЯ_СТОРОНА;
			case 'row-reverse': return ЛЕВАЯ_СТОРОНА;
			default: Проверить(false);
		}
	}

	function ВставитьПанель()
	{
		if (!_узЧат)
		{
			НачатьИздеватьсяНадЧатом(г_чИдВкладки);
			// Чат перенаправляет twitch.tv на www.twitch.tv, потом меняет document.domain c www.twitch.tv на twitch.tv.
			// Атрибут sandbox запрещает менять document.domain, поэтому sandbox использовать нельзя.
			const сАдрес = м_Twitch.ПолучитьАдресПанелиЧата();
			м_Журнал.Вот(`[Чат] Вставляю iframe ${сАдрес}`);
			_узЧат = document.createElement('iframe');
			_узЧат.id = 'чат';
			_узЧат.width = м_Настройки.Получить('чШиринаПанелиЧата');
			_узЧат.height = м_Настройки.Получить('чВысотаПанелиЧата');
			// UNDONE HACK https://bugs.chromium.org/p/chromium/issues/detail?id=793280
			/*if (ВЕРСИЯ_ДВИЖКА_БРАУЗЕРА > 55 && ВЕРСИЯ_ДВИЖКА_БРАУЗЕРА < 66)
			_узЧат.src = сАдрес;
			{
				const чСкрытьНа = Math.round(2000 - performance.now());
				if (чСкрытьНа > 0)
				{
					// Во время ожидания таймера _узЧат может измениться.
					const оСтиль = _узЧат.style;
					оСтиль.opacity = '0';
					setTimeout(
						() =>
						{
							оСтиль.visibility = 'hidden';
							setTimeout(
								() =>
								{
									оСтиль.opacity = оСтиль.visibility = '';
								},
								1000
							);
						},
						чСкрытьНа
					);
				}
			}*/
			document.getElementById('размерчата').insertAdjacentElement('afterend', _узЧат);
		}
	}

	function УдалитьПанель()
	{
		if (_узЧат)
		{
			м_Журнал.Вот(`[Чат] Удаляю iframe ${_узЧат.src}`);
			_узЧат.remove();
			_узЧат = null;
		}
	}

	function ОбновитьАдресПанели()
	{
		if (_узЧат)
		{
			м_Журнал.Окак('[Чат] Обновляю адрес iframe');
			УдалитьПанель();
			ВставитьПанель();
		}
	}

	function ОбновитьСостояниеПанели()
	// Вызвать, если изменилась настройка чСостояниеЧата.
	// Проще не удалять iframe, а менять его src, но тогда в чате кнопки браузера Вперед и Назад будут перезагружать чат.
	{
		const чСостояние = м_Настройки.Получить('чСостояниеЧата');
		м_Журнал.Окак(`[Чат] Новое состояние панели: ${чСостояние}`);
		ОтменитьПеретаскиваниеПанели();
		switch (чСостояние)
		{
		case ЧАТ_ВЫГРУЖЕН:
			document.body.classList.remove('показатьчат');
			УдалитьПанель();
			break;

		case ЧАТ_СКРЫТ:
			ЗакрытьБоковуюПанель();
			ВставитьПанель();
			document.body.classList.remove('показатьчат');
			break;

		case ЧАТ_ПАНЕЛЬ:
			ЗакрытьБоковуюПанель();
			ВставитьПанель();
			document.body.classList.add('показатьчат');
			break;

		default:
			Проверить(false);
		}
	}

	function ОбновитьПоложениеПанели()
	// Вызвать, если изменились настройки, влияющие на положение чата.
	{
		ОтменитьПеретаскиваниеПанели();
		const оКлассы = document.body.classList;
		if (м_Настройки.Получить('лАвтоПоложениеЧата'))
		{
			оКлассы.add('автоположениечата');
			оКлассы.toggle('чатвверху', м_Настройки.Получить('чВертикальноеПоложениеЧата') === ВЕРХНЯЯ_СТОРОНА);
			оКлассы.toggle('чатслева', м_Настройки.Получить('чГоризонтальноеПоложениеЧата') === ЛЕВАЯ_СТОРОНА);
		}
		else
		{
			const чПоложение = м_Настройки.Получить('чПоложениеПанелиЧата');
			оКлассы.remove('автоположениечата');
			оКлассы.toggle('чатвверху', чПоложение === ВЕРХНЯЯ_СТОРОНА);
			оКлассы.toggle('чатсправа', чПоложение === ПРАВАЯ_СТОРОНА);
			оКлассы.toggle('чатвнизу', чПоложение === НИЖНЯЯ_СТОРОНА);
			оКлассы.toggle('чатслева', чПоложение === ЛЕВАЯ_СТОРОНА);
		}
	}

	function ПереключитьСостояниеПанели()
 	{
		switch (м_Настройки.Получить('чСостояниеЧата'))
		{
		case ЧАТ_ВЫГРУЖЕН:
		case ЧАТ_СКРЫТ:
			м_Настройки.Изменить('чСостояниеЧата', ЧАТ_ПАНЕЛЬ);
			break;

		case ЧАТ_ПАНЕЛЬ:
			м_Настройки.Изменить('чСостояниеЧата', м_Настройки.Получить('чСостояниеЗакрытогоЧата'));
			break;

		default:
			Проверить(false);
		}
		ОбновитьСостояниеПанели();
	}

	function ЗадатьСостояниеЗакрытойПанели(чНовоеСостояние)
	{
		м_Настройки.Изменить('чСостояниеЗакрытогоЧата', чНовоеСостояние);
		const чСтароеСостояние = м_Настройки.Получить('чСостояниеЧата');
		if ((чСтароеСостояние === ЧАТ_ВЫГРУЖЕН || чСтароеСостояние === ЧАТ_СКРЫТ) && чСтароеСостояние !== чНовоеСостояние)
		{
			м_Настройки.Изменить('чСостояниеЧата', чНовоеСостояние);
			ОбновитьСостояниеПанели();
		}
	}

	function ПереключитьПоложениеПанели()
 	{
		let чПоложение;
		if (м_Настройки.Получить('лАвтоПоложениеЧата'))
		{
			м_Настройки.Изменить('лАвтоПоложениеЧата', false);
			чПоложение = ПолучитьПоложениеПанели();
		}
		else
		{
			чПоложение = м_Настройки.Получить('чПоложениеПанелиЧата');
		}
		switch (чПоложение)
		{
			case ВЕРХНЯЯ_СТОРОНА: м_Настройки.Изменить('чПоложениеПанелиЧата', ПРАВАЯ_СТОРОНА); break;
			case ПРАВАЯ_СТОРОНА:  м_Настройки.Изменить('чПоложениеПанелиЧата', НИЖНЯЯ_СТОРОНА); break;
			case НИЖНЯЯ_СТОРОНА:  м_Настройки.Изменить('чПоложениеПанелиЧата', ЛЕВАЯ_СТОРОНА); break;
			case ЛЕВАЯ_СТОРОНА:   м_Настройки.Изменить('чПоложениеПанелиЧата', ВЕРХНЯЯ_СТОРОНА); break;
			default: Проверить(false);
		}
		ОбновитьПоложениеПанели();
	}

	function ПроверитьДоступностьБоковойПанели()
	{
		_лБоковаяПанельДоступна = Boolean(window.opr && opr.sidebarAction);
		if (_лБоковаяПанельДоступна)
		{
			м_События.ДобавитьОбработчик('twitch-полученыметаданныеканала', ОбработатьПолучениеМетаданныхКанала);
		}
		else
		{
			м_Журнал.Ой('[Чат] Боковая панель браузера недоступна');
			const узМеню = document.getElementById('открытьбоковуюпанель'); // Пункт меню.
			узМеню.nextElementSibling.remove(); // Разделитель меню.
			узМеню.remove();
		}
	}


	function НастроитьБоковуюПанель(сАдрес, сЗаголовок, лОткрыть)
	{
		Проверить(сАдрес === undefined || сАдрес === '' || сАдрес.startsWith('http://') || сАдрес.startsWith('https://'));
		Проверить(сЗаголовок === undefined || typeof сЗаголовок === 'string');
		Проверить(сАдрес !== undefined || сЗаголовок !== undefined);
		const оМанифест = chrome.runtime.getManifest().sidebar_action;
		if (сАдрес !== undefined)
		{
			opr.sidebarAction.setPanel(
			{
				// Operа позволяет загружать в боковую панель только страницы расширения.
				// В Firefox нет такого ограничения.
				panel: оМанифест.default_panel + '#' + encodeURIComponent(сАдрес)
			});
		}
		if (сЗаголовок !== undefined)
		{
			opr.sidebarAction.setTitle(
			{
				// Эмулируем поведение Firefox 59+.
				title: сЗаголовок ? сЗаголовок : оМанифест.default_title
			});
		}
	}

	function НастроитьНашуБоковуюПанель(сАдрес, сЗаголовок)
	{
		opr.sidebarAction.getPanel({}, ДобавитьОбработчикИсключений(сТекущийАдрес =>
		{
			if (chrome.runtime.lastError)
			{
				throw `[Чат] Не удалось получить адрес боковой панели: ${chrome.runtime.lastError.message}`;
			}
			if (м_Twitch.ЭтоАдресПанелиЧата(decodeURIComponent((new URL(сТекущийАдрес)).hash.slice(1))))
			{
				НастроитьБоковуюПанель(сАдрес, сЗаголовок, false);
			}
		}));
	}

	function ОткрытьБоковуюПанель()
	{
		if (_лБоковаяПанельДоступна)
		{
			м_Настройки.Изменить('чСостояниеЧата', ЧАТ_ВЫГРУЖЕН, true);
			ОбновитьСостояниеПанели();
			const сАдрес = м_Twitch.ПолучитьАдресПанелиЧата();
			м_Журнал.Окак(`[Чат] Открываю боковую панель ${сАдрес}`);
			НастроитьБоковуюПанель(сАдрес, _сИмяКанала === '' ? '' : Текст('J0137', _сИмяКанала), true);
		}
	}

	function ЗакрытьБоковуюПанель()
	{
		if (_лБоковаяПанельДоступна)
		{
			м_Журнал.Окак('[Чат] Закрываю боковую панель');
			НастроитьНашуБоковуюПанель('', '');
		}
	}

	function ОбновитьАдресБоковойПанели()
	{
		if (_лБоковаяПанельДоступна)
		{
			const сАдрес = м_Twitch.ПолучитьАдресПанелиЧата();
			м_Журнал.Окак(`[Чат] Меняю адрес боковой панели на ${сАдрес}`);
			НастроитьНашуБоковуюПанель(сАдрес, undefined);
		}
	}

	function ОбработатьПолучениеМетаданныхКанала(сСобытие, оМетаданные)
	// Имя канала может быть получено после открытия боковой панели.
	// Также теоретически имя канала может измениться во время трансляции.
	{
		if (оМетаданные.сИмя !== undefined && оМетаданные.сИмя !== _сИмяКанала)
		{
			м_Журнал.Окак(`[Чат] Меняю заголовок боковой панели с ${_сИмяКанала} на ${оМетаданные.сИмя}`);
			_сИмяКанала = оМетаданные.сИмя;
			НастроитьНашуБоковуюПанель(undefined, Текст('J0137', оМетаданные.сИмя));
		}
	}

	let _чНачальныйРазмер;
	function ОбработатьПеретаскиваниеПанели(чШаг, узТащится, чИзменениеX, чИзменениеY, лИзменилсяX, лИзменилсяY)
	// TODO Если включено автоположение, то положение панели может измениться во время перетаскивания.
	{
		const чПоложение = ПолучитьПоложениеПанели();
		const лИзменитьШирину = чПоложение === ПРАВАЯ_СТОРОНА || чПоложение === ЛЕВАЯ_СТОРОНА;
		const лОбратноеНаправление = чПоложение === ВЕРХНЯЯ_СТОРОНА || чПоложение === ЛЕВАЯ_СТОРОНА;
		switch (чШаг)
		{
		case 1:
			if (лИзменитьШирину)
			{
				// Учитывать min-width.
				_чНачальныйРазмер = Number.parseInt(getComputedStyle(_узЧат).width, 10);
			}
			else
			{
				// Учитывать min-height.
				_чНачальныйРазмер = Number.parseInt(getComputedStyle(_узЧат).height, 10);
			}
			м_Журнал.Окак(`[Чат] Начальный размер чата: ${_чНачальныйРазмер}`);
			break;

		case 2:
			if (лИзменитьШирину)
			{
				if (лИзменилсяX)
				{
					const чМаксРазмер = Number.parseInt(getComputedStyle(document.getElementById('проигрывательичат')).width, 10)
					                  - Number.parseInt(getComputedStyle(document.getElementById('проигрыватель')).minWidth, 10);
					_узЧат.width = Math.max(Math.min(лОбратноеНаправление ? _чНачальныйРазмер - чИзменениеX : _чНачальныйРазмер + чИзменениеX, чМаксРазмер), 0);
				}
			}
			else
			{
				if (лИзменилсяY)
				{
					const чМаксРазмер = Number.parseInt(getComputedStyle(document.getElementById('проигрывательичат')).height, 10);
					                  - Number.parseInt(getComputedStyle(document.getElementById('проигрыватель')).minHeight, 10);
					_узЧат.height = Math.max(Math.min(лОбратноеНаправление ? _чНачальныйРазмер - чИзменениеY : _чНачальныйРазмер + чИзменениеY, чМаксРазмер), 0);
				}
			}
			break;

		case 3:
			if (лИзменитьШирину)
			{
				м_Настройки.Изменить('чШиринаПанелиЧата', Number.parseInt(getComputedStyle(_узЧат).width, 10));
			}
			else
			{
				м_Настройки.Изменить('чВысотаПанелиЧата', Number.parseInt(getComputedStyle(_узЧат).height, 10));
			}
			break;

		default:
			Проверить(false);
		}
	}

	function ОтменитьПеретаскиваниеПанели()
	{
		м_Тащилка.ОтменитьПеретаскивание('размерчата');
	}

	function ОбновитьАдрес()
	// Вызвать, если изменились настройки, влияющие на адрес чата.
	{
		ОбновитьАдресПанели();
		ОбновитьАдресБоковойПанели();
	}

	function Восстановить()
	{
		ОбновитьСостояниеПанели();
		ОбновитьПоложениеПанели();
		м_Тащилка.ДобавитьОбработчик('размерчата', ОбработатьПеретаскиваниеПанели);
	}

	ПроверитьДоступностьБоковойПанели();
	
	return {
		Восстановить,
		ОбновитьПоложениеПанели,
		ОбновитьАдрес,
		ПереключитьСостояниеПанели,
		ПереключитьПоложениеПанели,
		ЗадатьСостояниеЗакрытойПанели,
		ОткрытьБоковуюПанель
	};
})();

const м_Новости = (() =>
{
	function ПеревестиВерсиюВМиллисекунды(сВерсия)
	// Возвращает Date.getTime(). Число можно использовать для сравнения версий.
	{
		var мчЧасти = /^(\d+)\.(\d+)\.(\d+)(?:\.(\d+))?$/.exec(сВерсия);
		мчЧасти[1] |= 0;
		мчЧасти[2] |= 0;
		мчЧасти[3] |= 0;
		мчЧасти[4] |= 0;
		Проверить(мчЧасти[1] >= 2000 && мчЧасти[1] <= 2050);
		Проверить(мчЧасти[2] >=    1 && мчЧасти[2] <=   12);
		Проверить(мчЧасти[3] >=    1 && мчЧасти[3] <=   31);
		Проверить(мчЧасти[4] >=    0 && мчЧасти[4] <=    9);
		return Date.UTC(мчЧасти[1], мчЧасти[2] - 1, мчЧасти[3], 0, 0, 0, мчЧасти[4]);
	}

	function УдалитьВсеНовости()
	{
		document.getElementById('текстновостей').textContent = '';
	}

	function ДобавитьНовость(мНовость, чДатаНовости)
	{
		const узВставить = document.getElementById('текстновостей');

		if (узВставить.firstElementChild)
		{
			узВставить.insertBefore(document.createElement('hr'), узВставить.firstElementChild);
		}

		for (let ы = мНовость.length; --ы >= 2;)
		{
			м_i18n.InsertAdjacentHtmlMessage(узВставить, 'afterbegin', мНовость[ы]);
		}

		const узЗаголовок = document.createElement('h4');
		if (чДатаНовости !== 0)
		{
			узЗаголовок.textContent = `${(new Date(чДатаНовости)).toLocaleDateString()}\u2002·\u2002${Текст(мНовость[1])}`;
		}
		else
		{
			узЗаголовок.textContent = Текст(мНовость[1]);
		}
		узВставить.insertBefore(узЗаголовок, узВставить.firstChild);
	}

	function ДобавитьНовости(пДобавитьВерсию, лДобавитьСправку)
	// пДобавитьВерсию:
	//   если число, то максимальное количество добавляемых новостей, не считая справки
	//   если строка, то добавлять новости для версий > пДобавитьВерсию
	// Возвращает true, если добавлена хотя бы одна новость, включая справку.
	{
		Проверить((ЭтоЧисло(пДобавитьВерсию) && пДобавитьВерсию >= 0) || ЭтоНепустаяСтрока(пДобавитьВерсию));

		УдалитьВсеНовости();

		let лДобавленыНовости = false;
		let чДобавитьВерсию = typeof пДобавитьВерсию === 'number' ? пДобавитьВерсию : ПеревестиВерсиюВМиллисекунды(пДобавитьВерсию);
		for (let мНовость of г_мНовости)
		{
			switch (мНовость[0])
			{
			case '2000.2.2': // Показывать всегда.
				ДобавитьНовость(мНовость, 0);
				break;

			case '2000.1.1': // Справка.
				if (лДобавитьСправку)
				{
					лДобавленыНовости = true;
					ДобавитьНовость(мНовость, 0);
				}
				break;

			default:
				const чВерсия = ПеревестиВерсиюВМиллисекунды(мНовость[0]);
				if (typeof пДобавитьВерсию === 'number')
				{
					if (--чДобавитьВерсию < 0)
					{
						continue;
					}
				}
				else
				{
					if (чДобавитьВерсию >= чВерсия)
					{
						continue;
					}
				}
				лДобавленыНовости = true;
				ДобавитьНовость(мНовость, чВерсия);
			}
		}
		return лДобавленыНовости;
	}

	const ОбработатьПрокруткуТекста = ДобавитьОбработчикИсключений(оСобытие =>
	{
		if (ЭлементПолностьюПрокручен(оСобытие.target))
		{
			ПоказатьЭлемент('прокрутитьновости', false);
			оСобытие.target.removeEventListener('scroll', ОбработатьПрокруткуТекста);
		}
	});

	function ОбработатьОткрытиеОкна(сСобытие, сИдОкна)
	{
		if (сИдОкна === 'новости')
		{
			const узТекст = document.getElementById('текстновостей');
			// Возможно повторное открытие ранее прокрученных новостей.
			узТекст.scrollTop = 0;
			if (!ЭлементПолностьюПрокручен(узТекст))
			{
				ПоказатьЭлемент('прокрутитьновости', true);
				узТекст.addEventListener('scroll', ОбработатьПрокруткуТекста);
			}

			ПоказатьЭлемент('переключитьновости', false)
			.classList.remove('непрочитано');
		}
	}

	function ОбработатьЗакрытиеОкна(сСобытие, оСобытие)
	// Не удалять текст, чтобы не портить анимацию закрытия.
	{
		if (оСобытие.сИдОкна === 'новости')
		{
			// Отключить анимацию.
			ПоказатьЭлемент('прокрутитьновости', false);
			document.getElementById('текстновостей').removeEventListener('scroll', ОбработатьПрокруткуТекста);

			// Отложить чтение новостей?
			if (оСобытие.сДанные === 'отмена' && ЭлементПоказан('отложитьновости'))
			{
				ПоказатьЭлемент('переключитьновости', true);
			}
			else
			{
				м_Настройки.Изменить('сПредыдущаяВерсия', ВЕРСИЯ_РАСШИРЕНИЯ);
			}
		}
	}

	function Запустить()
	{
		м_События.ДобавитьОбработчик('окна-открытоокно', ОбработатьОткрытиеОкна);
		м_События.ДобавитьОбработчик('окна-закрытоокно', ОбработатьЗакрытиеОкна);

		const сПредыдущаяВерсия = м_Настройки.Получить('сПредыдущаяВерсия');
		if (сПредыдущаяВерсия !== ВЕРСИЯ_РАСШИРЕНИЯ)
		{
			// Первый запуск расширения?
			if (сПредыдущаяВерсия === '2000.1.1')
			{
				ДобавитьНовости(0, true);
				ПоказатьЭлемент('отложитьновости', false);
				ПоказатьЭлемент('переключитьновости', true);
			}
			else if (ДобавитьНовости(сПредыдущаяВерсия, false))
			{
				ПоказатьЭлемент('отложитьновости', true);
				ПоказатьЭлемент('переключитьновости', true);
			}
			else
			{
				м_Настройки.Изменить('сПредыдущаяВерсия', ВЕРСИЯ_РАСШИРЕНИЯ);
			}
		}
	}

	function ОткрытьСправку()
	{
		if (м_Окна.ПолучитьОткрытоеОкно() !== 'новости')
		{
			if (!ЭлементПоказан('переключитьновости'))
			{
				ДобавитьНовости(3, true);
				ПоказатьЭлемент('отложитьновости', false);
			}
			м_Окна.ОткрытьОкно('новости');
		}
	}
	
	return {
		Запустить,
		ОткрытьСправку
	};
})();

const м_Шкала = (() =>
{
	var _чНачало = 0;
	var _чКонец  = 0;
	var _чПросмотрено;

	function ОграничитьВремя(чВремя)
	{
		return Ограничить(чВремя, _чНачало, _чКонец);
	}

	function Обновить()
	{
		Проверить(Number.isFinite(_чНачало) && Number.isFinite(_чКонец) && Number.isFinite(_чПросмотрено));
		document.getElementById('шкала-просмотрено').style.transform = `scaleX(${((_чПросмотрено - _чНачало) / (_чКонец - _чНачало)).toFixed(4)})`;
	}

	const ОбработатьЩелчок = ДобавитьОбработчикИсключений(оСобытие =>
	{
		if (м_Управление.ПолучитьСостояние() === СОСТОЯНИЕ_ПОВТОР)
		{
			const оБордюр = оСобытие.currentTarget.getBoundingClientRect();
			const оСтиль = getComputedStyle(оСобытие.currentTarget);
			// У шкалы пока нет бордюра.
			const чНачалоШкалы = Math.round(оБордюр.left + Number.parseFloat(оСтиль.paddingLeft));
			const чКонецШкалы = Math.round(оБордюр.right - Number.parseFloat(оСтиль.paddingRight));
			// Windows 7: Hot spot курсора pointer находится левее центра указательного пальца. Исправляем это надоразумение.
			const чУказатель = оСобытие.clientX + 1;
			// Щелчок по левому полю перематывает на первый кадр. По правому полю - на последний.
			const чПеремотатьДо = ОграничитьВремя((чУказатель - чНачалоШкалы) / (чКонецШкалы - чНачалоШкалы) * (_чКонец - _чНачало) + _чНачало);
			м_Журнал.Окак(`[Шкала] Перематываю до ${чПеремотатьДо}`);
			м_Проигрыватель.ПеремотатьПовторДо(чПеремотатьДо);
		}
	});

	function ЗадатьНачалоИКонец(чНачало, чКонец)
	{
		Проверить(чНачало <= чКонец);
		_чНачало = чНачало;
		_чКонец = чКонец;
		document.getElementById('шкала').addEventListener('click', ОбработатьЩелчок);
	}

	function ЗадатьПросмотрено(чПросмотрено)
	{
		_чПросмотрено = ОграничитьВремя(чПросмотрено);
		Обновить();
	}

	function ПолучитьНачало()
	{
		return _чНачало;
	}

	function ПолучитьКонец()
	{
		return _чКонец;
	}

	return {
		ЗадатьНачалоИКонец, ЗадатьПросмотрено,
		ПолучитьНачало, ПолучитьКонец
	};
})();

const м_Окна = (() =>
{
	function ПолучитьОткрытоеОкно()
	{
		return document.body.getAttribute('data-окно-открыто') || '';
	}

	function ЗакрытьОкно(сИдОкна, сДанные)
	{
		Проверить(typeof сИдОкна === 'string' && typeof сДанные === 'string');
		if (сИдОкна && сИдОкна === ПолучитьОткрытоеОкно())
		{
			document.getElementById(сИдОкна).classList.remove('окнооткрыто');
			document.body.removeAttribute('data-окно-открыто');
			м_События.ОбработатьСобытие('окна-закрытоокно', {сИдОкна, сДанные});
		}
	}

	function ОткрытьОкно(сИдОкна)
	{
		Проверить(ЭтоНепустаяСтрока(сИдОкна));
		const сИдОткрытогоОкна = ПолучитьОткрытоеОкно();
		if (сИдОкна !== сИдОткрытогоОкна)
		{
			ЗакрытьОкно(сИдОткрытогоОкна, 'отмена');

			document.getElementById(сИдОкна).classList.add('окнооткрыто');
			document.body.setAttribute('data-окно-открыто', сИдОкна);
			м_События.ОбработатьСобытие('окна-открытоокно', сИдОкна);
		}
	}

	function ПереключитьОкно(сИдОкна, сДанные = '')
	{
		Проверить(ЭтоНепустаяСтрока(сИдОкна) && typeof сДанные === 'string');
		const сИдОткрытогоОкна = ПолучитьОткрытоеОкно();
		if (сИдОкна === сИдОткрытогоОкна)
		{
			ЗакрытьОкно(сИдОткрытогоОкна, сДанные);
		}
		else
		{
			ЗакрытьОкно(сИдОткрытогоОкна, 'отмена');
			ОткрытьОкно(сИдОкна);
		}
	}

	function ОбработатьЩелчок(сСобытие, оСобытие)
	{
		if (оСобытие.лВПроигрывателе)
		{
			const сИдОкна = оСобытие.target.getAttribute('data-окно-переключить');
			if (сИдОкна)
			{
				ПереключитьОкно(сИдОкна, оСобытие.target.getAttribute('data-окно-данные') || '');
			}
			else
			{
				// TODO Safari Mobile посылает событие click не для всех элементов. Перенести эту проверку в обработчик mousedown?
				// https://developer.mozilla.org/en-US/docs/Web/Events/click#Safari_Mobile
				const сИдОткрытогоОкна = ПолучитьОткрытоеОкно();
				if (сИдОткрытогоОкна && !document.getElementById(сИдОткрытогоОкна).contains(оСобытие.target))
				{
					ЗакрытьОкно(сИдОткрытогоОкна, 'отмена');
				}
			}
		}
	}

	м_События.ДобавитьОбработчик('управление-щелчок', ОбработатьЩелчок);

	return {
		ПолучитьОткрытоеОкно,
		ПереключитьОкно,
		ОткрытьОкно
	};
})();

const м_Меню = (() =>
{
	function ПолучитьОткрытоеМеню()
	{
		return document.getElementsByClassName('менюоткрыто')[0];
	}

	function ОткрытьМеню(узМеню)
	{
		узМеню.addEventListener('mouseleave', ОбработатьПокиданиеМеню);
		document.body.classList.remove('меню-безанимации');
		узМеню.classList.add('менюоткрыто');
	}

	function ЗакрытьМеню(узМеню, лБезАнимации)
	{
		узМеню.removeEventListener('mouseleave', ОбработатьПокиданиеМеню);
		document.body.classList.toggle('меню-безанимации', лБезАнимации);
		узМеню.classList.remove('менюоткрыто');
	}

	function ПереместитьМеню(узМеню, x, y)
	{
		Проверить(Number.isFinite(x) && Number.isFinite(y));
		// getComputedStyle() не учитывает transform, в отличие от getBoundingClientRect().
		const оСтиль = getComputedStyle(узМеню);
		const чШирина = Number.parseFloat(оСтиль.width,  10);
		const чВысота = Number.parseFloat(оСтиль.height, 10);
		Проверить(чШирина > 0 && чВысота > 0);
		let чЛево = x - чШирина * 0.2;
		let чВерх = y - чВысота * 0.5;
		if (чЛево + чШирина > window.innerWidth)
		{
			чЛево = window.innerWidth - чШирина;
		}
		if (чВерх + чВысота > window.innerHeight)
		{
			чВерх = window.innerHeight - чВысота;
		}
		узМеню.style.left = `${Math.floor(Math.max(чЛево, 0))}px`;
		узМеню.style.top  = `${Math.floor(Math.max(чВерх, 0))}px`;
	}

	const ОбработатьПокиданиеМеню = ДобавитьОбработчикИсключений(оСобытие =>
	{
		ЗакрытьМеню(оСобытие.target, false);
	});

	const ОбработатьПравыйЩелчок = ДобавитьОбработчикИсключений(оСобытие =>
	{
		const узОткрытоеМеню = ПолучитьОткрытоеМеню();
		if (узОткрытоеМеню && узОткрытоеМеню.contains(оСобытие.target))
		{
			// Ссылки в меню я скорее всего запрещу выделять, поэтому ЭтоСобытиеДляСсылки() вместо ЭтотЭлементМожноВыделить().
			if (!ЭтоСобытиеДляСсылки(оСобытие))
			{
				оСобытие.preventDefault();
			}
			return;
		}
		// Контекстное меню браузера запрещать...
		// - Нужно для тега video, команды которого могут поломать работу проигрывателя.
		// - Нельзя для ссылок, там есть полезные команды. Ссылки разрешено выделять.
		// - Нельзя для элементов, содержимое которых можно выделить, потому что на сенсорном экране выделение
		// начинается "правым щелчком". Для настольных компьютеров контекстное меню браузера пригодится, чтобы
		// совершить действие над выделенным текстом: копировать, искать в интернете.
		let узОткрытьМеню = null;
		if (!ЭтотЭлементМожноВыделить(оСобытие.target))
		{
			оСобытие.preventDefault();
			узОткрытьМеню = document.getElementById('контекстноеменю');
		}
		if (узОткрытоеМеню && узОткрытоеМеню !== узОткрытьМеню)
		{
			ЗакрытьМеню(узОткрытоеМеню);
		}
		return; // UNDONE
		if (узОткрытьМеню)
		{
			ПереместитьМеню(узОткрытьМеню, оСобытие.clientX, оСобытие.clientY);
			if (узОткрытьМеню !== узОткрытоеМеню)
			{
				ОткрытьМеню(узОткрытьМеню);
			}
		}
	});

	function ОбработатьЛевыйЩелчок(сСобытие, оСобытие)
	{
		const узЩелчок = оСобытие.target;
		// Закрыть меню после щелчка по его пункту.
		if (узЩелчок.classList.contains('меню-пункт'))
		{
			if (узЩелчок.hasAttribute('tabindex'))
			{
				ЗакрытьМеню(узЩелчок.parentNode, true);
			}
			return;
		}
		const узОткрытоеМеню = ПолучитьОткрытоеМеню();
		if (узОткрытоеМеню && !узОткрытоеМеню.contains(узЩелчок))
		{
			ЗакрытьМеню(узОткрытоеМеню, false);
		}
		// Открыть меню после нажатия на кнопку.
		if (узЩелчок.classList.contains('кнопкаименю-кнопка'))
		{
			const узОткрытьМеню = узЩелчок.nextElementSibling;
			if (узОткрытьМеню !== узОткрытоеМеню)
			{
				ОткрытьМеню(узОткрытьМеню);
			}
		}
	}

	// Нажатие SHIFT+F10 может послать событие в html и body.
	document.addEventListener('contextmenu', ОбработатьПравыйЩелчок);
	м_События.ДобавитьОбработчик('управление-щелчок', ОбработатьЛевыйЩелчок);

	return {};
})();

const м_Управление = (() =>
{
	// После изменения этой константы также изменить всплывающую подсказку.
	const ПЕРЕМАТЫВАТЬ_СТРЕЛКАМИ_НА      = 5;    // Секунды, назад и вперед.
	const ПЕРЕМАТЫВАТЬ_ПО_КАДРАМ_НА      = 5;    // Кадры, только назад.

	const МАКСИМАЛЬНАЯ_ЧАСТОТА_MOUSEMOVE = 10;   // Количество событий в секунду.
	const ПОРОГ_НАЧАЛА_ДВИЖЕНИЯ          = 180;  // Миллисекунды. Зависит от МАКСИМАЛЬНАЯ_ЧАСТОТА_MOUSEMOVE.
	                                             // Немного уменьшить чтобы гарантировать начало движения после двух MOUSEMOVE (≈ 200 мс).
	                                             // Частота опроса последовательной мыши 60 Гц.
	const ПОРОГ_ОКОНЧАНИЯ_ДВИЖЕНИЯ       = 300;  // Миллисекунды.

	const ПОКАЗЫВАТЬ_ПРОПУСК_ВИДЕО       = 1500; // Миллисекунды.

	// Текст для ссылки если метаданные не загружены.
	const НАЗВАНИЕ_ТРАНСЛЯЦИИ_НЕИЗВЕСТНО = '• • •';

	const ЯЗЫКИ =
	{
		'da':    'Dansk',
		'de':    'Deutsch',
		'en':    'English',
		'en-gb': 'English (UK)',
		'es':    'Español',
		'es-mx': 'Español (Latinoamérica)',
		'fr':    'Français',
		'it':    'Italiano',
		'hu':    'Magyar',
		'nl':    'Nederlands',
		'no':    'Norsk',
		'pl':    'Polski',
		'pt':    'Português',
		'pt-br': 'Português (Brasil)',
		'sk':    'Slovenčina',
		'fi':    'Suomi',
		'sv':    'Svenska',
		'vi':    'Tiếng Việt',
		'tr':    'Türkçe',
		'cs':    'Čeština',
		'el':    'Ελληνικά',
		'bg':    'Български',
		'ru':    'Русский',
		'ar':    'العربية',
		'th':    'ภาษาไทย',
		'zh':    '中文',
		'zh-cn': '简体中文',
		'zh-tw': '繁體中文',
		'zh-hk': '中文（香港）',
		'ja':    '日本語',
		'ko':    '한국어',
		'hi':    'हिंदी',
		'ro':    'Română',
		'ase':   'American Sign Language',
		'asl':   'American Sign Language' // Twitch передает этот неправильный код.
	};

	var _чСостояние;
	var _оНачалоВоспроизведения, _оРазмерБуфера, _оРастягиваниеБуфера, _оИнтервалОбновленияСписков, _оДлительностьПовтора;
	var _оРазмерИнтерфейса, _оИнтервалАвтоскрытия;
	var _чТаймерПропуска = 0;
	
	var _чНачалоДвижения           = 0;
	var _чПоследнееДвижение        = 0;
	var _чТаймерАвтоскрытия        = 0;
	var _чАвтоскрытиеX1, _чАвтоскрытиеY1, _чАвтоскрытиеX2, _чАвтоскрытиеY2;

	if (document.exitFullscreen)
	{
		var _sFullscreenElement = 'fullscreenElement';
		var _sRequestFullscreen = 'requestFullscreen';
		var _sExitFullscreen    = 'exitFullscreen';
		var _sFullscreenchange  = 'fullscreenchange';
	}
	else
	{
		var _sFullscreenElement = 'webkitFullscreenElement';
		var _sRequestFullscreen = 'webkitRequestFullscreen';
		var _sExitFullscreen    = 'webkitExitFullscreen';
		var _sFullscreenchange  = 'webkitfullscreenchange';
	}

	function ЗапуститьПолноэкранныйРежим()
	{
		ОбновитьПолноэкранныйРежим();
		document.addEventListener(_sFullscreenchange, ОбработатьИзменениеПолноэкранногоРежима);
	}

	function ОбновитьПолноэкранныйРежим()
	{
		var лАктивен = !!document[_sFullscreenElement];
		м_Журнал.Окак(`[Управление] Полноэкранный режим: ${лАктивен}`);
		ИзменитьКнопку('переключитьполноэкранный', лАктивен);
	}

	const ОбработатьИзменениеПолноэкранногоРежима = ДобавитьОбработчикИсключений(() =>
	{
		ОбновитьПолноэкранныйРежим();
	});

	function ПереключитьПолноэкранныйРежим()
	{
		// Анимация во время изменения размеров окна смотрится хреново.
		ВключитьАвтоскрытие(true);
		if (document[_sFullscreenElement])
		{
			ОтключитьПолноэкранныйРежим();
		}
		else
		{
			ВключитьПолноэкранныйРежим();
		}
	}

	function ВключитьПолноэкранныйРежим()
	{
		м_Журнал.Вот('[Управление] Вход в полноэкранный режим');
		document.getElementById('проигрыватель')[_sRequestFullscreen]();
	}

	function ОтключитьПолноэкранныйРежим()
	// Может вызываться до ЗапуститьПолноэкранныйРежим().
	{
		м_Журнал.Вот('[Управление] Выход из полноэкранного режима');
		document[_sExitFullscreen]();
	}

	function ОтключитьАвтоскрытие()
	// Возвращает true если изменилось состояние автоскрытия.
	{
		let лСостояниеИзменилось = false;
		// Автоскрытие включено?
		if (_чТаймерАвтоскрытия === 0)
		{
			// Панели могут быть показаны даже при наличии класса 'автоскрытие'. См. АВТОСКРЫТИЕ_ПАНЕЛЕЙ в player.css.
			лСостояниеИзменилось = getComputedStyle(document.getElementById('глаз')).cursor === 'none';
			document.body.classList.remove('автоскрытие', 'панель-безанимации');
		}
		else
		{
			clearTimeout(_чТаймерАвтоскрытия);
		}
		_чТаймерАвтоскрытия = setTimeout(ОбработатьВключениеАвтоскрытия, м_Настройки.Получить('чИнтервалАвтоскрытия') * 1000);
		return лСостояниеИзменилось;
	}

	function ВключитьАвтоскрытие(лБезАнимации)
	{
		// Автоскрытие отключено?
		if (_чТаймерАвтоскрытия !== 0)
		{
			clearTimeout(_чТаймерАвтоскрытия);
			_чТаймерАвтоскрытия = 0;
			document.body.classList.add('автоскрытие');
			document.body.classList.toggle('панель-безанимации', лБезАнимации);
			if (лБезАнимации)
			{
				// Не реагировать на небольшие движения мыши.
				_чНачалоДвижения = _чПоследнееДвижение = performance.now();
			}
		}
	}

	const ОбработатьВключениеАвтоскрытия = ДобавитьОбработчикИсключений(() =>
	{
		ВключитьАвтоскрытие(false);
	});

	function ОбработатьРедкоеДвижениеМыши(оСобытие)
	{
		// Chrome 52: При входе в полноэкранный режим посылаются mousemove, даже если мышь не двигалась.
		// Координаты screen могут изменяться во время WIN + TAB, поэтому добавляем проверку client.
		if ((_чАвтоскрытиеX1 !== оСобытие.screenX || _чАвтоскрытиеY1 !== оСобытие.screenY)
		&&  (_чАвтоскрытиеX2 !== оСобытие.clientX || _чАвтоскрытиеY2 !== оСобытие.clientY))
		{
			_чАвтоскрытиеX1 = оСобытие.screenX; _чАвтоскрытиеY1 = оСобытие.screenY;
			_чАвтоскрытиеX2 = оСобытие.clientX; _чАвтоскрытиеY2 = оСобытие.clientY;
			// Игнорировать движение, продолжительность которого меньше ПОРОГ_НАЧАЛА_ДВИЖЕНИЯ.
			// Зритель мог случайно задеть мышь или стол, на котором она лежит.
			// "Лишнее" отключение автоскрытия во время просмотра может раздражать.
			var чВремя = performance.now();
			if (чВремя - _чПоследнееДвижение >= ПОРОГ_ОКОНЧАНИЯ_ДВИЖЕНИЯ)
			{
				_чНачалоДвижения = _чПоследнееДвижение = чВремя;
			}
			else
			{
				_чПоследнееДвижение = чВремя;
				if (чВремя - _чНачалоДвижения >= ПОРОГ_НАЧАЛА_ДВИЖЕНИЯ)
				{
					ОтключитьАвтоскрытие();	
				}
			}
		}
	}

	const ОбработатьДвижениеМыши = ДобавитьОбработчикИсключений(оСобытие =>
	{
		// mousemove может посылаться с высокой частотой, если используется мышь USB 1000 Гц.
		// В этом случае моя обработка события занимает всего пару процентов не самого сильного
		// процессора. Но Chrome 51 не любит, когда часто вызывается setTimeout(). Да и очередь
		// ни к чему захламлять ненужными событиями. Поэтому частота обработки mousemove уменьшается
		// до МАКСИМАЛЬНАЯ_ЧАСТОТА_MOUSEMOVE. Высокая точность для автоскрытия не требуется.
		оСобытие.currentTarget.removeEventListener('mousemove', ОбработатьДвижениеМыши);
		ОбработатьРедкоеДвижениеМыши(оСобытие);
		setTimeout(ПерехватитьДвижениеМыши, 1000 / МАКСИМАЛЬНАЯ_ЧАСТОТА_MOUSEMOVE);
	});

	const ПерехватитьДвижениеМыши = ДобавитьОбработчикИсключений(() =>
	{
		document.getElementById('проигрыватель').addEventListener('mousemove', ОбработатьДвижениеМыши);
	});

	function ЗапуститьАвтоскрытие()
	{
		ПерехватитьДвижениеМыши();
		document.getElementById('проигрыватель').addEventListener('mouseleave', ОбработатьВключениеАвтоскрытия);
	}

	function ЗапуститьИзменениеГромкостиКолесом()
	{
		if (м_Настройки.Получить('лМенятьГромкостьКолесом'))
		{
			document.addEventListener('wheel', ОбработатьВращениеКолеса);
			document.addEventListener('mousedown', ОбработатьНажатиеМыши);
		}
		else
		{
			document.removeEventListener('wheel', ОбработатьВращениеКолеса);
			document.removeEventListener('mousedown', ОбработатьНажатиеМыши);
		}
	}

	const ОбработатьВращениеКолеса = ДобавитьОбработчикИсключений(оСобытие =>
	{
		if (!оСобытие.shiftKey && !оСобытие.ctrlKey && !оСобытие.altKey && !оСобытие.metaKey
		&& !ЭлементВЭтойТочкеМожноПрокрутить(оСобытие.clientX, оСобытие.clientY))
		{
			// Chrome 59 переводит строки в пикселы. Edge 15 переводит строки и страницы в пикселы.
			м_Журнал.Вот(`[Управление] Движение колеса deltaY=${оСобытие.deltaY} deltaMode=${оСобытие.deltaMode}`);
			оСобытие.preventDefault();
			if (оСобытие.deltaY < 0)
			{
				СохранитьИПрименитьНастройкиЗвука(false, Math.min(м_Настройки.Получить('чГромкость2') + ШАГ_ПОВЫШЕНИЯ_ГРОМКОСТИ_КОЛЕСОМ, МАКСИМАЛЬНАЯ_ГРОМКОСТЬ));
			}
			if (оСобытие.deltaY > 0)
			{
				СохранитьИПрименитьНастройкиЗвука(false, Math.max(м_Настройки.Получить('чГромкость2') - ШАГ_ПОНИЖЕНИЯ_ГРОМКОСТИ_КОЛЕСОМ, МИНИМАЛЬНАЯ_ГРОМКОСТЬ));
			}
		}
	});

	const ОбработатьНажатиеМыши = ДобавитьОбработчикИсключений(оСобытие =>
	{
		if (оСобытие.button === СРЕДНЯЯ_КНОПКА && !оСобытие.shiftKey && !оСобытие.ctrlKey && !оСобытие.altKey && !оСобытие.metaKey && !ЭтоСобытиеДляСсылки(оСобытие))
		{
			оСобытие.preventDefault();
			СохранитьИПрименитьНастройкиЗвука(!м_Настройки.Получить('лПриглушить'));
		}
	});

	function ИзменитьРазмерИнтерфейса()
	{
		// Не используем для 100% небольшие числа, например 1px, которые могут быть перебиты
		// настройкой минимального размера шрифта браузера. На данный момент 16px можно заменить
		// на большее значение (пересчитав rem в css). 10px маловато, потому что значение настройки
		// может быть меньше 100%.
		//document.documentElement.style.fontSize = `${16 * м_Настройки.Получить('чРазмерИнтерфейса') / 100}px`;
	}

	function ИзменитьАнимациюИнтерфейса()
	{
		document.body.classList.toggle('санимацией', м_Настройки.Получить('лАнимацияИнтерфейса'));
	}

	function ИзменитьКнопку(пКнопка, пСостояние)
	{
		var узКнопка = typeof пКнопка === 'string' ? document.getElementById(пКнопка) : пКнопка;
		var сузСостояния = узКнопка.getElementsByTagName('use');
		// В пСостояние может быть логическое значение.
		var чСостояние = Number(пСостояние);
		Проверить(чСостояние >= 0 && чСостояние < сузСостояния.length);
		for (var ы = 0; ы < сузСостояния.length; ++ы)
		{
			if (ы === чСостояние)
			{
				// Firefox 56: <title> и xlink:title не показывают всплывающую подсказку если находятся внутри <button>.
				// Edge 15: <title> иногда пропадает после автоскрытия панели.
				var сПодсказка = сузСостояния[ы].getAttributeNS('http://www.w3.org/1999/xlink', 'title');
				if (сПодсказка)
				{
					узКнопка.setAttribute('title', Текст(сПодсказка));
				}
				// Edge 15 падает если во время CSS transition программно менять xlink:href.
				сузСостояния[ы].removeAttribute('display');
			}
			else
			{
				сузСостояния[ы].setAttribute('display', 'none');
			}
		}
		return узКнопка;
	}

	function ПереключитьПросмотрТрансляции()
	{
		if (_чСостояние !== СОСТОЯНИЕ_ОСТАНОВКА && _чСостояние !== СОСТОЯНИЕ_ПОВТОР)
		{
			м_Журнал.Окак('[Управление] Останавливаю просмотр трансляции');
			м_Список.Остановить();
			// Удалить сегменты, застрявшие в рабочем потоке.
			м_Преобразователь.Остановить();
			// Очистить очередь и отменить загрузку сегментов.
			г_моОчередь.Очистить();
			// Изменить состояние, остановить воспроизведение, сменить поведение на повтор.
			г_моОчередь.Добавить(new Сегмент(ОБРАБОТКА_ПРЕОБРАЗОВАН, СОСТОЯНИЕ_ПОВТОР));
			// Ждать завершение _лАсинхроннаяОперация.
			м_Проигрыватель.ДобавитьСледующийСегмент();
		}
		else
		{
			м_Журнал.Окак('[Управление] Начинаю просмотр трансляции');
			// Удалить СОСТОЯНИЕ_ПОВТОР если оно еще находится в очереди.
			г_моОчередь.Очистить();
			// Изменить состояние, очистить буфер проигрывателя, сменить поведение на прямую трансляцию.
			м_Проигрыватель.Перезагрузить(СОСТОЯНИЕ_ЗАПУСК);
			м_Список.Запустить();
		}
	}
	
	function ИзменитьВариантТрансляции()
	// TODO Показывать старый вариант пока не загрузится новый.
	{
		// Изменить состояние, очистить буфер проигрывателя.
		м_Проигрыватель.Перезагрузить(СОСТОЯНИЕ_ЗАГРУЗКА);
		// Удалить сегменты, застрявшие в рабочем потоке.
		м_Преобразователь.Остановить();
		// Очистить очередь и отменить загрузку сегментов.
		// BUG Нельзя удалять элементы с новым состоянием.
		// report://07834447118157_14612437397
		г_моОчередь.Очистить();
		м_Статистика.ОчиститьИсторию();
		м_Список.ИзменитьВариантТрансляции();
	}

	function ПереключитьОкноСтатистики()
	{
		if (м_Статистика.ОкноПоказано())
		{
			м_Статистика.ЗакрытьОкно();
		}
		else
		{
			м_Статистика.ОткрытьОкно();
		}
	}
	
	function ПереключитьПроверкуЦвета(оСобытие)
	{
		if (document.body.classList.toggle('проверкацвета'))
		{
			document.body.classList.toggle('проверкацветафон', !оСобытие.shiftKey);
			м_Новости.ОткрытьСправку();
		}
		else
		{
			document.body.classList.remove('проверкацветафон');
		}
	}

	const ОбработатьИзменениеГромкости = ДобавитьОбработчикИсключений(оСобытие =>
	{
		СохранитьИПрименитьНастройкиЗвука(false, Number.parseFloat(оСобытие.target.value));
	});

	function СохранитьИПрименитьНастройкиЗвука(лПриглушить, чГромкость)
	{
		м_Настройки.Изменить('лПриглушить', лПриглушить);
		if (чГромкость !== undefined)
		{
			м_Настройки.Изменить('чГромкость2', Math.round(чГромкость));
		}
		м_Проигрыватель.ПрименитьНастройкиЗвука();
		ОбновитьНастройкиЗвука();
		ОтключитьАвтоскрытие();
	}

	function ОбновитьНастройкиЗвука()
	{
		document.getElementById('громкость').value = м_Настройки.Получить('чГромкость2');
		ИзменитьКнопку('переключитьприглушить', м_Настройки.Получить('лПриглушить'));
	}

	function ИзменитьПодпискуЗрителяНаКанал(чПодписка)
	{
		// pointer-events: none позволяет нажимать кнопки клавой.
		if (!document.getElementById('зритель-подписка').classList.contains('обновляется'))
		{
			м_Twitch.ИзменитьПодпискуЗрителяНаКанал(чПодписка);
		}
	}

	const ОбработатьДвойнойЩелчок = ДобавитьОбработчикИсключений(оСобытие =>
	{
		if (оСобытие.button === ЛЕВАЯ_КНОПКА)
		{
			оСобытие.preventDefault();
			ПереключитьПолноэкранныйРежим();
		}
	});

	const ОбработатьЛевыйЩелчок = ДобавитьОбработчикИсключений(оСобытие =>
	{
		const узЩелчок = оСобытие.target;
		// Firefox 58 посылает click для document после перетаскивания элемента за пределы окна.
		if (оСобытие.button !== ЛЕВАЯ_КНОПКА || узЩелчок.nodeType !== Node.ELEMENT_NODE || !узЩелчок.parentElement)
		{
			return;
		}

		const лВПроигрывателе = document.getElementById('проигрыватель').contains(узЩелчок);
		// Отключить автоскрытие касанием сенсорного экрана или щелчком мыши.
		if (лВПроигрывателе && ОтключитьАвтоскрытие())
		{
			return;
		}

		let узПозывной = узЩелчок;
		let сПозывной = узПозывной.id || узПозывной.name;
		if (!сПозывной)
		{
			узПозывной = узЩелчок.parentNode;
			сПозывной = узПозывной.id || узПозывной.name;
		}

		оСобытие.узПозывной = узПозывной;
		оСобытие.сПозывной = сПозывной;
		оСобытие.лВПроигрывателе = лВПроигрывателе;
		м_События.ОбработатьСобытие('управление-щелчок', оСобытие);

		switch (сПозывной)
		{
		case 'переключитьтрансляцию':
			ПереключитьПросмотрТрансляции();
			break;

		case 'глаз':
		case 'переключитьпаузу':
			if (_чСостояние === СОСТОЯНИЕ_ПОВТОР)
			{
				м_Проигрыватель.ПереключитьПаузу();
			}
			break;

		case 'переключитьприглушить':
			СохранитьИПрименитьНастройкиЗвука(!м_Настройки.Получить('лПриглушить'));
			break;

		case 'переключитьчат':
			м_Чат.ПереключитьСостояниеПанели();
			break;

		case 'создатьклип':
			м_Twitch.СоздатьКлип();
			break;

		case 'переключитьполноэкранный':
			ПереключитьПолноэкранныйРежим();
			break;

		case 'одновременныхзагрузок':
			Проверить(узЩелчок.checked);
			м_Настройки.Изменить('кОдновременныхЗагрузок', Number.parseInt(узЩелчок.value, 10));
			м_Статистика.ОчиститьИсторию();
			break;

		case 'заначка':
			Проверить(узЩелчок.checked);
			м_Настройки.Изменить('кЗаначка', Number.parseInt(узЩелчок.value, 10));
			м_Статистика.ОчиститьИсторию();
			break;

		case 'менятьгромкостьколесом':
			м_Настройки.Изменить('лМенятьГромкостьКолесом', узЩелчок.checked);
			ЗапуститьИзменениеГромкостиКолесом();
			break;

		case 'анимацияинтерфейса':
			м_Настройки.Изменить('лАнимацияИнтерфейса', узЩелчок.checked);
			ИзменитьАнимациюИнтерфейса();
			break;


		case 'автоположениечата':
			м_Настройки.Изменить('лАвтоПоложениеЧата', узЩелчок.checked);
			ОбновитьОкноНастроек();
			м_Чат.ОбновитьПоложениеПанели();
			break;

		case 'горизонтальноеположениечата':
			Проверить(узЩелчок.checked);
			м_Настройки.Изменить('чГоризонтальноеПоложениеЧата', Number.parseInt(узЩелчок.value, 10));
			м_Чат.ОбновитьПоложениеПанели();
			break;

		case 'вертикальноеположениечата':
			Проверить(узЩелчок.checked);
			м_Настройки.Изменить('чВертикальноеПоложениеЧата', Number.parseInt(узЩелчок.value, 10));
			м_Чат.ОбновитьПоложениеПанели();
			break;

		case 'положениечата':
			Проверить(узЩелчок.checked);
			м_Настройки.Изменить('чПоложениеПанелиЧата', Number.parseInt(узЩелчок.value, 10));
			м_Чат.ОбновитьПоложениеПанели();
			break;

		case 'состояниезакрытогочата':
			Проверить(узЩелчок.checked);
			м_Чат.ЗадатьСостояниеЗакрытойПанели(Number.parseInt(узЩелчок.value, 10));
			break;

		case 'переключитьстатистику':
		case 'позиция-текст':
			ПереключитьОкноСтатистики();
			break;

		case 'открытьсправку':
		case 'открытьсправку2':
			м_Новости.ОткрытьСправку();
			break;

		case 'отправитьотзыв':
			м_Отладка.ЗавершитьРаботуИОтправитьОтзыв();
			break;

		case 'поддержать':
			window.open('https://coolcmd.tk/tw5/donate.html');
			break;

		case 'экспортнастроек':
			м_Настройки.Экспорт();
			break;

		case 'импортнастроек':
			const уз = document.getElementById('выборфайладляимпортанастроек');
			уз.value = ''; // onchange
			уз.click();
			break;

		case 'сброситьнастройки':
			м_Настройки.Сбросить();
			break;

		case 'проверкацвета':
			ПереключитьПроверкуЦвета(оСобытие);
			break;

		case 'типтрансляции':
			Проверить(узЩелчок.nodeName === 'BUTTON');
			if (!узЩелчок.disabled)
			{
				window.location.assign(узЩелчок.getAttribute('data-адрес'));
			}
			break;

		case 'зритель-подписаться':
			ИзменитьПодпискуЗрителяНаКанал(ПОДПИСКА_УВЕДОМЛЯТЬ);
			break;

		case 'зритель-отписаться':
			ИзменитьПодпискуЗрителяНаКанал(ПОДПИСКА_НЕОФОРМЛЕНА);
			break;

		case 'зритель-уведомлять':
			ИзменитьПодпискуЗрителяНаКанал(узЩелчок.checked ? ПОДПИСКА_УВЕДОМЛЯТЬ : ПОДПИСКА_НЕУВЕДОМЛЯТЬ);
			break;

		case 'открытьбоковуюпанель':
			м_Чат.ОткрытьБоковуюПанель();
			break;

		case 'закрытьстатистику':
			м_Статистика.ЗакрытьОкно();
			break;
		}
	});

	const ОбработатьНажатиеИОтпусканиеКлавы = ДобавитьОбработчикИсключений(оСобытие =>
	// Firefox 47: <button> нажимается по отпусканию SPACE.
	// TODO Проверять <input type=text>.
	{
		const SHIFT_KEY = 1 << 16;
		const CTRL_KEY  = 1 << 17;
		const ALT_KEY   = 1 << 18;
		const META_KEY  = 1 << 19;

		if (г_лРаботаЗавершена)
		{
			return;
		}
		const лНажатие = оСобытие.type === 'keydown';
		const лНажатие1 = лНажатие && !оСобытие.repeat;
		switch (оСобытие.keyCode + оСобытие.shiftKey * SHIFT_KEY + оСобытие.ctrlKey * CTRL_KEY + оСобытие.altKey * ALT_KEY + оСобытие.metaKey * META_KEY)
		{
		case 13: // ENTER
			if (лНажатие1)
			{
				ПереключитьПолноэкранныйРежим();
			}
			break;

		case 86: // V
			if (лНажатие1)
			{
				м_Окна.ПереключитьОкно('настройки');
			}
			break;

		case 73: // I
			if (лНажатие1)
			{
				м_Окна.ПереключитьОкно('канал');
			}
			break;

		case 83: // S
			if (лНажатие1)
			{
				ПереключитьОкноСтатистики();
			}
			break;

		case 112: // F1
			if (лНажатие1)
			{
				м_Новости.ОткрытьСправку();
			}
			break;

		case 67: // C
		case 45: // INSERT
			if (лНажатие1)
			{
				м_Чат.ПереключитьСостояниеПанели();
			}
			break;

		case 67 + SHIFT_KEY: // SHIFT + C
			if (лНажатие1)
			{
				м_Чат.ОткрытьБоковуюПанель();
			}
			break;

		case 85: // U
			if (лНажатие1)
			{
				м_Чат.ПереключитьПоложениеПанели();
				ОбновитьОкноНастроек();
			}
			break;

		case 32: // SPACE
			if (лНажатие1)
			{
				ПереключитьПросмотрТрансляции();
				ОтключитьАвтоскрытие();
			}
			break;

		case 48: // 0
		case 49: // 1
		case 50: // 2
		case 51: // 3
		case 52: // 4
		case 53: // 5
		case 54: // 6
		case 55: // 7
		case 56: // 8
		case 57: // 9
			if (лНажатие1 && _чСостояние === СОСТОЯНИЕ_ПОВТОР)
			{
				ЗадатьСкоростьВоспроизведения((оСобытие.keyCode === 48 ? 58 : оСобытие.keyCode) - 53);
				ОтключитьАвтоскрытие();
			}
			break;

		// EDGE 15: PLUS и NUMPAD PLUS увеличивают скорость воспроизведения.
		case 187: // PLUS
		case 107: // NUMPAD PLUS
			if (лНажатие1 && _чСостояние === СОСТОЯНИЕ_ПОВТОР)
			{
				ЗадатьСкоростьВоспроизведения(Infinity);
				ОтключитьАвтоскрытие();
			}
			break;

		// EDGE 15: MINUS и NUMPAD MINUS уменьшают скорость воспроизведения.
		case 189: // MINUS
		case 109: // NUMPAD MINUS
			if (лНажатие1 && _чСостояние === СОСТОЯНИЕ_ПОВТОР)
			{
				ЗадатьСкоростьВоспроизведения(-Infinity);
				ОтключитьАвтоскрытие();
			}
			break;

		case 90: // Z
		case 12: // NUMPAD 5
			if (лНажатие1 && _чСостояние === СОСТОЯНИЕ_ПОВТОР)
			{
				м_Проигрыватель.ПереключитьПаузу();
				ОтключитьАвтоскрытие();
			}
			break;

		case 37: // LEFT
			if (лНажатие && _чСостояние === СОСТОЯНИЕ_ПОВТОР)
			{
				м_Журнал.Окак(`[Управление] Перематываю на -${ПЕРЕМАТЫВАТЬ_СТРЕЛКАМИ_НА}с`);
				м_Проигрыватель.ПеремотатьПовторНа(false, -ПЕРЕМАТЫВАТЬ_СТРЕЛКАМИ_НА);
				ОтключитьАвтоскрытие();
			}
			break;

		case 39: // RIGHT
			if (лНажатие && _чСостояние === СОСТОЯНИЕ_ПОВТОР)
			{
				м_Журнал.Окак(`[Управление] Перематываю на +${ПЕРЕМАТЫВАТЬ_СТРЕЛКАМИ_НА}с`);
				м_Проигрыватель.ПеремотатьПовторНа(false, ПЕРЕМАТЫВАТЬ_СТРЕЛКАМИ_НА);
				ОтключитьАвтоскрытие();
			}
			break;

		case 37 + SHIFT_KEY: // SHIFT + LEFT
			if (лНажатие && _чСостояние === СОСТОЯНИЕ_ПОВТОР)
			{
				м_Журнал.Окак(`[Управление] Перематываю на -${ПЕРЕМАТЫВАТЬ_ПО_КАДРАМ_НА} кадров`);
				м_Проигрыватель.ПеремотатьПовторНа(true, -ПЕРЕМАТЫВАТЬ_ПО_КАДРАМ_НА);
				ОтключитьАвтоскрытие();
			}
			break;

		case 39 + SHIFT_KEY: // SHIFT + RIGHT
			if (лНажатие && _чСостояние === СОСТОЯНИЕ_ПОВТОР)
			{
				м_Журнал.Окак(`[Управление] Перематываю на +1 кадр`);
				м_Проигрыватель.ПеремотатьПовторНа(true, 1);
				ОтключитьАвтоскрытие();
			}
			break;

		case 38: // UP
			if (лНажатие)
			{
				СохранитьИПрименитьНастройкиЗвука(false, Math.min(м_Настройки.Получить('чГромкость2') + ШАГ_ПОВЫШЕНИЯ_ГРОМКОСТИ_КЛАВОЙ, МАКСИМАЛЬНАЯ_ГРОМКОСТЬ));
			}
			break;

		case 40: // DOWN
			if (лНажатие)
			{
				СохранитьИПрименитьНастройкиЗвука(false, Math.max(м_Настройки.Получить('чГромкость2') - ШАГ_ПОНИЖЕНИЯ_ГРОМКОСТИ_КЛАВОЙ, МИНИМАЛЬНАЯ_ГРОМКОСТЬ));
			}
			break;

		case 33: // PAGE UP
			if (лНажатие1)
			{
				СохранитьИПрименитьНастройкиЗвука(false);
			}
			break;

		case 34: // PAGE DOWN
			if (лНажатие1)
			{
				СохранитьИПрименитьНастройкиЗвука(true);
			}
			break;

		case 77: // M
			if (лНажатие1)
			{
				СохранитьИПрименитьНастройкиЗвука(!м_Настройки.Получить('лПриглушить'));
			}
			break;

		case 88 + ALT_KEY: // ALT + X
			if (лНажатие1)
			{
				м_Twitch.СоздатьКлип();
			}
			break;


		default: return;
		}

		оСобытие.stopPropagation();
		оСобытие.preventDefault();
	});

	function ОбработатьИзменениеПредустановкиБуферизации()
	{
		ОбновитьОкноНастроек();
		м_Статистика.ОчиститьИсторию();
	}

	function ОбновитьОкноНастроек()
	{
		document.querySelector(`input[name="одновременныхзагрузок"][value="${м_Настройки.Получить('кОдновременныхЗагрузок')}"]`).checked = true;
		document.querySelector(`input[name="заначка"][value="${м_Настройки.Получить('кЗаначка')}"]`).checked = true;
		document.querySelector(`input[name="состояниезакрытогочата"][value="${м_Настройки.Получить('чСостояниеЗакрытогоЧата')}"]`).checked = true;
		document.getElementById('адресчата').selectedIndex = м_Настройки.Получить('лПолноценныйЧат') ? 0 : м_Настройки.Получить('лЗатемнитьЧат') ? 2 : 1;
		document.getElementById('менятьгромкостьколесом').checked = м_Настройки.Получить('лМенятьГромкостьКолесом');
		document.getElementById('анимацияинтерфейса').checked = м_Настройки.Получить('лАнимацияИнтерфейса');

		const лАвтоПоложение = м_Настройки.Получить('лАвтоПоложениеЧата');
		document.getElementById('автоположениечата').checked = лАвтоПоложение;
		const сузСтороны = document.querySelectorAll('.положениечата input');
		if (лАвтоПоложение)
		{
			const чГоризонтальноеПоложение = м_Настройки.Получить('чГоризонтальноеПоложениеЧата');
			const чВертикальноеПоложение = м_Настройки.Получить('чВертикальноеПоложениеЧата');
			let узГоризонтальноеПоложение, узВертикальноеПоложение;
			for (let узСторона of сузСтороны)
			{
				const чСторона = Number.parseInt(узСторона.value, 10);
				if (чГоризонтальноеПоложение === чСторона)
				{
					узГоризонтальноеПоложение = узСторона;
				}
				if (чВертикальноеПоложение === чСторона)
				{
					узВертикальноеПоложение = узСторона;
				}
				узСторона.name = чСторона === ПРАВАЯ_СТОРОНА || чСторона === ЛЕВАЯ_СТОРОНА ? 'горизонтальноеположениечата' : 'вертикальноеположениечата';
			}
			узГоризонтальноеПоложение.checked = узВертикальноеПоложение.checked = true;
		}
		else
		{
			const чПоложение = м_Настройки.Получить('чПоложениеПанелиЧата');
			let узПоложение;
			for (let узСторона of сузСтороны)
			{
				if (чПоложение === Number.parseInt(узСторона.value, 10))
				{
					узПоложение = узСторона;
				}
				узСторона.name = 'положениечата';
			}
			узПоложение.checked = true;
		}

		if (_оНачалоВоспроизведения)
		{
			_оНачалоВоспроизведения.Обновить();
			_оРазмерБуфера.Обновить();
			_оРастягиваниеБуфера.Обновить();
			_оИнтервалОбновленияСписков.Обновить();
			_оДлительностьПовтора.Обновить();
			_оРазмерИнтерфейса.Обновить();
			_оИнтервалАвтоскрытия.Обновить();
		}
		else
		{
			_оНачалоВоспроизведения     = new ВводЧисла('чНачалоВоспроизведения', 0.5, 1, 'началовоспроизведения');
			_оРазмерБуфера              = new ВводЧисла('чРазмерБуфера',          0.5, 1, 'размербуфера');
			_оРастягиваниеБуфера        = new ВводЧисла('чРастягиваниеБуфера',    0.5, 1, 'растягиваниебуфера');
			_оИнтервалОбновленияСписков = new ВводЧисла('чИнтервалОпроса',         10, 0, 'интервалопроса');
			_оДлительностьПовтора       = new ВводЧисла('чДлительностьПовтора2',   30, 0, 'длительностьповтора');
			_оНачалоВоспроизведения.ПослеИзменения = _оРазмерБуфера.ПослеИзменения = _оРастягиваниеБуфера.ПослеИзменения = _оИнтервалОбновленияСписков.ПослеИзменения = м_Статистика.ОчиститьИсторию;

			_оРазмерИнтерфейса = new ВводЧисла('чРазмерИнтерфейса', 1, 0, 'размеринтерфейса');
			_оРазмерИнтерфейса.ПослеИзменения = ИзменитьРазмерИнтерфейса;

			_оИнтервалАвтоскрытия = new ВводЧисла('чИнтервалАвтоскрытия', 0.5, 1, 'интервалавтоскрытия');
		}
	}

	function ОбработатьПаузу(сСобытие, лПауза)
	{
		ИзменитьКнопку('переключитьпаузу', лПауза);
	}

	function ПолучитьСкоростьВоспроизведения()
	{
		var узСкорость = document.getElementById('скорость');
		м_Журнал.Окак(`[Управление] Выбрана скорость ${узСкорость.value}`);
		var чСкорость = Number.parseFloat(узСкорость.value);
		// Firefox 47, Chrome 52: Отрицательный playbackRate не поддерживается.
		// Firefox 47: Минимальная скорость 0.25.
		// Chrome 52:  Минимальная скорость 0.06.
		// Chrome 59:  NVIDIA GTX770 не вытягивает скорость 4x.
		Проверить(Number.isFinite(чСкорость) && чСкорость >= 0);
		return чСкорость;
	}

	function ЗадатьСкоростьВоспроизведения(чСкорость)
	// -Infinity - замедлить на 1 шаг
	// +Infinity - ускорить  на 1 шаг
	// < 0       - пониженная скорость
	// = 0       - нормальная скорость
	// > 0       - повышенная скорость
	{
		Проверить(ЭтоЧисло(чСкорость));
		var узСкорость = document.getElementById('скорость');
		Проверить(узСкорость.selectedIndex >= 0);
		if (чСкорость === -Infinity || чСкорость === Infinity)
		{
			var чИндекс = узСкорость.selectedIndex - Math.sign(чСкорость);
		}
		else
		{
			var чИндекс = узСкорость.querySelector('option[value="1.00"]').index - чСкорость;
		}
		if (чИндекс >= 0 && чИндекс < узСкорость.length && чИндекс !== узСкорость.selectedIndex)
		{
			узСкорость.selectedIndex = чИндекс;
			м_Проигрыватель.ЗадатьСкоростьПовтора(ПолучитьСкоростьВоспроизведения());
		}
	}

	const ОбработатьИзменениеСкоростиВоспроизведения = ДобавитьОбработчикИсключений(оСобытие =>
	{
		if (_чСостояние === СОСТОЯНИЕ_ПОВТОР)
		{
			м_Проигрыватель.ЗадатьСкоростьПовтора(ПолучитьСкоростьВоспроизведения());
		}
	});

	const ОбработатьИзменениеВариантаТрансляции = ДобавитьОбработчикИсключений(оСобытие =>
	{
		м_Журнал.Окак(`[Управление] Выбран вариант ${оСобытие.target.value}`);
		Проверить(оСобытие.target.value);
		м_Настройки.Изменить('сНазваниеВарианта', оСобытие.target.value);
		ИзменитьВариантТрансляции();
	});

	const ОбработатьИзменениеАдресаЧата = ДобавитьОбработчикИсключений(оСобытие =>
	{
		м_Журнал.Окак(`[Управление] Выбран адрес чата ${оСобытие.target.selectedIndex}`);
		switch (оСобытие.target.selectedIndex)
		{
		case 0:
			м_Настройки.Изменить('лПолноценныйЧат', true);
			break;

		case 1:
			м_Настройки.Изменить('лПолноценныйЧат', false);
			м_Настройки.Изменить('лЗатемнитьЧат', false);
			break;

		case 2:
			м_Настройки.Изменить('лПолноценныйЧат', false);
			м_Настройки.Изменить('лЗатемнитьЧат', true);
			break;

		default:
			Проверить(false);
		}
		м_Чат.ОбновитьАдрес();
	});

	const ОбработатьВыборФайлаДляИмпортаНастроек = ДобавитьОбработчикИсключений(оСобытие =>
	{
		if (оСобытие.target.files.length === 1)
		{
			м_Настройки.Импорт(оСобытие.target.files[0]);
		}
	});

	ОбновитьСписокВариантовТрансляции.ПЕРЕВОД_ВАРИАНТОВ =
	{
		'Source': 'J0115',
		'High':   'J0116',
		'Medium': 'J0117',
		'Low':    'J0118',
		'Mobile': 'J0119'
	};

	function ОбновитьСписокВариантовТрансляции(сСобытие, мДанные)
	{
		const моСписокВариантов = мДанные[0], чВыбранныйВариант = мДанные[1];
		const узСписок = document.getElementById('варианттрансляции');
		узСписок.length = 0;
		if (моСписокВариантов)
		{
			for (var ы = 0; ы < моСписокВариантов.length; ++ы)
			{
				var сПереведенноеНазвание = ОбновитьСписокВариантовТрансляции.ПЕРЕВОД_ВАРИАНТОВ[моСписокВариантов[ы].сНазвание];
				сПереведенноеНазвание = сПереведенноеНазвание ? Текст(сПереведенноеНазвание) : моСписокВариантов[ы].сНазвание;
				узСписок.add(new Option(сПереведенноеНазвание, моСписокВариантов[ы].сИдентификатор, ы === чВыбранныйВариант, ы === чВыбранныйВариант));
			}
		}
		узСписок.disabled = узСписок.length < 2;
	}

	function ПоказатьПропускВидео()
	{
		if (_чТаймерПропуска === 0)
		{
			document.getElementById('пропуск').style.display = 'block';
			_чТаймерПропуска = setTimeout(СкрытьПропускВидео, ПОКАЗЫВАТЬ_ПРОПУСК_ВИДЕО);
		}
	}

	const СкрытьПропускВидео = ДобавитьОбработчикИсключений(() =>
	{
		document.getElementById('пропуск').style.display = '';
		_чТаймерПропуска = 0;
	});

	function Запустить()
	{
		Проверить(_чСостояние === undefined);

		document.getElementById('названиетрансляции').lastElementChild.setAttribute('href', м_Twitch.ПолучитьАдресУбогогоПроигрывателя());

		let уз = document.getElementById('громкость');
		уз.setAttribute('min', МИНИМАЛЬНАЯ_ГРОМКОСТЬ);
		уз.setAttribute('max', МАКСИМАЛЬНАЯ_ГРОМКОСТЬ);
		уз.setAttribute('step', ШАГ_ИЗМЕНЕНИЯ_ГРОМКОСТИ_МЫШЬЮ);
		уз.addEventListener('input', ОбработатьИзменениеГромкости);

		for (уз = document.getElementById('скорость').firstElementChild; уз; уз = уз.nextElementSibling)
		{
			уз.text = уз.value === '1.00' ? '1x' : м_i18n.ФорматироватьЧисло(уз.value, 2);
		}

		ЗапуститьАвтоскрытие();
		ОтключитьАвтоскрытие();
		ЗапуститьПолноэкранныйРежим();
		ОбновитьНастройкиЗвука();
		ОбновитьОкноНастроек();
		м_Новости.Запустить();
		м_Чат.Восстановить();

		м_События.ДобавитьОбработчик('список-выбранварианттрансляции', ОбновитьСписокВариантовТрансляции);
		м_События.ДобавитьОбработчик('проигрыватель-переполненбуфер', ПоказатьПропускВидео);
		м_События.ДобавитьОбработчик('проигрыватель-пауза', ОбработатьПаузу);
		м_События.ДобавитьОбработчик('настройки-измениласьпредустановка-буферизация', ОбработатьИзменениеПредустановкиБуферизации);
		м_События.ДобавитьОбработчик('twitch-полученыметаданныеканала', ПоказатьМетаданныеКанала);
		м_События.ДобавитьОбработчик('twitch-полученыметаданныезрителя', ПоказатьМетаданныеЗрителя);
		м_События.ДобавитьОбработчик('twitch-полученыметаданныетрансляции', ПоказатьМетаданныеТрансляции);

		document.addEventListener('click', ОбработатьЛевыйЩелчок);
		document.addEventListener('keydown', ОбработатьНажатиеИОтпусканиеКлавы);
		document.addEventListener('keyup', ОбработатьНажатиеИОтпусканиеКлавы);
		document.getElementById('глаз').addEventListener('dblclick', ОбработатьДвойнойЩелчок);
		document.getElementById('скорость').addEventListener('change', ОбработатьИзменениеСкоростиВоспроизведения);
		document.getElementById('варианттрансляции').addEventListener('change', ОбработатьИзменениеВариантаТрансляции);
		document.getElementById('адресчата').addEventListener('change', ОбработатьИзменениеАдресаЧата);
		document.getElementById('выборфайладляимпортанастроек').addEventListener('change', ОбработатьВыборФайлаДляИмпортаНастроек);
		ЗапуститьИзменениеГромкостиКолесом();

		ИзменитьСостояние(СОСТОЯНИЕ_ЗАПУСК);
		ИзменитьРазмерИнтерфейса();
		ИзменитьАнимациюИнтерфейса();
		// Показать проигрыватель.
		м_Оформление.Запустить();
	}

	function ИзменитьСостояние(чНовоеСостояние)
	{
		Проверить(Number.isInteger(чНовоеСостояние));
		if (чНовоеСостояние === _чСостояние)
		{
			return;
		}

		м_Журнал.Вот(`[Управление] Состояние трансляции изменилось с ${_чСостояние} на ${чНовоеСостояние}`);
		document.body.setAttribute('data-состояние', чНовоеСостояние);
		ИзменитьКнопку('переключитьтрансляцию', чНовоеСостояние === СОСТОЯНИЕ_ОСТАНОВКА || чНовоеСостояние === СОСТОЯНИЕ_ПОВТОР);
		document.getElementById('создатьклип').disabled = чНовоеСостояние === СОСТОЯНИЕ_ЗАПУСК || чНовоеСостояние === СОСТОЯНИЕ_НАЧАЛО_ТРАНСЛЯЦИИ || чНовоеСостояние === СОСТОЯНИЕ_ЗАВЕРШЕНИЕ_ТРАНСЛЯЦИИ;

		switch (чНовоеСостояние)
		{
		case СОСТОЯНИЕ_ЗАПУСК:
			м_Статистика.ОчиститьИсторию();
			ПоказатьМетаданныеТрансляции('',
			{
				лЗапись:                 null,
				сАдресЗаписи:            null,
				сНазваниеТрансляции:     НАЗВАНИЕ_ТРАНСЛЯЦИИ_НЕИЗВЕСТНО,
				сНазваниеИгры:           null,
				сАдресИгры:              null,
				кЗрителей:               null,
				чДлительностьТрансляции: null
			});
			break;

		case СОСТОЯНИЕ_НАЧАЛО_ТРАНСЛЯЦИИ:
			ПоказатьМетаданныеТрансляции('',
			{
				лЗапись:                 null,
				сАдресЗаписи:            null,
				сНазваниеТрансляции:     НАЗВАНИЕ_ТРАНСЛЯЦИИ_НЕИЗВЕСТНО,
				сНазваниеИгры:           null,
				сАдресИгры:              null,
				кЗрителей:               null,
				чДлительностьТрансляции: null
			});
			м_Twitch.НачатьСборМетаданныхТрансляции();
			break;

		case СОСТОЯНИЕ_ЗАВЕРШЕНИЕ_ТРАНСЛЯЦИИ:
			м_Twitch.ЗавершитьСборМетаданныхТрансляции(true);
			ПоказатьМетаданныеТрансляции('',
			{
				лЗапись:                 null,
				сАдресЗаписи:            null,
				сНазваниеТрансляции:     Текст('J0100'),
				сАдресИгры:              null,
				кЗрителей:               null,
				чДлительностьТрансляции: null
			});
			м_Помойка.Сжечь();
			break;

		case СОСТОЯНИЕ_ЗАГРУЗКА:
		case СОСТОЯНИЕ_НАЧАЛО_ВОСПРОИЗВЕДЕНИЯ:
		case СОСТОЯНИЕ_ВОСПРОИЗВЕДЕНИЕ:
			break;

		case СОСТОЯНИЕ_ОСТАНОВКА:
		case СОСТОЯНИЕ_ПОВТОР:
			м_Twitch.ЗавершитьСборМетаданныхТрансляции(false);
			ПоказатьМетаданныеТрансляции('',
			{
				кЗрителей: null
			});
			м_Помойка.Сжечь();
			break;
				
		default:
			Проверить(false);
		}

		_чСостояние = чНовоеСостояние;
	}

	function ПолучитьСостояние()
	{
		Проверить(_чСостояние !== undefined);
		return _чСостояние;
	}

	function ПоказатьМетаданныеКанала(сСобытие, оМетаданные)
	{
		if (оМетаданные.сИмя !== undefined)
		{
			ИзменитьЗаголовокДокумента(`${оМетаданные.сИмя} - Alternate Player for Twitch.tv`);
			document.getElementById('канал-имя').textContent = оМетаданные.сИмя;
		}

		if (оМетаданные.сАватар !== undefined)
		{
			Проверить(оМетаданные.сАватар);
			document.getElementById('канал-аватар').src = оМетаданные.сАватар;
		}

		if (оМетаданные.сОписание !== undefined)
		{
			document.getElementById('канал-описание').textContent = оМетаданные.сОписание || '';
		}

		if (оМетаданные.сКодЯзыка !== undefined)
		{
			const уз = document.getElementById('канал-язык');
			if (оМетаданные.сКодЯзыка)
			{
				const сЯзык = ЯЗЫКИ[оМетаданные.сКодЯзыка.toLowerCase()];
				Проверить(сЯзык);
				уз.textContent = сЯзык;
				ПоказатьЭлемент(уз.parentNode, true);
			}
			else
			{
				ПоказатьЭлемент(уз.parentNode, false);
			}
		}

		if (оМетаданные.кПодписчиков !== undefined)
		{
			document.getElementById('канал-подписчиков').textContent = м_i18n.ФорматироватьЧисло(оМетаданные.кПодписчиков);
		}

		if (оМетаданные.кПросмотров !== undefined)
		{
			document.getElementById('канал-просмотров').textContent = м_i18n.ФорматироватьЧисло(оМетаданные.кПросмотров);
		}

		if (оМетаданные.дКаналСоздан !== undefined)
		{
			document.getElementById('канал-создан').textContent = оМетаданные.дКаналСоздан.toLocaleDateString();
		}

		ПоказатьМассивСсылок(оМетаданные.моСообщества, 'канал-сообщества');
		ПоказатьМассивСсылок(оМетаданные.моКоманды, 'канал-команды');
	}

	function ПоказатьМассивСсылок(моСсылки, сИдУзла)
	{
		if (моСсылки !== undefined)
		{
			const уз = document.getElementById(сИдУзла);
			if (моСсылки.length === 0)
			{
				ПоказатьЭлемент(уз.parentNode, false);
			}
			else
			{
				const оФрагмент = document.createDocumentFragment();
				for (var ы = 0, оСсылка; оСсылка = моСсылки[ы]; ++ы)
				{
					if (ы !== 0)
					{
						оФрагмент.appendChild(document.createTextNode(',\u2002'));
					}
					Проверить(оСсылка.сАдрес && оСсылка.сИмя);
					const узСсылка = document.createElement('a');
					узСсылка.setAttribute('href', оСсылка.сАдрес);
					узСсылка.setAttribute('rel', 'external noopener noreferrer');
					узСсылка.setAttribute('target', '_blank');
					if (оСсылка.сОписание)
					{
						узСсылка.setAttribute('class', 'канал-ссылка');
						узСсылка.setAttribute('title', оСсылка.сОписание);
					}
					узСсылка.appendChild(document.createTextNode(оСсылка.сИмя));
					оФрагмент.appendChild(узСсылка);
				}
				уз.textContent = '';
				уз.appendChild(оФрагмент);
				ПоказатьЭлемент(уз.parentNode, true);
			}
		}
	}

	function ПоказатьМетаданныеЗрителя(сСобытие, оМетаданные)
	{
		if (оМетаданные.сИмя !== undefined)
		{
			if (оМетаданные.сИмя !== '')
			{
				document.getElementById('зритель-имя').textContent = оМетаданные.сИмя;
			}
			else
			{
				м_i18n.InsertAdjacentHtmlMessage(document.getElementById('зритель-имя'), 'beforeend', 'F0590');
			}
		}

		if (оМетаданные.чПодписка !== undefined)
		{
			const уз = document.getElementById('зритель-подписка');
			if (оМетаданные.чПодписка === ПОДПИСКА_ОБНОВЛЯЕТСЯ)
			{
				уз.classList.add('обновляется');
			}
			else
			{
				уз.classList.remove('обновляется');
				уз.setAttribute('data-подписка', оМетаданные.чПодписка);
				document.getElementById('зритель-уведомлять').checked = оМетаданные.чПодписка === ПОДПИСКА_УВЕДОМЛЯТЬ;
			}
		}
		return true;
	}

	function ПоказатьМетаданныеТрансляции(сСобытие, оМетаданные)
	// undefined - не менять, null - скрыть.
	{
		if (оМетаданные.лЗапись !== undefined)
		{
			const уз = document.getElementById('типтрансляции');
			if (оМетаданные.лЗапись === null || (!оМетаданные.лЗапись && !оМетаданные.сАдресЗаписи))
			{
				уз.disabled = true;
				ПоказатьЭлемент(уз, false);
			}
			else
			{
				ИзменитьКнопку(уз, оМетаданные.лЗапись);
				if (оМетаданные.сАдресЗаписи)
				{
					уз.setAttribute('data-адрес', оМетаданные.сАдресЗаписи);
					уз.disabled = false;
				}
				else
				{
					уз.disabled = true;
				}
				ПоказатьЭлемент(уз, true);
			}
		}

		if (оМетаданные.сНазваниеТрансляции !== undefined)
		{
			const уз = document.getElementById('названиетрансляции');
			if (оМетаданные.сНазваниеТрансляции === null)
			{
				ПоказатьЭлемент(уз, false);
			}
			else
			{
				уз.lastElementChild.setAttribute('title', оМетаданные.сНазваниеТрансляции + Текст('J0101'));
				уз.lastElementChild.textContent = оМетаданные.сНазваниеТрансляции;
				ПоказатьЭлемент(уз, true);
			}
		}

		if (оМетаданные.сНазваниеИгры !== undefined)
		{
			const уз = document.getElementById('названиеигры');
			if (оМетаданные.сНазваниеИгры === null)
			{
				ПоказатьЭлемент(уз, false);
			}
			else
			{
				уз.lastElementChild.setAttribute('href', оМетаданные.сАдресИгры);
				уз.lastElementChild.setAttribute('title', оМетаданные.сНазваниеИгры + Текст('J0102'));
				уз.lastElementChild.textContent = оМетаданные.сНазваниеИгры;
				ПоказатьЭлемент(уз, true);
			}
		}

		if (оМетаданные.кЗрителей !== undefined)
		{
			const уз = document.getElementById('количествозрителей');
			if (оМетаданные.кЗрителей === null)
			{
				ПоказатьЭлемент(уз, false);
			}
			else
			{
				уз.lastElementChild.textContent = м_i18n.ФорматироватьЧисло(оМетаданные.кЗрителей, 0);
				ПоказатьЭлемент(уз, true);
			}
		}

		if (оМетаданные.чДлительностьТрансляции !== undefined)
		{
			document.getElementById('позиция-текст').textContent =
				оМетаданные.чДлительностьТрансляции === null ? ''
				: м_i18n.ПеревестиСекундыВСтроку(оМетаданные.чДлительностьТрансляции / 1000, false);
		}
	}

	return {
		Запустить,
		ИзменитьСостояние, ПолучитьСостояние,
		ПолучитьСкоростьВоспроизведения,
		ОтключитьПолноэкранныйРежим,
		ПереключитьПросмотрТрансляции
	};
})();


const м_Проигрыватель = (() =>
{
	// Нет необходимости нагибать процессор слишком часто.
	//
	// Firefox 48: Если CTS кадров перепутаны, то после удаления или добавления видео, ямы в buffered перестают быть
	// видны, поэтому в них можно "провалиться": воспроизвдение в этом месте остановится. Такое происходит редко. Чтобы
	// уменьшить вероятность провала, не стоит уменьшать ИНТЕРВАЛ_УДАЛЕНИЯ_ВИДЕО слишком сильно.
	const ИНТЕРВАЛ_УДАЛЕНИЯ_ВИДЕО = 10; // Секунды.


	// Chrome 59 + Windows + аппаратное декодирование: Остановка воспроизведения происходит в конце кадра за
	// 1..7 кадров до конца HTMLMediaElement.buffered. Возможно зависит от HTMLMediaElement.playbackRate.
	//
	// Chrome 59 + Windows + аппаратное декодирование: Если до конца HTMLMediaElement.buffered ≈ менее 0,2 с, то
	// добавление сегмента приводит к рывку видео и увеличению счетчика пропущенных кадров. Продолжительность рывка
	// намного меньше, чем в Firefox.
	const ИСЧЕРПАНИЕ_БУФЕРА = 1 / 25 * 7; // Секунды.

	const ПОВТОР_НЕДОСТУПЕН_ЕСЛИ_ПРОСМОТРЕНО_МЕНЬШЕ_ЧЕМ = 1.0; // Секунды > ИСЧЕРПАНИЕ_БУФЕРА.

	const ПРОВЕРИТЬ_ДОБАВЛЕНИЕ_СЕГМЕНТА            = -1;
	const ПРОВЕРИТЬ_НАЧАЛО_ВОСПРОИЗВЕДЕНИЯ         = -2;
	const ПРОВЕРИТЬ_ВОСПРОИЗВЕДЕНИЕ                = -3;
	const ПРОВЕРИТЬ_ОСТАНОВКА_ВОСПРОИЗВЕДЕНИЯ      = -4;

	const ВОСПРОИЗВЕДЕНИЕ_НЕВОЗМОЖНО               = 0;
	const ВОСПРОИЗВЕДЕНИЕ_ВОЗМОЖНО                 = 1;
	const ВОСПРОИЗВЕДЕНИЕ_ВОЗМОЖНО_ПОСЛЕ_ПЕРЕМОТКИ = 2;

	let _oMediaElement;
	let _oMediaSource;
	let _oMediaSourceBuffer = null;
	// 0: начальное значение.
	// 1: _oMediaSource открывался.
	// 2: воспроизведение начиналось.
	let _чВоспроизведениеНачиналось = 0;
	let _лАсинхроннаяОперация = false;
	let _сРазмерБуфера = 'чНачалоВоспроизведения';
	let _лЖдатьЗаполненияБуфера = true;
	let _чСмещениеНачалаТрансляции = 0;
	// HACK Chrome 53 + Windows + аппаратное декодирование: Если после остановки воспроизведения в буфере останется
	// не просмотрено менее ≈ 16 кадров, то после быстрого продолжения воспроизведения картинка перестанет обновляться
	// до следующей остановки. Перемотка исправляет эту ошибку.
	let _лНужнаПеремотка = false;


	const _оПрямаяТрансляция =
	{
		ОбработатьSourceOpen: function()
		{
			_чВоспроизведениеНачиналось = Math.max(_чВоспроизведениеНачиналось, 1);
			ДобавитьСледующийСегмент();
		},

		ОбработатьProgress: function()
		// Обработка этого события добавлена на всякий случай: после завершения appendBuffer(),
		// содержимое _oMediaSourceBuffer могло не успеть добраться до _oMediaElement.
		{
			if (!_лАсинхроннаяОперация)
			{
				НачатьВоспроизведение(ПроверитьПозициюВоспроизведения(ПРОВЕРИТЬ_ДОБАВЛЕНИЕ_СЕГМЕНТА));
			}
		},

		ОбработатьWaiting: function()
		// Воспроизведение могло остановиться перед ямой. Обработчик timeupdate не проверяет
		// наличие ям, потому что браузер небольшие ямы может перепрыгнуть без посторонней помощи.
		{
		},

		ОбработатьPlaying: function()
		{
			if (м_Управление.ПолучитьСостояние() === СОСТОЯНИЕ_НАЧАЛО_ВОСПРОИЗВЕДЕНИЯ && !_oMediaElement.paused)
			{
				м_Управление.ИзменитьСостояние(СОСТОЯНИЕ_ВОСПРОИЗВЕДЕНИЕ);
			}
		},

		ОбработатьSeeking: ЗАГЛУШКА,

		ОбработатьSeeked: НачатьВоспроизведение,

		ОбработатьEnded: function()
		{
			ПерезагрузитьПроигрыватель(СОСТОЯНИЕ_ЗАГРУЗКА);
		},

		ОбработатьTimeUpdate: function()
		{
			if (!_oMediaElement.seeking && !_oMediaElement.paused && !_oMediaElement.ended)
			{
				ПроверитьПозициюВоспроизведения(ПРОВЕРИТЬ_ВОСПРОИЗВЕДЕНИЕ);
			}
		}
	};

	const _оПовтор =
	{
		лПауза: true,

		ОбработатьSourceOpen: function()
		// Может прийти, если начать и сразу остановить просмотр трансляции.
		{
			_чВоспроизведениеНачиналось = Math.max(_чВоспроизведениеНачиналось, 1);
		},

		ОбработатьProgress: ЗАГЛУШКА,
		ОбработатьWaiting: ЗАГЛУШКА,
		ОбработатьPlaying: ЗАГЛУШКА,

		ОбработатьSeeking: function()
		// Если изменить _oMediaElement.currentTime до окончания перемотки, то событие timeupdate не придет.
		{
			м_Шкала.ЗадатьПросмотрено(_oMediaElement.currentTime);
		},

		ОбработатьSeeked: ЗАГЛУШКА,

		ОбработатьEnded: function()
		{
			if (!this.лПауза)
			{
				// Сначала приходит timeupdate и происходит перемотка на начало. Потом приходит ended и воспроизведение возобновляется.
				_oMediaElement.play();
			}
		},

		ОбработатьTimeUpdate: function()
		{
			// Нельзя определить режим работы по _oMediaElement.paused. _oMediaElement.paused = true после события ended.
			// Каким был _oMediaElement.paused до прихода ended узнать по состоянию _oMediaElement нельзя.
			if (!this.лПауза && !_oMediaElement.seeking)
			{
				this.ПроверитьПозициюВоспроизведения(ПРОВЕРИТЬ_ВОСПРОИЗВЕДЕНИЕ);
			}
			м_Шкала.ЗадатьПросмотрено(_oMediaElement.currentTime);
		},

		ПроверитьПозициюВоспроизведения: function(чВремя)
		{
			Проверить(Number.isFinite(чВремя));
			Проверить(чВремя === ПРОВЕРИТЬ_НАЧАЛО_ВОСПРОИЗВЕДЕНИЯ || чВремя === ПРОВЕРИТЬ_ВОСПРОИЗВЕДЕНИЕ || чВремя >= 0);
			
			const оБуфер = _oMediaElement.buffered;
			const чПоследняяОбласть = оБуфер.length - 1;
			// Chrome 47: currentTime может быть на 0.000001 секунды меньше присвоенной величины.
			// Если это не учесть, то получим бесконечную перемотку на начало области.
			const чТекущееВремя = _oMediaElement.currentTime + 0.0001;
			var чПеремотатьДо = чВремя >= 0 ? чВремя : чТекущееВремя;
			var сПричинаПеремотки = '';

			for (var лНачатьСначала = false;;)
			{
				var чНужноДляВоспроизведения = чВремя === ПРОВЕРИТЬ_ВОСПРОИЗВЕДЕНИЕ ? ИСЧЕРПАНИЕ_БУФЕРА : МИН_РАЗМЕР_БУФЕРА;
				for (var чОбласть = 0; чОбласть <= чПоследняяОбласть; ++чОбласть)
				{
					if (чПеремотатьДо < оБуфер.start(чОбласть))
					{
						чНужноДляВоспроизведения = МИН_РАЗМЕР_БУФЕРА;
						сПричинаПеремотки += 'Перепрыгиваю яму. ';
						чПеремотатьДо = оБуфер.start(чОбласть);
					}
					if (оБуфер.end(чОбласть) - чПеремотатьДо >= чНужноДляВоспроизведения)
					{
						break;
					}
				}

				if (this.лПауза || чПеремотатьДо < м_Шкала.ПолучитьКонец())
				{
					break;
				}
				if (лНачатьСначала)
				{
					ПоказатьСостояние('Ой', `Бесконечная перемотка Время=${чВремя}`);
					return;
				}
				чПеремотатьДо = м_Шкала.ПолучитьНачало();
				сПричинаПеремотки += 'Начинаю сначала. ';
				лНачатьСначала = true;
			}

			if (чПеремотатьДо !== чТекущееВремя)
			{
				ПоказатьСостояние('Окак', `${сПричинаПеремотки}Перематываю до ${чПеремотатьДо}`);
				_oMediaElement.currentTime = чПеремотатьДо;
			}
		}
	};

	// _оПрямаяТрансляция или _оПовтор.
	let _оПоведение = _оПрямаяТрансляция;

	function ПоказатьСостояние(сВажность, сЗапись)
	{
		const оБуфер = _oMediaSource.sourceBuffers.length !== 0 ? _oMediaSource.sourceBuffers[0] : null;
		const сОбластиБуфера = ПеревестиОбластиВСтроку(оБуфер ? оБуфер.buffered : null);
		const сОбласти = ПеревестиОбластиВСтроку(_oMediaElement.buffered)
		const лОбластиРавны = сОбластиБуфера === сОбласти;
		if (сВажность === 'Вот' && ((оБуфер && оБуфер.buffered.length > 1) || _oMediaElement.buffered.length > 1))
		{
			сВажность = 'Окак';
		}
		if (_oMediaElement.error || !лОбластиРавны)
		{
			сВажность = 'Ой';
		}
		м_Журнал[сВажность](
			`${сЗапись.charAt(0) === '[' ? '' : '[Проигрыватель] '}${сЗапись} •••`
			+ (_oMediaElement.error ? ` error=${_oMediaElement.error.code}` : '')
			+ (оБуфер && оБуфер.updating ? ' [U]' : '')
			+ (_oMediaElement.paused     ? ' [P]' : '')
			+ (_oMediaElement.seeking    ? ' [S]' : '')
			+ (_oMediaElement.ended      ? ' [E]' : '')
			+ (_oMediaSource.readyState === 'open' ? '' : ` MSE.readyState=${_oMediaSource.readyState}`)
			+ (_oMediaSource.sourceBuffers.length === 1 ? '' : ` MSE.buffers=${_oMediaSource.sourceBuffers.length}`)
			+ (_oMediaElement.networkState === HTMLMediaElement.NETWORK_LOADING ? '' : ` networkState=${_oMediaElement.networkState}`)
			+ ` readyState=${_oMediaElement.readyState}`
			+ ` currentTime=${_oMediaElement.currentTime}`
			+ (лОбластиРавны ? ` buffered=${сОбласти}` : ` MSE.buffered=${сОбластиБуфера} buffered=${сОбласти}`)
			+ (_oMediaElement.duration === Infinity ? '' : ` duration=${_oMediaElement.duration}`)
			+ ` seekable=${ПеревестиОбластиВСтроку(_oMediaElement.seekable)}`
			+ ` played=${ПеревестиОбластиВСтроку(_oMediaElement.played)}`
		);
	}

	function ПеревестиОбластиВСтроку(оОбласти)
	{
		var сРезультат = '';
		if (оОбласти && оОбласти.length !== 0)
		{
			var кОбластей = оОбласти.length;
			var чОбласть = Math.max(кОбластей - 20, 0);
			if (чОбласть !== 0)
			{
				сРезультат = `[${чОбласть}]`;
			}
			for (; чОбласть < кОбластей; ++чОбласть)
			{
				if (чОбласть !== 0)
				{
					сРезультат += `(${(оОбласти.start(чОбласть) - оОбласти.end(чОбласть - 1)).toFixed(3)})`;
				}
				сРезультат += `${оОбласти.start(чОбласть)}-${оОбласти.end(чОбласть)}`;
			}
		}
		return сРезультат;
	}

	function ПолучитьЗаполненностьБуфера(оБуфер /* = _oMediaElement.buffered */)
	// Возвращает
	// {
	//   чПросмотрено:   длительность   просмотренного видео >= 0 с
	//   чНеПросмотрено: длительность непросмотренного видео >= 0 с
	// }
	// Ямы не учитываются.
	{
		var чПросмотрено = 0;
		var чНеПросмотрено = 0;
		if (оБуфер === undefined)
		{
			оБуфер = _oMediaElement.buffered;
		}
		if (оБуфер.length !== 0)
		{
			var чНачало = оБуфер.start(0);
			var чКонец = оБуфер.end(оБуфер.length - 1);
			var чТекущееВремя = Ограничить(_oMediaElement.currentTime, чНачало, чКонец);
			чПросмотрено = чТекущееВремя - чНачало;
			чНеПросмотрено = чКонец - чТекущееВремя;
		}
		return {
			чПросмотрено,
			чНеПросмотрено
		};
	}

	function ПолучитьКоличествоПропущенныхКадров()
	{
		return typeof _oMediaElement.getVideoPlaybackQuality === 'function'
			? _oMediaElement.getVideoPlaybackQuality() :
			{
				totalVideoFrames:   _oMediaElement.webkitDecodedFrameCount,
				droppedVideoFrames: _oMediaElement.webkitDroppedFrameCount
			};
	}

	function ПолучитьПозициюВоспроизведенияТрансляции()
	// Возвращает 0 если воспроизведение не начиналось.
	{
		// Во время повтора сегменты ближе к началу шкалы уже недоступны на сервере Twitch, поэтому используем конец шкалы вместо currentTime.
		var чПозиция = м_Управление.ПолучитьСостояние() === СОСТОЯНИЕ_ПОВТОР ? м_Шкала.ПолучитьКонец() : _oMediaElement.currentTime;
		return чПозиция === 0 ? 0 : Math.max(чПозиция + _чСмещениеНачалаТрансляции, 0);
	}

	function РасчитатьСмещениеНачалаТрансляции(оСегмент)
	// Изменяет _чСмещениеНачалаТрансляции.
	// Вызывать после добавления сегмента в буфер проигрывателя.
	// НЕ_ПРЕОБРАЗОВЫВАТЬ: Сегменты должны добавляться только в конец буфера.
	// Если трансляция длится больше ≈ 0x1FFFFFFFF / 90000 секунд, то позиция кодирования
	// добавляется к смещению (которое становится положительным числом) и затем обнуляется.
	// Бывают и другие комбинации, например чПозицияКодирования = 10000 и чСмещениеНачалаТрансляции = 5000.
	{
		// В сегменте есть статистика?
		if (!ЭтоЧисло(оСегмент.пДанные.чПозицияКодирования))
		{
			return;
		}
		// ВД как правило лишь на несколько миллисекунд отличается от ВП, поэтому годится для расчета смещения.
		// Большой точности для смещения не требуется.
		var чСмещениеНачалаТрансляции = ЭтоЧисло(оСегмент.чTwitchПрошлоВремени) ? оСегмент.чTwitchПрошлоВремени - оСегмент.пДанные.чПозицияКодирования : 0;
		var лОй = чСмещениеНачалаТрансляции === 0 || Math.abs(чСмещениеНачалаТрансляции - _чСмещениеНачалаТрансляции) > 1;
		м_Журнал[лОй ? 'Ой' : 'Вот'](`[Проигрыватель] Смещение начала трансляции ${м_Журнал.F1(чСмещениеНачалаТрансляции)}с`);
		if (м_Статистика.ОкноПоказано())
		{
			м_Статистика.ОбновитьЗначение('статистика-смещениеначалатрансляции', чСмещениеНачалаТрансляции.toFixed(1), лОй);
		}
		_чСмещениеНачалаТрансляции = чСмещениеНачалаТрансляции;
	}

	function ПоказатьПродолжительностьТрансляции()
	{
		if (м_Статистика.ОкноПоказано())
		{
			var оБуфер = _oMediaSourceBuffer.buffered;
			if (оБуфер.length !== 0)
			{
				document.getElementById('статистика-продолжительностьтрансляции').textContent =
					м_i18n.ПеревестиСекундыВСтроку(оБуфер.end(оБуфер.length - 1) + _чСмещениеНачалаТрансляции, true);
			}
		}
	}
	
	function ПоказатьЗадержкуТрансляции(оСегмент)
	{
		if (м_Статистика.ОкноПоказано())
		{
			var сЗадержка = '';
			if (ЭтоЧисло(оСегмент.пДанные.чВремяКодирования))
			{
				var чТекущееВремя = _oMediaElement.currentTime;
				if (чТекущееВремя !== 0)
				{
					var чЧасть1 = (Date.now() - оСегмент.пДанные.чВремяКодирования) / 1000;
					var чЧасть2 = оСегмент.пДанные.чПозицияКодирования - чТекущееВремя;
					сЗадержка = `${чЧасть1.toFixed(1)} + ${чЧасть2.toFixed(1)} = ${(чЧасть1 + чЧасть2).toFixed(1)}`;
				}
			}
			м_Журнал.Вот(`[Проигрыватель] Задержка трансляции ${сЗадержка}с`);
			document.getElementById('статистика-задержкатрансляции').textContent = сЗадержка;
		}
	}

	function ПрименитьНастройкиЗвука()
	{
		_oMediaElement.volume = м_Настройки.Получить('чГромкость2') / МАКСИМАЛЬНАЯ_ГРОМКОСТЬ;
		_oMediaElement.muted = м_Настройки.Получить('лПриглушить');
	}

	function ПерезагрузитьИЖдатьЗаполненияБуфера(чНовоеСостояние)
	{
		_лЖдатьЗаполненияБуфера = true;
		ПерезагрузитьПроигрыватель(чНовоеСостояние);
	}

	function ПерезагрузитьПроигрыватель(чНовоеСостояние)
	{
		ПоказатьСостояние('Окак', 'Перезагрузка проигрывателя');
		м_Управление.ИзменитьСостояние(чНовоеСостояние);
		_оПоведение = _оПрямаяТрансляция;
		_oMediaSourceBuffer = null;
		_лНужнаПеремотка = false;
		// - _oMediaElement.pause().
		// - _oMediaElement.currentTime = 0.
		// - _oMediaElement.playbackRate = 1.
		// - Посылает abort в _oMediaSourceBuffer если нужно.
		// - Отсоединяет _oMediaSourceBuffer от _oMediaSource.
		// - Закрывает _oMediaSource.
		// - Открывает _oMediaSource.
		_oMediaElement.load();
		// Ждем вызова ОбработатьSourceOpen().
	}

	function СледитьЗаОшибками()
	{
		if (_oMediaElement.error)
		{
			м_Отладка.ЗавершитьРаботуИПоказатьСообщение('J0206');
		}
	}

	const СледитьЗаСобытиямиMediaSource = ДобавитьОбработчикИсключений(оСобытие =>
	{
		СледитьЗаОшибками();
		var сЗапись = `[MediaSource] ${оСобытие.type}`;
		switch (оСобытие.type)
		{
		case 'sourceopen':
			ПоказатьСостояние('Вот', сЗапись);
			_оПоведение.ОбработатьSourceOpen();
			break;

		case 'sourceended':
		case 'sourceclose':
			ПоказатьСостояние('Вот', сЗапись);
			break;
	
		default:
			м_Журнал.Вот(сЗапись);
		}
	});

	const СледитьЗаСобытиямиMediaElement = ДобавитьОбработчикИсключений(оСобытие =>
	{
		СледитьЗаОшибками();
		var сЗапись = `[MediaElement] ${оСобытие.type}`;
		switch (оСобытие.type)
		{
		case 'loadstart':
			ПоказатьСостояние('Вот', `${сЗапись} src=${_oMediaElement.src} currentSrc=${_oMediaElement.currentSrc}`);
			break;

		case 'progress':
			ПоказатьСостояние('Вот', сЗапись);
			_оПоведение.ОбработатьProgress();
			break;

		case 'abort':
			ПоказатьСостояние('Вот', сЗапись);
			break;

		case 'waiting':
			ПоказатьСостояние('Окак', сЗапись);
			_оПоведение.ОбработатьWaiting();
			break;

		case 'playing':
			ПоказатьСостояние('Вот', сЗапись);
			_оПоведение.ОбработатьPlaying();
			break;

		case 'seeking':
			ПоказатьСостояние('Вот', сЗапись);
			_оПоведение.ОбработатьSeeking();
			break;

		case 'seeked':
			ПоказатьСостояние('Вот', сЗапись);
			_оПоведение.ОбработатьSeeked();
			break;

		case 'ended':
			ПоказатьСостояние('Вот', сЗапись);
			_оПоведение.ОбработатьEnded();
			break;

		case 'timeupdate':
			м_Журнал.Вот(`${сЗапись} readyState=${_oMediaElement.readyState} currentTime=${_oMediaElement.currentTime} НеПросмотрено=${м_Журнал.F2(ПолучитьЗаполненностьБуфера().чНеПросмотрено)}`);
			_оПоведение.ОбработатьTimeUpdate();
			break;

			case 'canplay':
				fitVideo()
				break

		case 'volumechange':
			м_Журнал.Вот(`${сЗапись} volume=${_oMediaElement.volume} muted=${_oMediaElement.muted}`);
			break;

		default:
			м_Журнал.Вот(сЗапись);
		}
	});

	function ПроверитьПозициюВоспроизведения(чИсточникПроверки, чБудетДобавлено /* = 0 */)
	// Это единственная функция, которая во время прямой трансляции изменяет _oMediaElement.currentTime.
	// ПРОВЕРИТЬ_ДОБАВЛЕНИЕ_СЕГМЕНТА:
	// - Переносит вперед _oMediaElement.currentTime чтобы предотвратить переполнение буфера.
	// - Ничего не возвращает.
	// ПРОВЕРИТЬ_НАЧАЛО_ВОСПРОИЗВЕДЕНИЯ, ПРОВЕРИТЬ_ВОСПРОИЗВЕДЕНИЕ, ПРОВЕРИТЬ_ОСТАНОВКА_ВОСПРОИЗВЕДЕНИЯ:
	// - Переносит вперед _oMediaElement.currentTime если найдена область >= МИН_РАЗМЕР_БУФЕРА.
	// - Вызывает БуферИсчерпан() если область не найдена и идет воспроизведение.
	// Возвращает:
	// - ВОСПРОИЗВЕДЕНИЕ_НЕВОЗМОЖНО если область не найдена.
	// - ВОСПРОИЗВЕДЕНИЕ_ВОЗМОЖНО если область найдена.
	// - ВОСПРОИЗВЕДЕНИЕ_ВОЗМОЖНО_ПОСЛЕ_ПЕРЕМОТКИ если область найдена и запущена перемотка.
	{
		if (чБудетДобавлено === undefined)
		{
			чБудетДобавлено = 0;
		}
		const оБуфер = _oMediaElement.buffered;
		const чПоследняяОбласть = оБуфер.length - 1;
		if (чПоследняяОбласть === -1)
		{
			return false;
		}
		// Chrome 47: currentTime может быть на 0.000001 секунды меньше присвоенной величины.
		// Если это не учесть, то получим бесконечную перемотку на начало области.
		const чТекущееВремя = _oMediaElement.currentTime + 0.0001;
		var чПеремотатьДо = Math.max(чТекущееВремя, оБуфер.start(0));
		var сПричинаПеремотки = '';
		const чНеПросмотрено = оБуфер.end(чПоследняяОбласть) - чПеремотатьДо;

		// Пропустить часть видео, чтобы не увеличивать задержку трансляции и чтобы _oMediaSource и
		// УдалитьПросмотренноеВидео() начали удалять просмотренное видео, предотвращая переполнение
		// _oMediaSourceBuffer. _oMediaSource при удалении (coded frame eviction) учитывает currentTime
		// и не учитывает played и paused.
		// Причины переполнения:
		// - Chrome 49: _oMediaSource был закрыт до первого перехода на вкладку.
		// - Разделять по ключевым кадрам и очень длинный GOP.
		// - Окончание трансляции (часть которой застряла на сервере?) и сразу начало новой (заранее записанной?).
		// - Серьезный затык в сети или на сервере.
		// - Изменение настроек.
		// - Очень большое количество разрывов.
		// - Выход из спячки.
		// - Edge 15: Выход из WIN + L.
		// - Зависание перемотки или воспроизведения.
		if (чИсточникПроверки === ПРОВЕРИТЬ_ДОБАВЛЕНИЕ_СЕГМЕНТА)
		{
			const чРазмерБуфера = м_Настройки.Получить('чМаксРазмерБуфера');
			const чПереполнение = чРазмерБуфера + м_Настройки.Получить('чРастягиваниеБуфера');
			if (чНеПросмотрено <= чПереполнение)
			{
				return; // Возвращаемое значение не используется.
			}
			// Не показывать переполнение если оно произошло из-за позднего перехода на вкладку.
			if (_чВоспроизведениеНачиналось >= 2)
			{
				м_События.ОбработатьСобытие('проигрыватель-переполненбуфер', чНеПросмотрено - чРазмерБуфера);
			}
			сПричинаПеремотки += `Переполнен буфер проигрывателя ${чНеПросмотрено.toFixed(2)}с > ${чПереполнение}с. `;
			// Немного добавить, чтобы непросмотренного точно хватило для начала воспроизведения.
			чПеремотатьДо = оБуфер.end(чПоследняяОбласть) - чРазмерБуфера - 0.1;
		}

		// После перехода на вкладку начальная задержка трансляции может составить чРазмерБуфера + чРастягиваниеБуфера, что слишком много.
		// Если переход выполнен поздно, то в процессе добавления сегментов и начала воспроизведения может несколько раз сработать защита
		// от переполнения буфера и один раз защита от превышения задержки трансляции.
		if (чИсточникПроверки === ПРОВЕРИТЬ_НАЧАЛО_ВОСПРОИЗВЕДЕНИЯ && _чВоспроизведениеНачиналось < 2)
		{
			_чВоспроизведениеНачиналось = 2;
			// Длительность сегментов не всегда кратна размеру буфера.
			// Также нужно немного добавить, чтобы непросмотренного точно хватило для начала воспроизведения.
			const чПереполнение = м_Настройки.Получить('чМаксРазмерБуфера') + м_Статистика.ПолучитьTargetDuration() / 2;
			if (чНеПросмотрено > чПереполнение)
			{
				сПричинаПеремотки += `Превышена задержка трансляции ${чНеПросмотрено.toFixed(2)}с > ${чПереполнение}с. `;
				чПеремотатьДо = оБуфер.end(чПоследняяОбласть) - чПереполнение;
			}
		}

		// Chrome 48, Firefox 48: Иногда currentTime вылезает за пределы области.
		//
		// Chrome 59 + Windows + аппаратное декодирование: Перемотка не завершится пока после точки перемотки не появится достаточно кадров
		// для начала воспроизведения. Пример: В буфере 1.0-5.1 с. После перемотки до 5.0 с, 100 мс (3 кадра) недостаточно для воспроизведения.
		// Добавлены кадры, часть которых утеряна, в буфере 1.0-5.1 6.0-10.0. Перемотка никогда не завершится. Чтобы этого не произошло,
		// запрещаем перемотку и воспроизведение если данных недостаточно. Исключение сделано для переполнения буфера.
		Проверить(ИСЧЕРПАНИЕ_БУФЕРА < МИН_РАЗМЕР_БУФЕРА);
		var чНужноДляВоспроизведения = чИсточникПроверки === ПРОВЕРИТЬ_ВОСПРОИЗВЕДЕНИЕ ? ИСЧЕРПАНИЕ_БУФЕРА
		                             : чИсточникПроверки === ПРОВЕРИТЬ_ОСТАНОВКА_ВОСПРОИЗВЕДЕНИЯ ? Infinity
		                             : МИН_РАЗМЕР_БУФЕРА;
		var лВоспроизведениеВозможно = _oMediaSource.readyState === 'ended';
		for (var чОбласть = 0; чОбласть <= чПоследняяОбласть; ++чОбласть)
		{
			if (чПеремотатьДо < оБуфер.start(чОбласть))
			{
				чНужноДляВоспроизведения = МИН_РАЗМЕР_БУФЕРА;
				сПричинаПеремотки += 'Перепрыгиваю яму. ';
				чПеремотатьДо = оБуфер.start(чОбласть);
			}
			var чДоКонцаОбласти = оБуфер.end(чОбласть) - чПеремотатьДо;
			if (чДоКонцаОбласти >= чНужноДляВоспроизведения)
			{
				лВоспроизведениеВозможно = true;
				break;
			}
		}

		if (!лВоспроизведениеВозможно && !_oMediaElement.paused)
		{
			// Остановить воспроизведение если нужно.
			БуферИсчерпан(чДоКонцаОбласти, чНеПросмотрено, чБудетДобавлено);
		}
		
		if ((лВоспроизведениеВозможно || чИсточникПроверки === ПРОВЕРИТЬ_ДОБАВЛЕНИЕ_СЕГМЕНТА) && (чПеремотатьДо !== чТекущееВремя || _лНужнаПеремотка))
		{
			// Разрывы в _oMediaElement.played нам не нужны.
			if (чПеремотатьДо === чТекущееВремя)
			{
				чПеремотатьДо = _oMediaElement.currentTime;
			}
			ПоказатьСостояние(сПричинаПеремотки ? 'Ой' : 'Окак', `${сПричинаПеремотки}Перематываю до ${чПеремотатьДо}`)
			_лНужнаПеремотка = false;
			_oMediaElement.currentTime = чПеремотатьДо;
			// Edge 15 и Chrome 59: _oMediaElement.seeking возвращает false после изменения _oMediaElement.currentTime.
			// В Chrome 59 бывает редко. https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/12581492/
			return ВОСПРОИЗВЕДЕНИЕ_ВОЗМОЖНО_ПОСЛЕ_ПЕРЕМОТКИ;
		}

		return лВоспроизведениеВозможно ? ВОСПРОИЗВЕДЕНИЕ_ВОЗМОЖНО : ВОСПРОИЗВЕДЕНИЕ_НЕВОЗМОЖНО;
	}

	function НачатьВоспроизведение(чПроверка /* необязательный */)
	// Это единственная функция, которая во время прямой трансляции вызывает _oMediaElement.play().
	//
	// Firefox 45: После окончания перемотки, _oMediaElement.readyState может остаться равным HAVE_CURRENT_DATA. Возможно
	// потому что после _oMediaElement.currentTime доступно < 25 кадров. Для увеличения _oMediaElement.readyState
	// нужно вызвать _oMediaElement.play().
	//
	// Firefox 45: Если УдалитьПросмотренноеВидео() удалит из буфера всё видео, но оставит часть звука, то возможно состояние:
	// _oMediaElement.readyState == HAVE_CURRENT_DATA и _oMediaElement.buffered.length == 0.
	{
		if ((_oMediaElement.seeking || чПроверка === ВОСПРОИЗВЕДЕНИЕ_ВОЗМОЖНО_ПОСЛЕ_ПЕРЕМОТКИ) || !_oMediaElement.paused || _oMediaElement.ended)
		{
			return;
		}

		if (_лЖдатьЗаполненияБуфера && _oMediaSource.readyState !== 'ended')
		{
			const чНеПросмотрено = ПолучитьЗаполненностьБуфера().чНеПросмотрено;
			const чРазмерБуфера = м_Настройки.Получить(_сРазмерБуфера);
			if (чНеПросмотрено < чРазмерБуфера)
			{
				м_Журнал.Вот(`[Проигрыватель] В буфере не просмотрено ${м_Журнал.F3(чНеПросмотрено)}с < ${чРазмерБуфера}с`);
				return;
			}
			м_Журнал.Окак(`[Проигрыватель] В буфере не просмотрено ${м_Журнал.F3(чНеПросмотрено)}с >= ${чРазмерБуфера}с`);
		}
		else
		{
			м_Журнал.Окак('[Проигрыватель] Не нужно ждать заполнения буфера');
		}

		switch (ПроверитьПозициюВоспроизведения(ПРОВЕРИТЬ_НАЧАЛО_ВОСПРОИЗВЕДЕНИЯ))
		{
		case ВОСПРОИЗВЕДЕНИЕ_НЕВОЗМОЖНО:
			ПоказатьСостояние('Ой', `Не найдена область >= ${МИН_РАЗМЕР_БУФЕРА}с для начала воспроизведения`);
			_лЖдатьЗаполненияБуфера = true;
			break;

		// Не начинаем воспроизведение во время перемотки, потому что ПроверитьПозициюВоспроизведения() могла перескочить
		// яму, из-за чего длительность непросмотренного видео могла упасть ниже _сРазмерБуфера. Нужно проверить
		// заполненность буфера еще раз.
		// TODO Ждем окончания перемотки чтобы повысить стабильность в Firefox?
		case ВОСПРОИЗВЕДЕНИЕ_ВОЗМОЖНО:
			ПоказатьСостояние('Окак', 'Начало воспроизведения');
			_лЖдатьЗаполненияБуфера = true;
			_oMediaElement.play();
			// Может пройти больше секунды, прежде чем начало видео будет декодировано и показано.
			// Ждем события playing для смены состояния.
			//
			// Firefox 45: Иногда, скорее всего из-за ошибки лисы, после события seeked и вызова play(), readyState
			// остается равно HAVE_METADATA и не прилетают loadeddata, canplay, canplaythrough и playing. Воспроизведение
			// идет нормально (не знаю насколько долго).
			м_Управление.ИзменитьСостояние(СОСТОЯНИЕ_НАЧАЛО_ВОСПРОИЗВЕДЕНИЯ);
			break;
		}
	}

	function ОстановитьВоспроизведение(чНовоеСостояние)
	// Это единственная функция, которая во время прямой трансляции вызывает _oMediaElement.pause().
	{
		if (чНовоеСостояние !== undefined)
		{
			м_Управление.ИзменитьСостояние(чНовоеСостояние);
		}
		{
			_oMediaElement.pause();
		}
	}

	function БуферИсчерпан(чДоКонцаПоследнейОбласти, чНеПросмотрено, чБудетДобавлено)
	{
		Проверить(_oMediaSource.readyState !== 'ended');
		Проверить(чДоКонцаПоследнейОбласти < МИН_РАЗМЕР_БУФЕРА);
		const лДосрочно = чНеПросмотрено > 1.0;
		м_Статистика.ИсчерпанБуферПроигрывателя(лДосрочно);
		_сРазмерБуфера = 'чМаксРазмерБуфера';
		const чРазмерБуфера = м_Настройки.Получить(_сРазмерБуфера);
		if (чДоКонцаПоследнейОбласти + чБудетДобавлено >= МИН_РАЗМЕР_БУФЕРА && чНеПросмотрено + чБудетДобавлено >= чРазмерБуфера)
		{
			// Это может произойти с нулевым чБудетДобавлено:
			// - Firefox 54 и ИСПОЛЬЗОВАТЬ_WAITING: Исчерпание буфера произошло во время appendBuffer():
			//   readyState=HAVE_ENOUGH_DATA ▪ appendBuffer() ▪ readyState=HAVE_CURRENT_DATA ▪ timeupdate ▪ waiting
			// - Firefox 48 и ИСПОЛЬЗОВАТЬ_WAITING: Остановка перед невидимой ямой, которая появилась из-за перепутаных CTS кадров.
			ПоказатьСостояние(лДосрочно ? 'Ой' : 'Окак', `Буфер исчерпан, остановка не нужна БудетДобавлено=${м_Журнал.F3(чБудетДобавлено)}с ДоКонцаПоследнейОбласти=${м_Журнал.F3(чДоКонцаПоследнейОбласти)}с НеПросмотрено=${м_Журнал.F3(чНеПросмотрено)}с РазмерБуфера=${чРазмерБуфера}с`);
		}
		else
		{
			ПоказатьСостояние(лДосрочно ? 'Ой' : 'Окак', `Приостанавливаю воспроизведение для заполнения буфера ДоКонцаПоследнейОбласти=${м_Журнал.F3(чДоКонцаПоследнейОбласти)}с НеПросмотрено=${м_Журнал.F3(чНеПросмотрено)}с РазмерБуфера=${чРазмерБуфера}с`);
			_лНужнаПеремотка = true;
			// Вместо pause() можно обнулить playbackRate.
			ОстановитьВоспроизведение(СОСТОЯНИЕ_ЗАГРУЗКА);
		}
	}

	function УдалитьПросмотренноеВидео()
	{
		var чДлительностьПовтора = м_Настройки.Получить('чДлительностьПовтора2');
		if (чДлительностьПовтора === АВТОНАСТРОЙКА)
		{
			return Promise.resolve();
		}
		var оВБуфере = ПолучитьЗаполненностьБуфера(_oMediaSourceBuffer.buffered);
		{
			if (оВБуфере.чПросмотрено < чДлительностьПовтора + ИНТЕРВАЛ_УДАЛЕНИЯ_ВИДЕО)
			{
				return Promise.resolve();
			}
			var чУдалитьДо = _oMediaElement.currentTime - чДлительностьПовтора;
		}

		return new Promise((фВыполнить, фОтказаться) =>
		{
			ПоказатьСостояние('Вот', `Удаляю просмотренное видео Просмотрено=${м_Журнал.F3(оВБуфере.чПросмотрено)}с УдалитьДо=${м_Журнал.F3(чУдалитьДо)}с`);
			_oMediaSourceBuffer.addEventListener('updateend', Удалено);
			var чПрошлоВремени = -performance.now();
			_oMediaSourceBuffer.remove(0, чУдалитьДо);

			function Удалено()
			{
				try
				{
					// Удаление прервано в ПерезагрузитьПроигрыватель()? Обрабатывать событие abort не нужно.
					if (_oMediaSourceBuffer === null)
					{
						фОтказаться(ОтменаОбещания.ОБЕЩАНИЕ_ОТМЕНЕНО);
					}
					else
					{
						чПрошлоВремени += performance.now();
						_oMediaSourceBuffer.removeEventListener('updateend', Удалено);
						оВБуфере = ПолучитьЗаполненностьБуфера(_oMediaSourceBuffer.buffered);
						ПоказатьСостояние(чПрошлоВремени > 100 || оВБуфере.чПросмотрено < МИН_РАЗМЕР_БУФЕРА ? 'Ой' : 'Вот',
							`Просмотренное видео удалено за ${м_Журнал.F0(чПрошлоВремени)}мс Просмотрено=${м_Журнал.F0(оВБуфере.чПросмотрено)}с`);
						фВыполнить();
					}
				}
				catch (пИсключение)
				{
					фОтказаться(пИсключение);
				}
			}
		});
	}

	function ДобавитьСегмент(оСегмент, лИнициализация)
	{
		return new Promise((фВыполнить, фОтказаться) =>
		{
			ПоказатьСостояние('Вот', `Добавляю ${лИнициализация ? 'сегмент инициализации' : 'медиасегмент'} ${оСегмент.чНомер}`);
			_oMediaSourceBuffer.addEventListener('updateend', Добавлено);
			var чПрошлоВремени = -performance.now();
			_oMediaSourceBuffer.appendBuffer(лИнициализация ? оСегмент.пДанные.мбСегментИнициализации : оСегмент.пДанные.мбМедиасегмент);
		
			function Добавлено()
			{
				try
				{
					// Добавление прервано в ПерезагрузитьПроигрыватель()? Обрабатывать событие abort не нужно.
					if (_oMediaSourceBuffer === null)
					{
						фОтказаться(ОтменаОбещания.ОБЕЩАНИЕ_ОТМЕНЕНО);
					}
					else
					{
						чПрошлоВремени += performance.now();
						_oMediaSourceBuffer.removeEventListener('updateend', Добавлено);
						ПоказатьСостояние(чПрошлоВремени > 100 ? 'Ой' : 'Вот',
							`Добавлен сегмент ${оСегмент.чНомер} за ${м_Журнал.F0(чПрошлоВремени)}мс`);
						фВыполнить();
					}
				}
				catch (пИсключение)
				{
					фОтказаться(пИсключение);
				}
			}
		});
	}

	function ПредотвратитьПереполнениеОчереди()
	// Chrome 49: _oMediaSource закрыт до первого перехода на вкладку. Если пользователь забудет перейти, то получим переполнение
	// очереди. Немного ждем и останавливаем работу, чтобы избежать переполнения и не нагружать напрасно железо.
	// TODO Если в очереди есть разрывы, то теоретически задержка трансляции может превышать указанную в настройках проигрывателя.
	{
		// Нет смысла накапливать больше ПЕРЕПОЛНЕНИЕ_БУФЕРА, потому что этот излишек будет пропущен. Останавливать просмотр трансляции
		// по достижении чРазмерБуфера или даже чРазмерБуфера + чРастягиваниеБуфера слишком рано, потому что пользователь с широким каналом
		// не успеет переключиться на вкладку.
		var чПреобразовано = г_моОчередь.ПолучитьКоличествоПреобразованныхСегментов().чДлительность;
		if (чПреобразовано >= ПЕРЕПОЛНЕНИЕ_БУФЕРА)
		{
			м_Журнал.Ой(`[Проигрыватель] MediaSource закрыт слишком долго ${чПреобразовано}с >= ${ПЕРЕПОЛНЕНИЕ_БУФЕРА}с`);
			Проверить(м_Управление.ПолучитьСостояние() === СОСТОЯНИЕ_ЗАПУСК || м_Управление.ПолучитьСостояние() === СОСТОЯНИЕ_НАЧАЛО_ТРАНСЛЯЦИИ);
			м_Управление.ПереключитьПросмотрТрансляции();
		}
	}

	function ЗавершитьПоток(оСегмент)
	// Это единственная функция, которая во время прямой трансляции вызывает _oMediaSource.endOfStream().
	// Chrome 50: До endOfStream() _oMediaElement.duration может быть еще = NaN.
	// Chrome 49: Если не было appendBuffer(), то после endOfStream() _oMediaElement.duration = Infinity. https://bugs.chromium.org/p/chromium/issues/detail?id=604353
	{
		ПоказатьСостояние('Окак', `Сегмент ${оСегмент.чНомер} вызвал окончание потока`);
		// После endOfStream() в _oMediaElement.buffered могут появиться области без звука или видео. Firefox 48, согласно текущей
		// версии стандарта, на такие места не перематывает. Chrome 52 перематывает и воспроизводит. Чтобы в Firefox воспроизведение
		// не зависло, проверяем _oMediaElement.buffered ДО вызова endOfStream(). https://bugzilla.mozilla.org/show_bug.cgi?id=1294412
		if (_oMediaElement.buffered.length === 0
		// Часто перед окончанием потока в буфере остается ИСЧЕРПАНИЕ_БУФЕРА (если не ИСПОЛЬЗОВАТЬ_WAITING) и несколько кадров,
		// застревающих в рабочем потоке: Пауза ▪ Воспроизведение нескольких кадров ▪ Пауза ▪ Воспроизведение другого видео.
		// Смотрить на это не слишком приятно, поэтому не начинаем воспроизведение ради нескольких кадров.
		|| (_oMediaElement.paused && ПолучитьЗаполненностьБуфера().чНеПросмотрено < ИСЧЕРПАНИЕ_БУФЕРА + 0.1))
		{
			ПерезагрузитьИЖдатьЗаполненияБуфера(СОСТОЯНИЕ_ЗАГРУЗКА);
		}
		else
		{
			// Перемотка во время прямой трансляции означает, что в буфере достаточно данных для воспроизведения.
			_лЖдатьЗаполненияБуфера = typeof оСегмент.пДанные === 'number' || (!_oMediaElement.seeking && _oMediaElement.paused);
			_oMediaSource.endOfStream();
			НачатьВоспроизведение();
		}
	}

	function ДобавитьСледующийСегмент()
	{
		Проверить(_oMediaElement);

		const оСегмент = г_моОчередь[0];
		if (_лАсинхроннаяОперация || !оСегмент || оСегмент.чОбработка !== ОБРАБОТКА_ПРЕОБРАЗОВАН)
		{
			return;
		}
		Проверить(_оПоведение === _оПрямаяТрансляция);

		if (оСегмент.пДанные === СОСТОЯНИЕ_НАЧАЛО_ТРАНСЛЯЦИИ)
		{
			Проверить(_oMediaSource.sourceBuffers.length === 0);
			м_Управление.ИзменитьСостояние(оСегмент.пДанные);
			г_моОчередь.Удалить(0);
			ДобавитьСледующийСегмент();
			return;
		}

		if (оСегмент.пДанные === СОСТОЯНИЕ_ПОВТОР)
		{
			Проверить(м_Управление.ПолучитьСостояние() !== СОСТОЯНИЕ_ОСТАНОВКА && м_Управление.ПолучитьСостояние() !== СОСТОЯНИЕ_ПОВТОР);
			ЗапуститьПовтор();
			г_моОчередь.Удалить(0);
			ДобавитьСледующийСегмент();
			return;
		}

		const сГотовность = _oMediaSource.readyState;
		if (сГотовность !== 'open')
		{
			м_Журнал.Вот(`[Проигрыватель] Добавление сегмента ${оСегмент.чНомер} отложено MediaSource.readyState=${сГотовность} MediaElement.src=${_oMediaElement.src}`);
			if (сГотовность === 'closed' && _чВоспроизведениеНачиналось === 0)
			{
				ПредотвратитьПереполнениеОчереди();
			}
			return;
		}

		if (оСегмент.лРазрыв && _oMediaSource.sourceBuffers.length !== 0)
		{
			ЗавершитьПоток(оСегмент);
			return;
		}

		if (оСегмент.пДанные === СОСТОЯНИЕ_ЗАВЕРШЕНИЕ_ТРАНСЛЯЦИИ)
		{
			Проверить(оСегмент.лРазрыв && _oMediaSource.sourceBuffers.length === 0);
			м_Управление.ИзменитьСостояние(оСегмент.пДанные);
			г_моОчередь.Удалить(0);
			ДобавитьСледующийСегмент();
			return;
		}

		ДобавитьБуферы(оСегмент);

		_лАсинхроннаяОперация = true;
		let оОбещание = УдалитьПросмотренноеВидео()
		.then(() =>
		{
			// Событие timeupdate посылается редко, каждые 250..500 мс, поэтому исчерпание буфера может быть пропущено,
			// что особенно неприятно в Edge 15 с его принудительной буферизацией. Добавляем еще одну проверку перед изменением
			// буфера. Почему проверка после удаления видео, а не перед ним: это повышает вероятность обнаружить исчерпание
			// буфера и повышает точность чБудетДобавлено, потому что за время удаления видео позиция воспроизведения изменяется.
			// Код в этой функции аналогичен обработчику timeupdate, за исключением передачи параметра чБудетДобавлено.
			if (!_oMediaElement.seeking && !_oMediaElement.paused && !_oMediaElement.ended)
			{
				ПроверитьПозициюВоспроизведения(ПРОВЕРИТЬ_ВОСПРОИЗВЕДЕНИЕ, оСегмент.чДлительность);
			}
		}) // ; мешает IntelliSense
		if (оСегмент.пДанные.мбСегментИнициализации)
		{
			оОбещание = оОбещание.then(() => ДобавитьСегмент(оСегмент, true));
		}
		оОбещание.then(() =>
		{
			return ДобавитьСегмент(оСегмент, false);
		})
		.then(() =>
		{
			_лАсинхроннаяОперация = false;
			г_моОчередь.Удалить(оСегмент);
			// Нет смысла начинать воспроизведение если запрошен повтор.
			if (!(г_моОчередь[0] && г_моОчередь[0].пДанные === СОСТОЯНИЕ_ПОВТОР))
			{
				РасчитатьСмещениеНачалаТрансляции(оСегмент);
				// Предотвратить переполнение буфера проигрывателя.
				const чПроверка = ПроверитьПозициюВоспроизведения(ПРОВЕРИТЬ_ДОБАВЛЕНИЕ_СЕГМЕНТА);
				// Начать воспроизведение только после добавления всех накопившихся в очереди преобразованных сегментов.
				// Во время добавления части добавленного потока могут многократно удаляться из-за переполнения буфера.
				// Похожая проверка есть в ОбработатьProgress().
				if (!(г_моОчередь[0] && г_моОчередь[0].чОбработка === ОБРАБОТКА_ПРЕОБРАЗОВАН))
				{
					НачатьВоспроизведение(чПроверка);
					ПоказатьПродолжительностьТрансляции();
					ПоказатьЗадержкуТрансляции(оСегмент);
				}
			}
			ДобавитьСледующийСегмент();
		})
		.catch(ДобавитьОбработчикИсключений(пПричина =>
		{
			_лАсинхроннаяОперация = false;
			if (пПричина === 'ДОБАВЛЕНИЕ СЕГМЕНТА ОТЛОЖЕНО')
			{
				return;
			}
			г_моОчередь.Удалить(оСегмент);
			// ПерезагрузитьПроигрыватель() прервала выполнение УдалитьПросмотренноеВидео() или ДобавитьСегмент()?
			if (пПричина === ОтменаОбещания.ОБЕЩАНИЕ_ОТМЕНЕНО)
			{
				м_Журнал.Вот(`[Проигрыватель] Отменено добавление сегмента ${оСегмент.чНомер}`);
			}
			else
			{
				м_Отладка.ПойманоИсключение(пПричина);
			}
		}));
	}

	function ПеремотатьПовторДо(чПеремотатьДо)
	{
		Проверить(м_Управление.ПолучитьСостояние() === СОСТОЯНИЕ_ПОВТОР);
		_оПовтор.ПроверитьПозициюВоспроизведения(чПеремотатьДо);
	}

	function ПеремотатьПовторНа(лКадры, чПеремотатьНа)
	{
		Проверить(м_Управление.ПолучитьСостояние() === СОСТОЯНИЕ_ПОВТОР);
		Проверить(Number.isFinite(чПеремотатьНа));
		if (лКадры)
		{
			чПеремотатьНа *= м_Статистика.ПолучитьДлительностьКадраВСекундах().чМинимальная;
		}
		if (чПеремотатьНа !== 0)
		{
			ПеремотатьПовторДо(Ограничить(_oMediaElement.currentTime + чПеремотатьНа, м_Шкала.ПолучитьНачало(), м_Шкала.ПолучитьКонец()));
		}
	}

	function ПереключитьПаузу()
	{
		Проверить(м_Управление.ПолучитьСостояние() === СОСТОЯНИЕ_ПОВТОР);
		if (_оПовтор.лПауза = !_оПовтор.лПауза)
		{
			м_Журнал.Окак('[Проигрыватель] Ставлю повтор на паузу');
			_oMediaElement.pause();
		}
		else
		{
			м_Журнал.Окак('[Проигрыватель] Снимаю повтор с паузы');
			_оПовтор.ПроверитьПозициюВоспроизведения(ПРОВЕРИТЬ_НАЧАЛО_ВОСПРОИЗВЕДЕНИЯ);
			_oMediaElement.play();
		}
		м_События.ОбработатьСобытие('проигрыватель-пауза', _оПовтор.лПауза);
	}

	function ЗадатьСкоростьПовтора(чСкорость)
	{
		Проверить(м_Управление.ПолучитьСостояние() === СОСТОЯНИЕ_ПОВТОР);
		_oMediaElement.playbackRate = чСкорость;
	}

	function ЗапуститьПовтор()
	{
		_оПовтор.лПауза = true;
		_оПоведение = _оПовтор;
		ОстановитьВоспроизведение();
		// Chrome 52: Если вызвать endOfStream() до addSourceBuffer(), то _oMediaElement.error.code = MEDIA_ERR_SRC_NOT_SUPPORTED.
		if (_oMediaSource.sourceBuffers.length !== 0 && _oMediaSource.readyState === 'open')
		{
			_oMediaSource.endOfStream();
		}

		var чПросмотрено = ПолучитьЗаполненностьБуфера().чПросмотрено;
		if (чПросмотрено < ПОВТОР_НЕДОСТУПЕН_ЕСЛИ_ПРОСМОТРЕНО_МЕНЬШЕ_ЧЕМ)
		{
			ПоказатьСостояние('Окак', 'Повторять нечего');
			м_Управление.ИзменитьСостояние(СОСТОЯНИЕ_ОСТАНОВКА);
			return;
		}

		ПоказатьСостояние('Окак', 'Запуск повтора');
		_oMediaElement.playbackRate = м_Управление.ПолучитьСкоростьВоспроизведения();
		м_События.ОбработатьСобытие('проигрыватель-пауза', _оПовтор.лПауза);
		// Chrome 48: Иногда currentTime вылезает за пределы области.
		м_Шкала.ЗадатьНачалоИКонец(_oMediaElement.buffered.start(0), _oMediaElement.buffered.start(0) + чПросмотрено);
		м_Шкала.ЗадатьПросмотрено(_oMediaElement.currentTime);
		м_Управление.ИзменитьСостояние(СОСТОЯНИЕ_ПОВТОР);
	}

	function ДобавитьБуферы(оСегмент)
	{
		if (_oMediaSource.sourceBuffers.length === 0)
		{
			м_Журнал.Окак(`[Проигрыватель] Добавляю буфер ${оСегмент.пДанные.сКодеки}`);
			Проверить(оСегмент.лРазрыв && оСегмент.пДанные.сКодеки);
			try
			{
				_oMediaSourceBuffer = _oMediaSource.addSourceBuffer(оСегмент.пДанные.сКодеки);
			}
			catch (пИсключение)
			{
				// Edge 15 кидает DOMException, которое не является потомком Error.
				if (ЭтоОбъект(пИсключение) && пИсключение.name === 'NotSupportedError')
				{
					м_Отладка.ЗавершитьРаботуИПоказатьСообщение('J0201');
				}
				else
				{
					м_Отладка.ПойманоИсключение(пИсключение);
				}
			}
			_oMediaSourceBuffer.addEventListener('updatestart', СледитьЗаСобытиямиMediaSource);
			_oMediaSourceBuffer.addEventListener('update',      СледитьЗаСобытиямиMediaSource);
			_oMediaSourceBuffer.addEventListener('updateend',   СледитьЗаСобытиямиMediaSource);
			_oMediaSourceBuffer.addEventListener('abort',       СледитьЗаСобытиямиMediaSource);
			_oMediaSourceBuffer.addEventListener('error',       СледитьЗаСобытиямиMediaSource);
		}
	}

	function Запустить()
	{
		Проверить(!_oMediaElement);

		try
		{
			_oMediaSource = new MediaSource();
		}
		catch (и)
		{
			м_Отладка.ЗавершитьРаботуИПоказатьСообщение('J0202');
		}
		_oMediaSource.addEventListener('sourceopen',                       СледитьЗаСобытиямиMediaSource);
		_oMediaSource.addEventListener('sourceended',                      СледитьЗаСобытиямиMediaSource);
		_oMediaSource.addEventListener('sourceclose',                      СледитьЗаСобытиямиMediaSource);
		_oMediaSource.sourceBuffers.addEventListener('addsourcebuffer',    СледитьЗаСобытиямиMediaSource);
		_oMediaSource.sourceBuffers.addEventListener('removesourcebuffer', СледитьЗаСобытиямиMediaSource);

		_oMediaElement = document.getElementById('глаз');
		ПрименитьНастройкиЗвука();
		for (var сСобытие of
		[
			'progress', 'error', 'playing', 'seeking', 'seeked', 'ended', 'timeupdate',
			'waiting',
			'loadstart', 'suspend', 'abort', 'emptied', 'stalled', 'loadedmetadata', 'loadeddata',
			'canplay', 'canplaythrough', 'durationchange', 'play', 'pause', 'ratechange', 'resize'
		])
		{
			_oMediaElement.addEventListener(сСобытие, СледитьЗаСобытиямиMediaElement);
		}
		_oMediaElement.src = URL.createObjectURL(_oMediaSource);
		return true;
	}


	function Остановить()
	{
		if (_oMediaElement)
		{
			URL.revokeObjectURL(_oMediaElement.src);
			_oMediaElement.removeAttribute('src');
			_oMediaElement.load();
		}
	}

	return {
		Запустить, Остановить,
		ПолучитьЗаполненностьБуфера, ПолучитьКоличествоПропущенныхКадров, ПолучитьПозициюВоспроизведенияТрансляции,
		ПоказатьСостояние,
		Перезагрузить: ПерезагрузитьИЖдатьЗаполненияБуфера,
		ПрименитьНастройкиЗвука,
		ДобавитьСледующийСегмент,
		ПеремотатьПовторДо, ПеремотатьПовторНа, ПереключитьПаузу, ЗадатьСкоростьПовтора
	};
})();

const м_Список = (() =>
{
	const ИНТЕРВАЛ_ОБНОВЛЕНИЯ_СПИСКА_ВАРИАНТОВ_НАЧАЛО      = 3000;  // Миллисекунды.
	const ИНТЕРВАЛ_ОБНОВЛЕНИЯ_СПИСКА_ВАРИАНТОВ_КОНЕЦ       = 30000; // Миллисекунды.
	const ИНТЕРВАЛ_ОБНОВЛЕНИЯ_СПИСКА_ВАРИАНТОВ_ШАГ         = 1000;  // Миллисекунды.

	const ДОБАВИТЬ_К_ИНТЕРВАЛУ_ОБНОВЛЕНИЯ_СПИСКА_СЕГМЕНТОВ = 150;   // Миллисекунды. Длительность сегмента может быть чуть больше чем обычно.
	                                                                // Новый сегмент может быть доступен чуть позже чем обычно.
	const КОЛИЧЕСТВО_СЕГМЕНТОВ_ДЛЯ_РАСЧЕТА_ИНТЕРВАЛА       = 10;    // Количество.

	// СОСТОЯНИЕ_НАЧАЛО_ТРАНСЛЯЦИИ - идет трансляция.
	// СОСТОЯНИЕ_ЗАВЕРШЕНИЕ_ТРАНСЛЯЦИИ - трансляция завершена, периодически проверять ее начало.
	// СОСТОЯНИЕ_ОСТАНОВКА - работа полностью остановлена.
	var _чСостояние = СОСТОЯНИЕ_ОСТАНОВКА;
	// СОСТОЯНИЕ_НАЧАЛО_ТРАНСЛЯЦИИ - индекс последнего сегмента в _мчДлительностьСегментов.
	// СОСТОЯНИЕ_ЗАВЕРШЕНИЕ_ТРАНСЛЯЦИИ - интервал обновления списка вариантов.
	var _чИнтервалОбновленияСписка;
	// Кольцевой буфер, в котором хранятся длительности последних сегментов.
	// Используется для расчета интервала обновления списка сегментов.
	var _мчДлительностьСегментов = new Array(КОЛИЧЕСТВО_СЕГМЕНТОВ_ДЛЯ_РАСЧЕТА_ИНТЕРВАЛА);
	var _ооОбновлениеСписков = new ОтменаОбещания();
	// Список отсортирован по убыванию nPeakBitrate. Исходный вариант всегда в начале списка.
	// {
	//   nPeakBitrate
	//   сИдентификатор
	//   сНазвание
	//   сАбсолютныйАдресСпискаСегментов
	//   сКодеки
	// }
	var _моСписокВариантов = null;
	// Индекс _моСписокВариантов.
	var _чВыбранныйВариант;
	// {
	//   nMediaSequenceNumber,
	//   nTargetDuration,
	//   лКонецСписка,
	//   моСегменты:
	//   {
	//     сАдрес,
	//     чДлительность,
	//     лРазрыв
	//   }
	// }
	var _оПоследнийСписок = null;
	// Следующий добавляемый в очередь сегмент должен быть разорван.
	var _лРазрыв;

	function РазобратьСписок(лЭтоСписокВариантов, сАбсолютныйАдресСписка, сРазбираемыйСписок)
	{
		// https://tools.ietf.org/html/draft-pantos-http-live-streaming-19
		const МАКС_ПОДДЕРЖИВАЕМАЯ_ВЕРСИЯ_HLS = 7;

		// Иногда вместе с кодом 200 вместо списка прилетает HTML произвольного содержания. Например
		// 400 Bad Request (nginx) или сообщение об окончании денег на счете интернет-провайдера. :)
		if (!сРазбираемыйСписок.startsWith('#EXTM3U'))
		{
			throw `Вместо списка загружена какая-то фигня длиною ${сРазбираемыйСписок.length}\n${сРазбираемыйСписок}`;
		}

		var чВерсия = 1;
		if (лЭтоСписокВариантов)
		{
			var mapRenditionGroups = new Map(); // Порядок элементов не важен.
			var моСписокВариантов = [];
			var оНовыйВариант = null; // Используется для проверки порядка следования тегов.
		}
		else
		{
			var чДлительностьСписка = 0; // Статистика.
			var nMediaSequenceNumber = 0;
			var чTwitchПрошлоВремени = NaN;
			var nTargetDuration;
			var лКонецСписка;
			var лРазрыв = false;
			var моСегменты = [];
			var оНовыйСегмент = null; // Используется для проверки порядка следования тегов.
		}

		var рвТегИлиАдрес = /^#([A-Z0-9\-]+)(?::(.+))?$|^[^#\r\n].*$/mg;
		// Пропускаем #EXTM3U.
		рвТегИлиАдрес.lastIndex = 7;
		for (var asMatches; asMatches = рвТегИлиАдрес.exec(сРазбираемыйСписок);)
		{
			var сАдрес = asMatches[0], сНазваниеТега = asMatches[1], сЗначениеТега = asMatches[2];

			if (сАдрес.charAt(0) !== '#')
			{
				сАдрес = ResolveRelativeUrl(сАдрес, сАбсолютныйАдресСписка);
				if (лЭтоСписокВариантов)
				{
					Проверить(оНовыйВариант);
					оНовыйВариант.сАбсолютныйАдресСпискаСегментов = сАдрес;
					моСписокВариантов.push(оНовыйВариант);
					оНовыйВариант = null;
				}
				else
				{
					Проверить(оНовыйСегмент);
					Проверить(typeof оНовыйСегмент.чДлительность !== 'undefined');
					Проверить(!лКонецСписка);
					оНовыйСегмент.чTwitchПрошлоВремени = чTwitchПрошлоВремени;
					оНовыйСегмент.лРазрыв = лРазрыв;
					оНовыйСегмент.сАдрес = сАдрес;
					моСегменты.push(оНовыйСегмент);
					чДлительностьСписка  += оНовыйСегмент.чДлительность;
					чTwitchПрошлоВремени += оНовыйСегмент.чДлительность;
					лРазрыв = false;
					оНовыйСегмент = null;
				}
				continue;
			}

			switch (сНазваниеТега)
			{
			//
			// Теги общие для обоих типов списка.
			// #EXT-X-INDEPENDENT-SEGMENTS не используется.
			//
			case 'EXTM3U':
				Проверить(false);
				break;

			case 'EXT-X-VERSION':
				Проверить(чВерсия === 1);
				чВерсия = ParseDecimalInteger(сЗначениеТега);
				Проверить(чВерсия >= 2 && чВерсия <= МАКС_ПОДДЕРЖИВАЕМАЯ_ВЕРСИЯ_HLS);
				break;

			case 'EXT-X-START':
				Проверить(false);
				break;

			//
			// Теги списка вариантов.
			//
			case 'EXT-X-MEDIA':
				Проверить(лЭтоСписокВариантов);
				var амАтрибуты = РазобратьСписокАтрибутов(сЗначениеТега);
				var сТип = амАтрибуты.get('TYPE');
				Проверить(сТип);
				// Видео и звук должны находиться в одном файле.
				Проверить((сТип !== 'VIDEO' && сТип !== 'AUDIO') || !амАтрибуты.has('URI'));
				if (сТип !== 'VIDEO')
				{
					м_Журнал.Ой(`[Список] Найден #EXT-X-MEDIA TYPE=${сТип}`);
				}
				else
				{
					var сГруппа = ParseQuotedString(амАтрибуты.get('GROUP-ID'));
					Проверить(!mapRenditionGroups.has(сГруппа));
					mapRenditionGroups.set(сГруппа, ParseQuotedString(амАтрибуты.get('NAME')));
				}
				break;

			case 'EXT-X-STREAM-INF':
				Проверить(лЭтоСписокВариантов);
				// Пропущен адрес?
				Проверить(!оНовыйВариант);
				оНовыйВариант = Object.create(null);
				var амАтрибуты = РазобратьСписокАтрибутов(сЗначениеТега);
				// Иногда после завершения трансляции BANDWIDTH=0.
				оНовыйВариант.nPeakBitrate = ParseDecimalInteger(амАтрибуты.get('BANDWIDTH'));
				оНовыйВариант.сКодеки = амАтрибуты.has('CODECS') ? ParseQuotedString(амАтрибуты.get('CODECS')) : '';
				Проверить(!амАтрибуты.has('AUDIO') && !амАтрибуты.has('SUBTITLES') && !амАтрибуты.has('CLOSED-CAPTIONS'));
				if (амАтрибуты.has('VIDEO'))
				{
					оНовыйВариант.сИдентификатор = ParseQuotedString(амАтрибуты.get('VIDEO'));
				}
				break;

			case 'EXT-X-I-FRAME-STREAM-INF':
			case 'EXT-X-SESSION-DATA':
			case 'EXT-X-SESSION-KEY':
				Проверить(лЭтоСписокВариантов);
				break;

			//
			// Теги списка сегментов для всех сегментов.
			//
			case 'EXT-X-TARGETDURATION':
				Проверить(!лЭтоСписокВариантов);
				Проверить(nTargetDuration === undefined);
				nTargetDuration = ParseDecimalInteger(сЗначениеТега);
				Проверить(nTargetDuration > 0 && nTargetDuration < 24 * 60 * 60);
				break;

			case 'EXT-X-MEDIA-SEQUENCE':
				Проверить(!лЭтоСписокВариантов);
				Проверить(nMediaSequenceNumber === 0);
				nMediaSequenceNumber = ParseDecimalInteger(сЗначениеТега);
				break;

			case 'EXT-X-ENDLIST':
				Проверить(!лЭтоСписокВариантов);
				Проверить(лКонецСписка === undefined);
				Проверить(сЗначениеТега === undefined);
				лКонецСписка = true;
				м_Журнал.Окак(`[Список] #EXT-X-ENDLIST после сегмента ${nMediaSequenceNumber + моСегменты.length - 1}`);
				break;

			case 'EXT-X-DISCONTINUITY-SEQUENCE':
			case 'EXT-X-DATERANGE':
				Проверить(!лЭтоСписокВариантов);
				break;

			case 'EXT-X-PLAYLIST-TYPE':
			case 'EXT-X-I-FRAMES-ONLY':
				Проверить(false);
				break;

			//
			// Теги списка сегментов для конкретного сегмента.
			//
			case 'EXTINF':
				Проверить(!лЭтоСписокВариантов);
				оНовыйСегмент = оНовыйСегмент || Object.create(null);
				Проверить(typeof оНовыйСегмент.чДлительность === 'undefined');
				оНовыйСегмент.чДлительность = ParseExtinfTag(сЗначениеТега);
				Проверить(оНовыйСегмент.чДлительность !== 0);
				if (оНовыйСегмент.чДлительность - nTargetDuration > 1.0)
				{
					м_Журнал.Ой(`[Список] Длительность сегмента превышена на ${оНовыйСегмент.чДлительность - nTargetDuration}с`);
				}
				break;

			case 'EXT-X-DISCONTINUITY':
				// Twitch: Раньше архивные трансляции завершались странно
				// #EXT-X-DISCONTINUITY
				// #EXT-X-ENDLIST
				Проверить(!лЭтоСписокВариантов);
				Проверить(!лРазрыв);
				Проверить(сЗначениеТега === undefined);
				лРазрыв = true;
				м_Журнал.Ой(`[Список] #EXT-X-DISCONTINUITY у сегмента ${nMediaSequenceNumber + моСегменты.length}`);
				break;

			case 'EXT-X-PROGRAM-DATE-TIME':
				Проверить(!лЭтоСписокВариантов);
				break;

			case 'EXT-X-BYTERANGE':
			case 'EXT-X-KEY':
			case 'EXT-X-MAP':
				Проверить(false);
				break;
		
			//
			// Нестандартные теги Twitch.
			//
			case 'EXT-X-TWITCH-ELAPSED-SECS':
				Проверить(!лЭтоСписокВариантов);
				Проверить(моСегменты.length === 0);
				Проверить(Number.isNaN(чTwitchПрошлоВремени));
				чTwitchПрошлоВремени = ParseFloatingPointOrDecimalInteger(сЗначениеТега);
				break;
			}
		}

		if (лЭтоСписокВариантов)
		{
			// Пропущен адрес?
			Проверить(!оНовыйВариант);

			for (var оВариант of моСписокВариантов)
			{
				if ('сИдентификатор' in оВариант)
				{
					оВариант.сНазвание = mapRenditionGroups.get(оВариант.сИдентификатор);
					Проверить(оВариант.сНазвание);
				}
				else
				{
					// #EXT-X-STREAM-INF без #EXT-X-MEDIA.
					оВариант.сИдентификатор = `CoolCmd${оВариант.nPeakBitrate}`;
					оВариант.сНазвание = `${м_i18n.ФорматироватьЧисло(оВариант.nPeakBitrate / 1000000, 1)} ${Текст('J0114')}`;
				}
				м_Журнал.Окак(`[Список] Добавлен вариант PeakBitrate=${оВариант.nPeakBitrate} Идентификатор=${оВариант.сИдентификатор} Название=${оВариант.сНазвание} Кодеки=${оВариант.сКодеки}`);
			}

			моСписокВариантов.sort(СравнитьВарианты);
			return моСписокВариантов;
		}

		// Пропущен адрес?
		Проверить(!оНовыйСегмент);
		// Пропущен #EXT-X-TARGETDURATION?
		Проверить(nTargetDuration !== undefined);
		м_Журнал.Вот(`[Список] Разобран список сегментов TargetDuration=${nTargetDuration} MediaSequenceNumber=${nMediaSequenceNumber} КоличествоСегментов=${моСегменты.length} ДлительностьСписка=${м_Журнал.F1(чДлительностьСписка)}с`);
		м_Статистика.РазобранСписокСегментов(nTargetDuration, моСегменты.length, чДлительностьСписка);
		return {
			nMediaSequenceNumber,
			nTargetDuration,
			лКонецСписка: !!лКонецСписка,
			моСегменты
		};
	}

	function СравнитьВарианты(оВариант1, оВариант2)
	// Сортирует список по убыванию nPeakBitrate. Исходный вариант всегда в начале списка.
	// HACK Twitch: nPeakBitrate исходного варианта отражает текущее значение, которое может быть намного
	// меньше среднего и максимального. Также при пережатии исходного варианта битрейт может не уменьшиться,
	// а увеличиться. В этих случаях сортировка только по nPeakBitrate переместит исходный вариант
	// в неправильную позицию.
	{
		return (оВариант2.сИдентификатор === 'chunked' ? 1000000000 : оВариант2.nPeakBitrate)
		     - (оВариант1.сИдентификатор === 'chunked' ? 1000000000 : оВариант1.nPeakBitrate);
	}

	function РазобратьСписокАтрибутов(сИсходныйТекст)
	{
		Проверить(сИсходныйТекст);
		var рвАтрибут = /([A-Z0-9\-]+)=("[^"]+"|[^",][^,]*)(?:,|$)/g;
		var амАтрибуты = new Map();
		while (рвАтрибут.lastIndex !== сИсходныйТекст.length)
		{
			var nLastIndex = рвАтрибут.lastIndex;
			var asMatches = рвАтрибут.exec(сИсходныйТекст);
			Проверить(asMatches && asMatches.index === nLastIndex);
			Проверить(!амАтрибуты.has(asMatches[1]));
			амАтрибуты.set(asMatches[1], asMatches[2]);
		}
		return амАтрибуты;
	}

	function ParseDecimalInteger(сИсходныйТекст)
	{
		Проверить(/^[0-9]{1,15}$/.test(сИсходныйТекст));
		return Number.parseInt(сИсходныйТекст, 10);
	}

	function ParseFloatingPointOrDecimalInteger(сИсходныйТекст)
	{
		// Нам нужны минимум 3 цифры после запятой.
		Проверить(/^[0-9]{1,14}(?:\.[0-9]{1,15})?$/.test(сИсходныйТекст));
		return Number.parseFloat(сИсходныйТекст);
	}

	function ParseQuotedString(сИсходныйТекст)
	{
		Проверить(сИсходныйТекст && сИсходныйТекст.length > 2 && сИсходныйТекст.charAt(0) === '"' && сИсходныйТекст.charAt(сИсходныйТекст.length - 1) === '"');
		return сИсходныйТекст.slice(1, -1);
	}

	function ParseDecimalResolution(сИсходныйТекст)
	{
		Проверить(сИсходныйТекст);
		var чРазделитель = сИсходныйТекст.indexOf('x');
		Проверить(чРазделитель !== -1);
		return [ParseDecimalInteger(сИсходныйТекст.slice(0, чРазделитель)), ParseDecimalInteger(сИсходныйТекст.slice(чРазделитель + 1))];
	}

	function ParseExtinfTag(сИсходныйТекст)
	{
		Проверить(сИсходныйТекст);
		// HACK Twitch: Иногда перед завершением трансляции встречается сегмент с отрицательной длительностью:
		// #EXTINF:-0.099,
		// url.ts
		// #EXT-X-ENDLIST
		if (сИсходныйТекст.slice(0, 1) === '-')
		{
			throw 'Отрицательный #EXTINF';
		}
		var чЗапятая = сИсходныйТекст.indexOf(',');
		return ParseFloatingPointOrDecimalInteger(чЗапятая === -1 ? сИсходныйТекст : сИсходныйТекст.slice(0, чЗапятая));
	}

	function ДобавитьСегментыВОчередь(оНовыйСписок)
	// Добавляет в очередь сегменты из оНовыйСписок.
	// Если нужно, добавляет в очередь СОСТОЯНИЕ_НАЧАЛО_ТРАНСЛЯЦИИ.
	// Возвращает количество добавленных в очередь сегментов.
	// Изменяет _чСостояние и _оПоследнийСписок.
	{
		if (_оПоследнийСписок === null)
		{
			// После окончания трансляции список может быть доступен довольно долго.
			if (оНовыйСписок.лКонецСписка)
			{
				throw 'Найден #EXT-X-ENDLIST';
			}

			// Twitch: Возможен пустой список с #EXT-X-ENDLIST и #EXT-X-MEDIA-SEQUENCE: 0.
			Проверить(оНовыйСписок.моСегменты.length !== 0);

			_лРазрыв = true;

			var чРазмерБуфера = м_Настройки.Получить('чРазмерБуфера');
			var чИндекс = Math.max(оНовыйСписок.моСегменты.length - м_Настройки.Получить('кЗаначка') - ЗАСТРЕВАЕТ_СЕГМЕНТОВ_В_РАБОЧЕМ_ПОТОКЕ, 1);
			while (--чИндекс !== 0 && (чРазмерБуфера -= оНовыйСписок.моСегменты[чИндекс].чДлительность) > 0) {}
		}
		else
		{
			Проверить(оНовыйСписок.моСегменты.length !== 0);
			
			// Twitch, ТВЦ: Нам ошибочно прислали старый список.
			if (оНовыйСписок.nMediaSequenceNumber < _оПоследнийСписок.nMediaSequenceNumber
			// Twitch: Количество сегментов в списке ошибочно уменьшено с 15 до 14. #EXT-X-MEDIA-SEQUENCE не изменился. report://02573973289785_15098517906
			||  оНовыйСписок.nMediaSequenceNumber + оНовыйСписок.моСегменты.length < _оПоследнийСписок.nMediaSequenceNumber + _оПоследнийСписок.моСегменты.length)
			{
				м_Журнал.Ой(`[Список] Уменьшился media sequence number [${_оПоследнийСписок.nMediaSequenceNumber}..${_оПоследнийСписок.nMediaSequenceNumber + _оПоследнийСписок.моСегменты.length - 1}] ==> [${оНовыйСписок.nMediaSequenceNumber}..${оНовыйСписок.nMediaSequenceNumber + оНовыйСписок.моСегменты.length - 1}]`);
			}
			
			// Firefox 43: Из-за нехватки памяти в системе, загрузка списка может задержаться на несколько десятков секунд.
			const чПропущеноСегментов = оНовыйСписок.nMediaSequenceNumber - (_оПоследнийСписок.nMediaSequenceNumber + _оПоследнийСписок.моСегменты.length);
			if (чПропущеноСегментов > 0)
			{
				м_Журнал.Ой(`[Список] Пропущено сегментов: ${чПропущеноСегментов}`);
				м_Статистика.НеЗагруженыСегменты(чПропущеноСегментов);
				_лРазрыв = true;
			}

			if (оНовыйСписок.nTargetDuration !== _оПоследнийСписок.nTargetDuration)
			{
				м_Журнал.Ой(`[Список] Изменился target duration ${_оПоследнийСписок.nTargetDuration} ==> ${оНовыйСписок.nTargetDuration}`);
				СброситьИнтервалОбновленияСписков();
			}

			var чИндекс = 0;
		}

		var кСегментовДобавлено = 0;
		var кСекундДобавлено = 0; // Статистика.
		for (var оСегмент; оСегмент = оНовыйСписок.моСегменты[чИндекс]; ++чИндекс)
		{
			const nMediaSequenceNumber = оНовыйСписок.nMediaSequenceNumber + чИндекс;

			if (_оПоследнийСписок !== null
			&& nMediaSequenceNumber >= _оПоследнийСписок.nMediaSequenceNumber
			&& nMediaSequenceNumber <  _оПоследнийСписок.nMediaSequenceNumber + _оПоследнийСписок.моСегменты.length)
			{
				const оПоследнийСегмент = _оПоследнийСписок.моСегменты[nMediaSequenceNumber - _оПоследнийСписок.nMediaSequenceNumber];
				// Twitch: EXT-X-MEDIA-SEQUENCE ошибочно на 1 меньше после начала трансляции.
				if (оПоследнийСегмент.сАдрес !== оСегмент.сАдрес || оПоследнийСегмент.чДлительность !== оСегмент.чДлительность)
				{
					м_Журнал.Ой(`[Список] У сегмента ${nMediaSequenceNumber} изменились адрес ${оПоследнийСегмент.сАдрес} ==> ${оСегмент.сАдрес} или длительность ${оПоследнийСегмент.чДлительность} ==> ${оСегмент.чДлительность}`);
					_лРазрыв = true;
				}
			}

			if (_оПоследнийСписок === null
			|| nMediaSequenceNumber >= _оПоследнийСписок.nMediaSequenceNumber + _оПоследнийСписок.моСегменты.length)
			{
				if (_чСостояние !== СОСТОЯНИЕ_НАЧАЛО_ТРАНСЛЯЦИИ)
				{
					_чСостояние = СОСТОЯНИЕ_НАЧАЛО_ТРАНСЛЯЦИИ;
					г_моОчередь.Добавить(new Сегмент(ОБРАБОТКА_ЗАГРУЖЕН, СОСТОЯНИЕ_НАЧАЛО_ТРАНСЛЯЦИИ));
					СброситьИнтервалОбновленияСписков();
				}

				const оДобавлено = г_моОчередь.Добавить(new Сегмент(ОБРАБОТКА_ЖДЕТ_ЗАГРУЗКИ, оСегмент.сАдрес, оСегмент.чДлительность, оСегмент.лРазрыв || _лРазрыв, оСегмент.чTwitchПрошлоВремени));
				м_Журнал.Вот(`[Список] Добавлен сегмент ${оДобавлено.чНомер} MediaSequenceNumber=${nMediaSequenceNumber} Длительность=${оДобавлено.чДлительность} Разрыв=${оДобавлено.лРазрыв} TwitchПрошлоВремени=${оДобавлено.чTwitchПрошлоВремени}`);

				_лРазрыв = false;
				кСегментовДобавлено += 1;
				кСекундДобавлено += оДобавлено.чДлительность;
			}
		}

		м_Статистика.ДобавленыСегментыВОчередь(кСегментовДобавлено, кСекундДобавлено);

		if (_оПоследнийСписок === null
		|| оНовыйСписок.nMediaSequenceNumber + оНовыйСписок.моСегменты.length >= _оПоследнийСписок.nMediaSequenceNumber + _оПоследнийСписок.моСегменты.length)
		{
			_оПоследнийСписок = оНовыйСписок;
		}

		if (оНовыйСписок.лКонецСписка)
		{
			throw 'Найден #EXT-X-ENDLIST';
		}

		return кСегментовДобавлено;
	}

	function ОбновитьСписки(чЧерез)
	{
		Проверить(Number.isFinite(чЧерез) && чЧерез >= 0);
		м_Журнал.Вот(`[Список] Загрузка списка начнется через ${м_Журнал.F0(чЧерез)}мс`);
		var оОбещание = Ждать(_ооОбновлениеСписков, чЧерез);
		if (!_моСписокВариантов)
		{
			var сАбсолютныйАдресСпискаВариантов;
			оОбещание = оОбещание.then(() =>
			{
				return м_Twitch.ПолучитьАбсолютныйАдресСпискаВариантов(_ооОбновлениеСписков);
			})
			.then(сРезультат =>
			{
				сАбсолютныйАдресСпискаВариантов = сРезультат;
				return м_Загрузчик.ЗагрузитьТекст(_ооОбновлениеСписков, сАбсолютныйАдресСпискаВариантов,
					ЗАГРУЖАТЬ_СПИСОК_ВАРИАНТОВ_НЕ_ДОЛЬШЕ, 'список вариантов', false);
			})
			.then(сРезультат =>
			{
				м_Отладка.СохранитьСписокВариантов(сРезультат);
				_моСписокВариантов = РазобратьСписок(true, сАбсолютныйАдресСпискаВариантов, сРезультат);
				ВыбратьВариантТрансляции();
			});
		}
		var чНачалоОпроса;
		оОбещание.then(() =>
		{
			чНачалоОпроса = performance.now();
			return м_Загрузчик.ЗагрузитьТекст(_ооОбновлениеСписков,
				_моСписокВариантов[_чВыбранныйВариант].сАбсолютныйАдресСпискаСегментов,
				ЗАГРУЖАТЬ_СПИСОК_СЕГМЕНТОВ_НЕ_ДОЛЬШЕ, 'список сегментов', false);
		})
		.then(сРезультат =>
		{
			м_Отладка.СохранитьСписокСегментов(сРезультат);
			var чИнтервал = ПолучитьИнтервалОбновленияСпискаСегментов( ДобавитьСегментыВОчередь( РазобратьСписок(
				false, _моСписокВариантов[_чВыбранныйВариант].сАбсолютныйАдресСпискаСегментов, сРезультат)));
			ОбновитьСписки(Math.max(чИнтервал - performance.now() + чНачалоОпроса, 0));
			м_Загрузчик.ЗагрузитьСледующийСегмент();
		})
		.catch(ДобавитьОбработчикИсключений(пПричина =>
		{
			// Завершение трансляции?
			if (typeof пПричина === 'string')
			{
				м_Журнал.Ой(`[Список] Завершаю трансляцию. ${пПричина}`);
				ЗавершитьТрансляцию();
				ОбновитьСписки(ПолучитьИнтервалОбновленияСпискаВариантов());
				м_Загрузчик.ЗагрузитьСледующийСегмент();
			}
			// Выполнение этой цепочки обещаний было прервано вызовом _ооОбновлениеСписков.Отменить()?
			// В этот момент уже может работать другая цепочка обещаний.
			else if (пПричина === ОтменаОбещания.ОБЕЩАНИЕ_ОТМЕНЕНО)
			{
				м_Журнал.Вот('[Список] Отменено обновление списков');
			}
			// Проверить() или незапланированное исключение.
			else
			{
				м_Отладка.ПойманоИсключение(пПричина);
			}
		}));
	}

	function ОтменитьОбновлениеСписков()
	{
		м_Журнал.Вот('[Список] Отменяю обновление списков');
		_ооОбновлениеСписков.Отменить();
	}

	function СброситьИнтервалОбновленияСписков()
	{
		_мчДлительностьСегментов.fill(0);
		_чИнтервалОбновленияСписка = -1;
	}

	function ПолучитьИнтервалОбновленияСпискаСегментов(кСегментовДобавлено)
	{
		Проверить(_чСостояние === СОСТОЯНИЕ_НАЧАЛО_ТРАНСЛЯЦИИ);

		const чМинИнтервал = МИН_ИНТЕРВАЛ_ОБНОВЛЕНИЯ_СПИСКОВ * _оПоследнийСписок.nTargetDuration * 10;
		if (кСегментовДобавлено === 0)
		{
			return чМинИнтервал;
		}

		var чИнтервал = м_Настройки.Получить('чИнтервалОпроса');
		if (чИнтервал !== АВТОНАСТРОЙКА)
		{
			return чИнтервал * _оПоследнийСписок.nTargetDuration * 10;
		}

		Проверить(кСегментовДобавлено > 0 && кСегментовДобавлено <= _оПоследнийСписок.моСегменты.length);
		if (_чИнтервалОбновленияСписка === -1)
		{
			_чИнтервалОбновленияСписка = 0;
			// Ради этой строки _мчДлительностьСегментов[] заполняется без помощи ДобавитьСегментыВОчередь().
			кСегментовДобавлено = _оПоследнийСписок.моСегменты.length;
		}
		кСегментовДобавлено = Math.min(кСегментовДобавлено, _мчДлительностьСегментов.length);
		do
		{
			_мчДлительностьСегментов[_чИнтервалОбновленияСписка] = _оПоследнийСписок.моСегменты[_оПоследнийСписок.моСегменты.length - кСегментовДобавлено].чДлительность;
			if (++_чИнтервалОбновленияСписка === _мчДлительностьСегментов.length)
			{
				_чИнтервалОбновленияСписка = 0;
			}
		}
		while (--кСегментовДобавлено !== 0);
		чИнтервал = Math.max.apply(null, _мчДлительностьСегментов);
		Проверить(чИнтервал > 0);
		return Math.max(чИнтервал * 1000 + ДОБАВИТЬ_К_ИНТЕРВАЛУ_ОБНОВЛЕНИЯ_СПИСКА_СЕГМЕНТОВ, чМинИнтервал);
	}

	function ПолучитьИнтервалОбновленияСпискаВариантов()
	{
		Проверить(_чСостояние === СОСТОЯНИЕ_ЗАВЕРШЕНИЕ_ТРАНСЛЯЦИИ);
		if (_чИнтервалОбновленияСписка === -1)
		{
			_чИнтервалОбновленияСписка = ИНТЕРВАЛ_ОБНОВЛЕНИЯ_СПИСКА_ВАРИАНТОВ_НАЧАЛО;
		}
		else
		{
			_чИнтервалОбновленияСписка = Math.min(_чИнтервалОбновленияСписка + ИНТЕРВАЛ_ОБНОВЛЕНИЯ_СПИСКА_ВАРИАНТОВ_ШАГ, ИНТЕРВАЛ_ОБНОВЛЕНИЯ_СПИСКА_ВАРИАНТОВ_КОНЕЦ);
		}
		return _чИнтервалОбновленияСписка;
	}

	function ВыбратьВариантТрансляции()
	// Изменяет _чВыбранныйВариант.
	{
		if (_моСписокВариантов.length === 0)
		{
			throw 'Список вариантов пуст';
		}
		// Если сЖелаемыйВариант не будет найден в списке, то возьмем вариант с максимальным качеством из начала списка.
		var сЖелаемыйВариант = м_Настройки.Получить('сНазваниеВарианта');
		_чВыбранныйВариант = _моСписокВариантов.length - 1;
		while (_чВыбранныйВариант !== 0 && _моСписокВариантов[_чВыбранныйВариант].сИдентификатор !== сЖелаемыйВариант)
		{
			--_чВыбранныйВариант
		}
		м_Журнал.Вот(`[Список] Выбран вариант трансляции ${_моСписокВариантов[_чВыбранныйВариант].сИдентификатор} ЖелаемыйВариант=${сЖелаемыйВариант}`);
		м_События.ОбработатьСобытие('список-выбранварианттрансляции', [_моСписокВариантов, _чВыбранныйВариант]);
	}

	function ОчиститьСписокВариантовТрансляции()
	// Изменяет _моСписокВариантов.
	{
		if (_моСписокВариантов)
		{
			м_Журнал.Вот('[Список] Очищаю список вариантов трансляции');
			_моСписокВариантов = null;
			м_События.ОбработатьСобытие('список-выбранварианттрансляции', [_моСписокВариантов, _чВыбранныйВариант]);
		}
	}

	function ЗавершитьТрансляцию()
	// Если нужно, добавляет в очередь СОСТОЯНИЕ_ЗАВЕРШЕНИЕ_ТРАНСЛЯЦИИ.
	{
		// Если СОСТОЯНИЕ_ОСТАНОВКА, то сменить СОСТОЯНИЕ_ЗАГРУЗКА на СОСТОЯНИЕ_ЗАВЕРШЕНИЕ_ТРАНСЛЯЦИИ.
		if (_чСостояние !== СОСТОЯНИЕ_ЗАВЕРШЕНИЕ_ТРАНСЛЯЦИИ)
		{
			_чСостояние = СОСТОЯНИЕ_ЗАВЕРШЕНИЕ_ТРАНСЛЯЦИИ;
			г_моОчередь.Добавить(new Сегмент(ОБРАБОТКА_ЗАГРУЖЕН, СОСТОЯНИЕ_ЗАВЕРШЕНИЕ_ТРАНСЛЯЦИИ));
			СброситьИнтервалОбновленияСписков();
		}
		ОчиститьСписокВариантовТрансляции();
		_оПоследнийСписок = null;
	}

	function ИзменитьВариантТрансляции()
	// Не добавляет в очередь СОСТОЯНИЕ_ЗАВЕРШЕНИЕ_ТРАНСЛЯЦИИ.
	{
		// _чСостояние может быть любым, например если список вариантов уже загружен, а список сегментов - нет.
		Проверить(_моСписокВариантов);
		ОтменитьОбновлениеСписков();
		СброситьИнтервалОбновленияСписков();
		ВыбратьВариантТрансляции();
		_оПоследнийСписок = null;
		_ооОбновлениеСписков.НачалоВыполнения();
		ОбновитьСписки(0);
	}


	function Остановить()
	// Не изменяет очередь.
	{
		_чСостояние = СОСТОЯНИЕ_ОСТАНОВКА;
		ОтменитьОбновлениеСписков();
		ОчиститьСписокВариантовТрансляции();
		_оПоследнийСписок = null;
	}

	function Запустить()
	{
		Проверить(_чСостояние === СОСТОЯНИЕ_ОСТАНОВКА);
		_ооОбновлениеСписков.НачалоВыполнения();
		ОбновитьСписки(0);
	}

	СброситьИнтервалОбновленияСписков();

	return {
		Запустить, Остановить,
		ИзменитьВариантТрансляции
	};
})();

const м_Преобразователь = (() =>
{
	var _оРабочийПоток = null;
	var _чПоследнийЗагруженный = -1;

	function ПреобразоватьСледующийСегмент()
	// СОСТОЯНИЕ_НАЧАЛО_ТРАНСЛЯЦИИ:
	//   Создает рабочий поток пока сегменты закачиваются.
	//   Отсылается в рабочий поток чтобы не изменилась его позиция в очереди.
	// СОСТОЯНИЕ_ЗАВЕРШЕНИЕ_ТРАНСЛЯЦИИ:
	//   Выталкивает из рабочего потока застрявшие там сегменты.
	//   TODO Когда все сегменты будут вытолкнуты, убить рабочий поток.
	{
		var кУдалить = 0, чУдалить;
		// Нельзя преобразовывать сегменты в произвольном порядке.
		for (var чСегмент = 0, оСегмент; оСегмент = г_моОчередь[чСегмент]; ++чСегмент)
		{
			if (оСегмент.чОбработка > ОБРАБОТКА_ЗАГРУЖЕН)
			{
				continue;
			}
			if (оСегмент.чОбработка < ОБРАБОТКА_ЗАГРУЖЕН)
			{
				break;
			}


			if (_чПоследнийЗагруженный !== -1 && _чПоследнийЗагруженный + 1 !== оСегмент.чНомер)
			{
				м_Журнал.Ой(`[Преобразование] Не загружены сегменты между ${_чПоследнийЗагруженный} и ${оСегмент.чНомер}`);
				оСегмент.лРазрыв = true;
			}
			_чПоследнийЗагруженный = оСегмент.чНомер;

			if (typeof оСегмент.пДанные === 'number' && _оРабочийПоток === null)
			{
				м_Журнал.Вот(`[Преобразование] Пропускаю сегмент ${оСегмент.чНомер} Состояние=${оСегмент.пДанные}`);
				оСегмент.чОбработка = ОБРАБОТКА_ПРЕОБРАЗОВАН;
				// Создать заранее пока загружаются сегменты.
				if (оСегмент.пДанные === СОСТОЯНИЕ_НАЧАЛО_ТРАНСЛЯЦИИ)
				{
					СоздатьРабочийПоток();
				}
				continue;
			}

			if (typeof оСегмент.пДанные !== 'number')
			{
				м_Отладка.СохранитьТранспортныйПоток(оСегмент);
				м_Статистика.ОтосланИсходныйСегмент();
			}

			// При смене варианта трансляции СОСТОЯНИЕ_НАЧАЛО_ТРАНСЛЯЦИИ не добавляется.
			СоздатьРабочийПоток();

			м_Журнал.Вот(`[Преобразование] Отсылаю сегмент ${оСегмент.чНомер}`);
			оСегмент.сВерсия = ВЕРСИЯ_РАСШИРЕНИЯ;
			оСегмент.чОбработка = ЗАСТРЕВАЕТ_СЕГМЕНТОВ_В_РАБОЧЕМ_ПОТОКЕ;
			_оРабочийПоток.postMessage(оСегмент, typeof оСегмент.пДанные === 'number' ? undefined : [оСегмент.пДанные]);

			if (++кУдалить === 1)
			{
				чУдалить = чСегмент;
			}
		}
		if (кУдалить !== 0)
		{
			г_моОчередь.Удалить(чУдалить, кУдалить);
		}
		м_Проигрыватель.ДобавитьСледующийСегмент();
	}

	function ОбработатьОшибкуПреобразования(оСобытие)
	{
		м_Отладка.ЗавершитьРаботуИОтправитьОтчет(`Произошла ошибка в рабочем потоке в строке ${оСобытие.lineno}. ${оСобытие.message}`);
	}

	const ОбработатьОкончаниеПреобразования = ДобавитьОбработчикИсключений(оСобытие =>
	{
		var мДанные = оСобытие.data;
		Проверить(Array.isArray(мДанные));
		switch (мДанные[0])
		{
		case 1:
			Проверить(мДанные.length === 2 && ЭтоОбъект(мДанные[1]));
			var оСегмент = new Сегмент(ОБРАБОТКА_ПРЕОБРАЗОВАН, мДанные[1].пДанные, мДанные[1].чДлительность, мДанные[1].лРазрыв, мДанные[1].чTwitchПрошлоВремени, мДанные[1].чНомер);
			м_Журнал.Вот(`[Преобразование] Получен сегмент ${оСегмент.чНомер} ПреобразованЗа=${м_Журнал.F0(оСегмент.пДанные.чПреобразованЗа)}мс`);
			if (typeof оСегмент.пДанные !== 'number')
			{
				м_Статистика.ПолученПреобразованныйСегмент(оСегмент);
				// Если исходный сегмент не был преобразован или преобразованный медиасегмент был
				// задержан в рабочем потоке, то приходит только статистика без медиасегмента.
				if (typeof оСегмент.пДанные.мбМедиасегмент === 'undefined')
				{
					return;
				}
				м_Отладка.СохранитьПреобразованныйСегмент(оСегмент);
			}
			г_моОчередь.Добавить(оСегмент);
			м_Проигрыватель.ДобавитьСледующийСегмент();
			return;

		case 2:
			var мсВажность = мДанные[1], мсЗаписи = мДанные[2];
			Проверить(мДанные.length === 3 && Array.isArray(мсВажность) && Array.isArray(мсЗаписи) && мсВажность.length === мсЗаписи.length);
			for (var ы = 0; ы < мсВажность.length; ++ы)
			{
				Проверить((мсВажность[ы] === 'Вот' || мсВажность[ы] === 'Окак' || мсВажность[ы] === 'Ой') && typeof мсЗаписи[ы] === 'string');
				м_Журнал[мсВажность[ы]](мсЗаписи[ы]);
			}
			return;

		case 3:
			Проверить(мДанные.length === 3 && typeof мДанные[1] === 'string' && typeof мДанные[2] === 'object');
			м_Отладка.ЗавершитьРаботуИОтправитьОтчет(мДанные[1], мДанные[2]);
			return;

		case 4:
			Проверить(мДанные.length === 2 && typeof мДанные[1] === 'string');
			м_Отладка.ЗавершитьРаботуИПоказатьСообщение(мДанные[1]);
			return;

		case 5:
			Проверить(мДанные.length === 2 && мДанные[1].byteLength);
			м_Помойка.Выбросить(мДанные[1]);
			return;

		default:
			Проверить(false);
		}
	});

	function СоздатьРабочийПоток()
	// Версии player.js и worker.js должны совпадать. Во время обновления расширения этим занимается браузер.
	{
		if (!_оРабочийПоток)
		{
			м_Журнал.Вот('[Преобразование] Создаю рабочий поток');
			_оРабочийПоток = new Worker(chrome.extension.getURL('worker_pre.js'));
			_оРабочийПоток.addEventListener('error', ОбработатьОшибкуПреобразования);
			_оРабочийПоток.addEventListener('message', ОбработатьОкончаниеПреобразования);
		}
	}

	function Остановить()
	// Не изменяет очередь.
	{
		_чПоследнийЗагруженный = -1;
		if (_оРабочийПоток)
		{
			м_Журнал.Вот('[Преобразование] Убиваю рабочий поток');
			_оРабочийПоток.terminate();
			_оРабочийПоток = null;
		}
	}

	return {
		Остановить,
		ПреобразоватьСледующийСегмент
	};
})();

const м_Загрузчик = (() =>
{
	function ЗагрузитьТекст(ооОтменаОбещания, сАдрес, чНеДольше, сНазвание, лЖурнал, оЗаголовки /* необязательный */, сМетод /* необязательный */)
	{
		return Загрузить(ооОтменаОбещания, сМетод === undefined ? 'GET' : сМетод, сАдрес, чНеДольше, сНазвание, лЖурнал, оЗаголовки, false, false);
	}

	function Загрузить(ооОтменаОбещания, сМетод, сАдрес, чНеДольше, сНазвание, лЖурнал, оЗаголовки, лДвоичныеДанные, лНужнаСтатистика)
	// BUG Firefox 46, Chrome 48, Edge 15 (выход из спячки): Иногда запрос не завершается, не посылая никаких событий.
	{
		Проверить(сМетод === 'GET' || сМетод === 'PUT' || сМетод === 'DELETE');
		Проверить(typeof сАдрес === 'string' && (сАдрес.startsWith('http://') || сАдрес.startsWith('https://') || (чНеДольше === 0 && сАдрес.startsWith(chrome.extension.getURL('')))));
		Проверить(!лДвоичныеДанные || !лЖурнал);
		Проверить(Number.isFinite(чНеДольше) && (чНеДольше === 0 || чНеДольше > 500));
		чНеДольше = Math.round(чНеДольше);
		м_Журнал.Вот(`[Загрузчик] ${сМетод} ${сНазвание} не дольше ${чНеДольше}мс`);
		return new Promise((фВыполнить, фОтказаться) =>
		{
			const оЗапрос = new XMLHttpRequest();
			оЗапрос.addEventListener('timeout', ОбработатьОшибку);
			оЗапрос.addEventListener('error', ОбработатьОшибку);
			оЗапрос.addEventListener('abort', ОбработатьОшибку);
			оЗапрос.addEventListener('load', ОбработатьLoad);
			if (лНужнаСтатистика)
			{
				оЗапрос.addEventListener('progress', function ОбработатьProgress()
				// За время загрузки одного сегмента обработчик readystatechange вызывается несколько сотен раз.
				// Обработчик progress вызывается примерно каждые 50 мс.
				// TODO Firefox 42: Первое событие progress прилетает примерно через 50 мс после получения заголовков.
				// Edge 15: Последнее событие progress может прилететь по окончании загрузки ПРЕДпоследнего блока.
				{
					try
					{
						Проверить(Number.isNaN(чВремяПолученияОтвета));
						чВремяПолученияОтвета = performance.now();
						оЗапрос.removeEventListener('progress', ОбработатьProgress);
					}
					catch (пИсключение)
					{
						м_Отладка.ПойманоИсключение(пИсключение);
					}
				});
			}
			if (ооОтменаОбещания)
			{
				ооОтменаОбещания.ЗаменитьОбработчик(() =>
				{
					оЗапрос.removeEventListener('abort', ОбработатьОшибку);
					// Синхронно вызывает обработчик события abort.
					оЗапрос.abort();
					фОтказаться(ОтменаОбещания.ОБЕЩАНИЕ_ОТМЕНЕНО);
				});
			}
			оЗапрос.open(сМетод, сАдрес);
			if (оЗаголовки)
			{
				for (var сЗаголовок of Object.keys(оЗаголовки))
				{
					оЗапрос.setRequestHeader(сЗаголовок, оЗаголовки[сЗаголовок]);
				}
			}
			оЗапрос.responseType = лДвоичныеДанные ? 'arraybuffer' : 'text';
			оЗапрос.timeout = чНеДольше;
			// Если вечером изменять параметры подписки, то 503 возвращается на удивление часто. Согласно документации Twitch,
			// при получении кода 503 нужно повторить запрос 1 раз. Повтор не помешает и в других случаях.
			// TODO Повторять запрос сегментов прямой трансляции? Пока ПовторитьЗапрос() не содержит кода сбора статистики.
			var лПовторитьЗапрос = !лДвоичныеДанные;
			Проверить(!лПовторитьЗапрос || !лНужнаСтатистика);
			const чВремяОтправкиЗапроса = performance.now();
			var чВремяПолученияОтвета = NaN;
			оЗапрос.send();

			function ПовторитьЗапрос()
			{
				if (!лПовторитьЗапрос)
				{
					return false;
				}
				м_Журнал.Ой(`[Загрузчик] Повторно загружаю ${сНазвание}`);
				оЗапрос.open(сМетод, сАдрес);
				if (оЗаголовки)
				{
					for (var сЗаголовок of Object.keys(оЗаголовки))
					{
						оЗапрос.setRequestHeader(сЗаголовок, оЗаголовки[сЗаголовок]);
					}
				}
				лПовторитьЗапрос = false;
				оЗапрос.send();
				return true;
			}


			function ОбработатьОшибку(оСобытие)
			{
				try
				{
					if (г_лРаботаЗавершена)
					{
						return;
					}
					м_Журнал.Ой(`[Загрузчик] Не удалось загрузить ${сНазвание}. Произошло событие ${оСобытие.type}`);
					// Chrome 49: Вызывает abort() во время выгрузки страницы, засыпания компа и еще по каким-то неведомым мне причинам.
					// Firefox: Раньше сам вызывал abort(). Возможно, продолжит это в будущем, беря пример с Chrome.
					// После abort() нет смысла повторять запрос.
					if ((оСобытие.type !== 'timeout' && оСобытие.type !== 'error') || !ПовторитьЗапрос())
					{
						фОтказаться(`Произошло событие ${оСобытие.type}`);
					}
				}
				catch (пИсключение)
				{
					м_Отладка.ПойманоИсключение(пИсключение);
				}
			}

			function ОбработатьLoad()
			{
				try
				{
					if (г_лРаботаЗавершена)
					{
						return;
					}
					Проверить(оЗапрос.readyState === XMLHttpRequest.DONE);
					const чКод = оЗапрос.status;
					// report://03794749782803_15084697088
					if (чКод >= 200 && чКод <= 299 && оЗапрос.response !== null)
					{
						Проверить((лДвоичныеДанные && ЭтоОбъект(оЗапрос.response)) || (!лДвоичныеДанные && typeof оЗапрос.response === 'string'));

						const чДлительностьЗагрузки = Math.round(performance.now() - чВремяОтправкиЗапроса);
						const чОжиданиеОтвета = Math.round(чВремяПолученияОтвета - чВремяОтправкиЗапроса);

						м_Журнал[чКод === 200 ? 'Вот' : 'Ой'](
							`[Загрузчик] Загрузил ${сНазвание} за ${чДлительностьЗагрузки}мс`
							+ (лНужнаСтатистика ? ` ОжиданиеОтвета=${чОжиданиеОтвета}мс` : ``)
							+ (чКод === 200 ? `` : ` Код=${чКод} ${оЗапрос.statusText}`)
							+ (лЖурнал && оЗапрос.response.length ? `\n${оЗапрос.response}` : ` Размер=${лДвоичныеДанные ? оЗапрос.response.byteLength : оЗапрос.response.length}`)
						);

						// Файл загружен не с диска?
						if (чНеДольше !== 0)
						{
							м_Статистика.СкачаноНечто(ПолучитьРазмерОтвета(оЗапрос));
						}

						if (лДвоичныеДанные)
						{
							фВыполнить(
							{
								буфДанные: оЗапрос.response,
								чДлительностьЗагрузки,
								чОжиданиеОтвета
							});
						}
						else
						{
							Проверить(!лНужнаСтатистика);
							фВыполнить(оЗапрос.response);
						}
					}
					else
					{
						м_Журнал.Ой(`[Загрузчик] Не удалось загрузить ${сНазвание}. Сервер вернул код ${чКод} ${оЗапрос.statusText}`
							+ (лДвоичныеДанные && ЭтоОбъект(оЗапрос.response) ? ` Размер=${оЗапрос.response.byteLength}` : `\n${оЗапрос.response}`)
						);
						// Встречается код 302, видимо без заголовка запроса location. report://02880986452199_15106536708
						if ((чКод >= 400 && чКод <= 499) || оЗапрос.response === null || !ПовторитьЗапрос())
						{
							фОтказаться(КОД_ОТВЕТА + чКод);
						}
					}
				}
				catch (пИсключение)
				{
					м_Отладка.ПойманоИсключение(пИсключение);
				}
			}
		});
	}

	function ПолучитьРазмерОтвета(оЗапрос)
	// TODO Twitch: Часть запросов к API может кэшироваться.
	{
		var кбРазмерЗаголовков = 17 + оЗапрос.statusText.length + оЗапрос.getAllResponseHeaders().length;
		// HTTP/2 сжимает заголовки. Итоговый размер равен ≈ 0,2..0,7 и зависит от
		// содержимого заголовков и количества запросов в соединении.
		if (ЭтоHTTP2(оЗапрос))
		{
			кбРазмерЗаголовков = Math.round(кбРазмерЗаголовков * 0.5);
		}
		
		var кбРазмерТела;
		// Нам нужен размер сжатых данных. Событие progress дает размер разжатых данных.
		// Content-Length отсутствует если используется Transfer-Encoding: chunked.
		// Content-Length не обязателен для протокола HTTP/2.
		var сЗаголовок = оЗапрос.getResponseHeader('Content-Length');
		if (сЗаголовок)
		{
			кбРазмерТела = Number.parseInt(сЗаголовок, 10);
		}
		else if (оЗапрос.responseType !== 'text')
		{
			кбРазмерТела = оЗапрос.response.byteLength;
			// TODO Расширение пока не скачивает сжатые двоичные файлы.
		}
		else
		{
			// TODO Размер в байтах исходного текста в кодировке UTF-8 может быть больше.
			// Twitch: Таких файлов очень мало.
			кбРазмерТела = оЗапрос.response.length;
			сЗаголовок = оЗапрос.getResponseHeader('Content-Encoding');
			if (сЗаголовок && сЗаголовок !== 'identity')
			{
				кбРазмерТела = Math.round(кбРазмерТела * 0.35);
			}
		}
		
		return кбРазмерЗаголовков + кбРазмерТела;
	}

	function ЭтоHTTP2(оЗапрос)
	// HACK Нет стандартного способа для определения версии протокола HTTP.
	{
		return оЗапрос.statusText.length === 0;
	}

	function ЗагрузитьСледующийСегмент()
	// Начинает загрузку незагруженных сегментов и отправляет на преобразование загруженные.
	// Сегменты могут загружаться в произвольном порядке, преобразовываться - только по порядку.
	{
		var чЗаначка = г_моОчередь.length;
		for (var ы = м_Настройки.Получить('кЗаначка'); ы !== 0; --ы)
		{
			if (чЗаначка === 0 || г_моОчередь[чЗаначка - 1].чОбработка !== ОБРАБОТКА_ЖДЕТ_ЗАГРУЗКИ)
			{
				break;
			}
			--чЗаначка;
		}
	
		var кОдновременныхЗагрузок = м_Настройки.Получить('кОдновременныхЗагрузок');
		var чДлительностьВсехЗагрузок = 0;
		for (var ы = 0; ы < чЗаначка; ++ы)
		{
			// Загруженные сегменты могут застрять в очереди если из-за ошибки браузера завис XHR
			// и в настройках проигрывателя включена одновременная загрузка нескольких сегментов.
			if (г_моОчередь[ы].чОбработка <= ОБРАБОТКА_ЗАГРУЖЕН)
			{
				чДлительностьВсехЗагрузок += г_моОчередь[ы].чДлительность;
				if (г_моОчередь[ы].чОбработка <= ОБРАБОТКА_ЗАГРУЖАЕТСЯ)
				{
					--кОдновременныхЗагрузок;
					if (г_моОчередь[ы].чОбработка === ОБРАБОТКА_ЖДЕТ_ЗАГРУЗКИ && кОдновременныхЗагрузок >= 0)
					{
						ЗагрузитьСегмент(г_моОчередь[ы]);
					}
				}
			}
		}

		// TODO Можно заменить ПЕРЕПОЛНЕНИЕ_БУФЕРА на:
		// а) Текущий размер буфера + МАКС_РАСТЯГИВАНИЕ_БУФЕРА
		// б) Длительность списка воспроизведения * 2
		// Значение должно быть заметно больше, чем чЗагружатьНеДольше в ЗагрузитьСегмент(), чтобы не путать ошибку загрузки с переполнением очереди.
		if (чДлительностьВсехЗагрузок >= ПЕРЕПОЛНЕНИЕ_БУФЕРА)
		{
			м_Журнал.Ой(`[Загрузчик] Длительность всех загрузок в очереди ${м_Журнал.F1(чДлительностьВсехЗагрузок)}с >= ${ПЕРЕПОЛНЕНИЕ_БУФЕРА}с`);
			ОбработатьНеудачнуюЗагрузкуСегмента(null);
			ЗагрузитьСледующийСегмент();
			return;
		}

		м_Преобразователь.ПреобразоватьСледующийСегмент();
	}

	function ЗагрузитьСегмент(оСегмент)
	{
		const чЗагружатьНеДольше = 5000                                               // Ожидание ответа.
			+ оСегмент.чДлительность * м_Настройки.Получить('кОдновременныхЗагрузок') // Если толщина сегмента и толщина канала совпадают.
			* 2                                                                       // Проблемы со связью.
			* 1000;                                                                   // Перевод в миллисекунды.
		// См. проверку на переполнение очереди в ЗагрузитьСледующийСегмент().
		Проверить(чЗагружатьНеДольше < ПЕРЕПОЛНЕНИЕ_БУФЕРА * 1000);
		const сАдрес = оСегмент.пДанные;
		оСегмент.пДанные = new ОтменаОбещания();
		оСегмент.пДанные.НачалоВыполнения();
		оСегмент.чОбработка = ОБРАБОТКА_ЗАГРУЖАЕТСЯ;
		Загрузить(оСегмент.пДанные, 'GET', сАдрес, чЗагружатьНеДольше, `сегмент ${оСегмент.чНомер}`, false, null, true, м_Статистика.ОкноПоказано())
		.then(оРезультат =>
		{
			Проверить(г_моОчередь.includes(оСегмент));
			оСегмент.пДанные = оРезультат.буфДанные;
			оСегмент.чОбработка = ОБРАБОТКА_ЗАГРУЖЕН;
			м_Статистика.ЗагруженСегмент(оРезультат.буфДанные.byteLength, оСегмент.чДлительность, оРезультат.чДлительностьЗагрузки, оРезультат.чОжиданиеОтвета);
			ЗагрузитьСледующийСегмент();
		})
		.catch(ДобавитьОбработчикИсключений(пПричина =>
		{
			// Не удалось загрузить файл?
			// Firefox: Во время отправки загруженного сегмента на преобразование может кинуть строковое исключение 'out of memory'.
			if (typeof пПричина === 'string' && оСегмент.чОбработка === ОБРАБОТКА_ЗАГРУЖАЕТСЯ)
			{
				м_Журнал.Ой(`[Загрузчик] Не удалось загрузить сегмент ${оСегмент.чНомер}. ${пПричина}`);
				Проверить(г_моОчередь.includes(оСегмент));
				// На всякий случай вызываем XMLHttpRequest.abort(). Для этого не обнуляем оСегмент.пДанные.
				ОбработатьНеудачнуюЗагрузкуСегмента(пПричина === (КОД_ОТВЕТА + 404) || пПричина === (КОД_ОТВЕТА + 410) ? null : оСегмент);
				Проверить(!г_моОчередь.includes(оСегмент));
				ЗагрузитьСледующийСегмент();
			}
			// Загрузка отменена?
			else if (пПричина === ОтменаОбещания.ОБЕЩАНИЕ_ОТМЕНЕНО)
			{
				м_Журнал.Вот(`[Загрузчик] Отменена загрузка сегмента ${оСегмент.чНомер}`);
				Проверить(!г_моОчередь.includes(оСегмент));
			}
			// Проверить() или незапланированное исключение.
			else
			{
				м_Отладка.ПойманоИсключение(пПричина);
			}
		}));
	}

	function ОбработатьНеудачнуюЗагрузкуСегмента(оНезагруженныйСегмент)
	// оНезагруженныйСегмент - сегмент, во время загрузки которого произошла ошибка.
	// оНезагруженныйСегмент = null - произошло переполнение очереди.
	{
		г_моОчередь.ПоказатьСостояние();
		const кДлинаОчереди = г_моОчередь.length;
		if (оНезагруженныйСегмент)
		{
			г_моОчередь.Удалить(оНезагруженныйСегмент);
		}
		else
		{
			var кОставитьСегментов = м_Настройки.Получить('кЗаначка');
			var чОставитьДлительность = м_Настройки.Получить('чРазмерБуфера');
			for (var ы = кДлинаОчереди - 1, оСегмент; оСегмент = г_моОчередь[ы]; --ы)
			{
				if (typeof оСегмент.пДанные === 'number')
				{
					continue;
				}
				if (оСегмент.чОбработка === ОБРАБОТКА_ЗАГРУЖАЕТСЯ)
				{
					г_моОчередь.Удалить(ы);
					continue;
				}
				if (оСегмент.чОбработка === ОБРАБОТКА_ЖДЕТ_ЗАГРУЗКИ)
				{
					if (кОставитьСегментов > 0)
					{
						кОставитьСегментов -= 1;
					}
					else if (чОставитьДлительность > 0)
					{
						чОставитьДлительность -= оСегмент.чДлительность;
					}
					else
					{
						г_моОчередь.Удалить(ы);
					}
				}
			}
		}
		г_моОчередь.ПоказатьСостояние();
		м_Статистика.НеЗагруженыСегменты(кДлинаОчереди - г_моОчередь.length);
	}


	return {
		ЗагрузитьТекст,
		ЗагрузитьСледующийСегмент
	};
})();

let м_Twitch = null;

function Twitch(_сКодКанала)
{
	const ИНТЕРВАЛ_ОБНОВЛЕНИЯ_МЕТАДАННЫХ_ТРАНСЛЯЦИИ = 60000; // Миллисекунды.
	const ЗАДЕРЖКА_ОБНОВЛЕНИЯ_МЕТАДАННЫХ_ЗАПИСИ = 4 * 60000; // Миллисекунды.
	const ИДЕНТИФИКАТОР_КЛИЕНТА = 'jzkbprff40iqj646a697cyrvl0zt2m6';

	const ЗАГОЛОВКИ_ЗАПРОСА =
	{
		'Client-ID': ИДЕНТИФИКАТОР_КЛИЕНТА,
		'Accept': 'application/vnd.twitchtv.v5+json'
	};

	let _сИдКанала     = '';
	let _сИдТрансляции = '';
	let _сИдЗрителя    = '';
	let _сТокенЗрителя = '';
	let _ооОбновлениеМетаданных = new ОтменаОбещания();

	function ПолучитьАдресУбогогоПроигрывателя()
	{
		// Twitch переводит код канала и параметры в нижний регистр.
		return `https://www.twitch.tv/${_сКодКанала}?twitch5=0`;
	}

	function ПолучитьАдресПанелиЧата()
	{
		if (м_Настройки.Получить('лПолноценныйЧат'))
		{
			return `https://www.twitch.tv/popout/${_сКодКанала}/chat`;
		}
		return м_Настройки.Получить('лЗатемнитьЧат')
			? `https://www.twitch.tv/embed/${_сКодКанала}/chat?darkpopout`
			: `https://www.twitch.tv/embed/${_сКодКанала}/chat`;
	}

	function ЭтоАдресПанелиЧата(сАдрес)
	{
		const мсРазбор = сАдрес.match(/^https:\/\/www.twitch.tv\/(?:popout|embed)\/([^/]+)\/chat(?:\?|$)/);
		return мсРазбор && мсРазбор[1] === _сКодКанала;
	}

	function ПолучитьАдресКаталогаИгры(сНазваниеИгры)
	{
		return 'https://www.twitch.tv/directory' + (сНазваниеИгры ? '/game/' + encodeURIComponent(сНазваниеИгры) : '');
	}

	function ИзменитьПодпискуЗрителяНаКанал(чПодписка)
	{
		Проверить(Number.isInteger(чПодписка));
		ПолучитьИлиИзменитьПодпискуЗрителяНаКанал(чПодписка);
	}

	function ПолучитьИлиИзменитьПодпискуЗрителяНаКанал(чПодписка)
	{
		Проверить(_сИдЗрителя && _сИдКанала && _сТокенЗрителя);
		if (_сИдЗрителя === _сИдКанала)
		{
			Проверить(чПодписка === undefined);
			м_События.ОбработатьСобытие('twitch-полученыметаданныезрителя', {чПодписка: ПОДПИСКА_НЕДОСТУПНА});
			return;
		}
		let сМетод, сПараметры;
		switch (чПодписка)
		{
			case undefined:             сМетод = 'GET';    сПараметры = ''; break;
			case ПОДПИСКА_НЕОФОРМЛЕНА:  сМетод = 'DELETE'; сПараметры = ''; break;
			case ПОДПИСКА_НЕУВЕДОМЛЯТЬ: сМетод = 'PUT';    сПараметры = '?notifications=false'; break;
			case ПОДПИСКА_УВЕДОМЛЯТЬ:   сМетод = 'PUT';    сПараметры = '?notifications=true';  break;
			default: Проверить(false);
		}
		м_Загрузчик.ЗагрузитьТекст(null,
			`https://api.twitch.tv/kraken/users/${_сИдЗрителя}/follows/channels/${_сИдКанала}${сПараметры}`,
			ЗАГРУЖАТЬ_МЕТАДАННЫЕ_НЕ_ДОЛЬШЕ, `подписка ${чПодписка}`, true,
			чПодписка === undefined ? ЗАГОЛОВКИ_ЗАПРОСА :
			{
				'Client-ID': ИДЕНТИФИКАТОР_КЛИЕНТА,
				'Accept': 'application/vnd.twitchtv.v5+json',
				'Authorization': `OAuth ${_сТокенЗрителя}`
			},
			сМетод
		)
		.then(сРезультат =>
		{
			// После DELETE код ответа 204.
			if (чПодписка === ПОДПИСКА_НЕОФОРМЛЕНА)
			{
				Проверить(сРезультат === '');
				м_События.ОбработатьСобытие('twitch-полученыметаданныезрителя', {чПодписка: ПОДПИСКА_НЕОФОРМЛЕНА});
				return;
			}
			let оРезультат;
			try
			{
				оРезультат = JSON.parse(сРезультат);
			}
			catch (пИсключение)
			{
				throw String(пИсключение);
			}
			Проверить(ЭтоНепустаяСтрока(оРезультат.created_at));
			Проверить(typeof оРезультат.notifications === 'boolean');
			// После смены уведомления, оРезультат.notifications иногда содержит предыдущее значение.
			// Это ошибка Twitch или сделано специально?
			м_События.ОбработатьСобытие('twitch-полученыметаданныезрителя',
			{
				чПодписка: чПодписка !== undefined ? чПодписка : оРезультат.notifications ? ПОДПИСКА_УВЕДОМЛЯТЬ : ПОДПИСКА_НЕУВЕДОМЛЯТЬ
			});
		})
		.catch(ДобавитьОбработчикИсключений(пПричина =>
		{
			// После GET код ответа 404 если зритель не подписан на канал.
			if (пПричина === (КОД_ОТВЕТА + 404))
			{
				Проверить(чПодписка === undefined);
				м_События.ОбработатьСобытие('twitch-полученыметаданныезрителя', {чПодписка: ПОДПИСКА_НЕОФОРМЛЕНА});
			}
			// TODO Обновить метаданные, если ошибка произошла из-за протухшего токена.
			else if (typeof пПричина === 'string')
			{
				м_Журнал.Ой(`[Twitch] Не удалось обновить подписку. ${пПричина}`);
				м_События.ОбработатьСобытие('twitch-полученыметаданныезрителя', {чПодписка: ПОДПИСКА_НЕДОСТУПНА});
			}
			// Отмены обещания в этой цепочке пока нет.
			else
			{
				м_Отладка.ПойманоИсключение(пПричина);
			}
		}));
	}

	const ПолученИдКанала = ДобавитьОбработчикИсключений(() =>
	{
		ПолучитьМетаданныеКанала();
		ПолучитьМетаданныеЗрителя();
	});

	function ПолучитьАбсолютныйАдресСпискаВариантов(ооОтменаОбещания)
	// Загружаем сегменты по http вместо https, чтобы напрасно не нагружать центральный процессор. Чтобы адреса
	// сегментов в списке были доступны по http, не используем need_https=true и загружаем список вариантов по http.
	{
		return м_Загрузчик.ЗагрузитьТекст(ооОтменаОбещания,
			// TODO Хорошо бы передавать в запросе _сИдКанала вместо _сКодКанала, но похоже API пока этого не позволяет.
			`https://api.twitch.tv/api/channels/${_сКодКанала}/access_token?adblock=false&need_https=false&platform=web&player_type=site`,
			ЗАГРУЖАТЬ_СПИСОК_ВАРИАНТОВ_НЕ_ДОЛЬШЕ, 'токен трансляции', true, {'Client-ID': ИДЕНТИФИКАТОР_КЛИЕНТА}
		)
		.then(
			сРезультат =>
			{
				const оРезультат = JSON.parse(сРезультат);
				// Если в коде канала есть знак вопроса, то Twitch вместо токена возвращает какую-то фигню.
				if (ЭтоОбъект(оРезультат) && ЭтоНепустаяСтрока(оРезультат.token) && ЭтоНепустаяСтрока(оРезультат.sig))
				{
					const оТокен = JSON.parse(оРезультат.token);
					if (оТокен.channel === _сКодКанала)
					{
						if (_сИдКанала === '')
						{
							Проверить(оТокен.hasOwnProperty('channel_id'));
							// В access token это число. В helix и части kraken это строка. Второй вариант более логичный.
							_сИдКанала = String(оТокен.channel_id);
							// Сначала загружаем видео, которое важнее метаданных.
							setImmediate(ПолученИдКанала);
						}
						else
						{
							// TODO Теоретически проверка может сработать, если во время трансляции канал поменяет код, другой канал
							// возьмет себе старый код, и метаданные трансляции не успеют получить новый код?
							Проверить(_сИдКанала === String(оТокен.channel_id));
						}
						// Этот адрес есть в <head> файла player.html.
						return `http://usher.ttvnw.net/api/channel/hls/${_сКодКанала}.m3u8?token=${encodeURIComponent(оРезультат.token)}&sig=${encodeURIComponent(оРезультат.sig)}&allow_source=true`;
					}
				}
				м_Отладка.ЗавершитьРаботуИПоказатьСообщение('J0203');
			},
			пПричина =>
			{
				// Канала не существует || запрещенное название канала?
				if (пПричина === (КОД_ОТВЕТА + 404) || пПричина === (КОД_ОТВЕТА + 422))
				{
					м_Отладка.ЗавершитьРаботуИПоказатьСообщение('J0203');
				}
				else
				{
					throw пПричина;
				}
			}
		);
	}

	function ПолучитьМетаданныеКанала()
	{
		Проверить(_сИдКанала);
		м_Загрузчик.ЗагрузитьТекст(null,
			`https://api.twitch.tv/kraken/channels/${_сИдКанала}`,
			ЗАГРУЖАТЬ_МЕТАДАННЫЕ_НЕ_ДОЛЬШЕ, 'метаданные канала', true, ЗАГОЛОВКИ_ЗАПРОСА
		)
		.then(сРезультат =>
		{
			let оРезультат;
			try
			{
				оРезультат = JSON.parse(сРезультат);
			}
			catch (пИсключение)
			{
				throw String(пИсключение);
			}
			const дКаналСоздан = new Date(оРезультат.created_at); // ISO 8601
			Проверить(
				оРезультат._id === _сИдКанала
				&& Number.isFinite(оРезультат.followers)
				&& Number.isFinite(оРезультат.views)
				&& !Number.isNaN(дКаналСоздан.getTime())
			);
			м_События.ОбработатьСобытие('twitch-полученыметаданныеканала',
			{
				сИмя: оРезультат.display_name || оРезультат.name,
				сАватар: оРезультат.logo || chrome.extension.getURL('glitch.svg#avatar'),
				сОписание: оРезультат.description,
				сКодЯзыка: оРезультат.broadcaster_language === 'other' ? null : оРезультат.broadcaster_language,
				кПодписчиков: оРезультат.followers,
				кПросмотров: оРезультат.views,
				дКаналСоздан
			});
		})
		.catch(пПричина =>
		{
			if (typeof пПричина === 'string')
			{
				м_Журнал.Ой(`[Twitch] Не удалось получить метаданные канала. ${пПричина}`);
			}
			// Отмены обещания в этой цепочке пока нет.
			else
			{
				м_Отладка.ПойманоИсключение(пПричина);
			}
		});

		м_Загрузчик.ЗагрузитьТекст(null,
			`https://api.twitch.tv/kraken/channels/${_сИдКанала}/communities`,
			ЗАГРУЖАТЬ_МЕТАДАННЫЕ_НЕ_ДОЛЬШЕ, 'сообщества канала', true, ЗАГОЛОВКИ_ЗАПРОСА
		)
		.then(сРезультат =>
		{
			let оРезультат;
			try
			{
				оРезультат = JSON.parse(сРезультат);
			}
			catch (пИсключение)
			{
				throw String(пИсключение);
			}
			Проверить(Array.isArray(оРезультат.communities));
			for (let оСообщество of оРезультат.communities)
			{
				Проверить(ЭтоНепустаяСтрока(оСообщество.name));
				оСообщество.сИмя = оСообщество.display_name || оСообщество.name;
				оСообщество.сОписание = оСообщество.description;
				оСообщество.сАдрес = `https://www.twitch.tv/communities/${encodeURIComponent(оСообщество.name)}`;
			}
			м_События.ОбработатьСобытие('twitch-полученыметаданныеканала', {моСообщества: оРезультат.communities});
		})
		.catch(пПричина =>
		{
			if (typeof пПричина === 'string')
			{
				м_Журнал.Ой(`[Twitch] Не удалось получить сообщества канала. ${пПричина}`);
			}
			// Отмены обещания в этой цепочке пока нет.
			else
			{
				м_Отладка.ПойманоИсключение(пПричина);
			}
		});

		м_Загрузчик.ЗагрузитьТекст(null,
			`https://api.twitch.tv/kraken/channels/${_сИдКанала}/teams`,
			ЗАГРУЖАТЬ_МЕТАДАННЫЕ_НЕ_ДОЛЬШЕ, 'команды канала', true, ЗАГОЛОВКИ_ЗАПРОСА
		)
		.then(сРезультат =>
		{
			let оРезультат;
			try
			{
				оРезультат = JSON.parse(сРезультат);
			}
			catch (пИсключение)
			{
				throw String(пИсключение);
			}
			Проверить(Array.isArray(оРезультат.teams));
			for (let оКоманда of оРезультат.teams)
			{
				Проверить(ЭтоНепустаяСтрока(оКоманда.name));
				оКоманда.сИмя = оКоманда.display_name || оКоманда.name;
				if (оКоманда.info)
				{
					оКоманда.сОписание = ПреобразоватьРазметкуВТекст(оКоманда.info);
				}
				оКоманда.сАдрес = `https://www.twitch.tv/team/${encodeURIComponent(оКоманда.name)}`;
			}
			м_События.ОбработатьСобытие('twitch-полученыметаданныеканала', {моКоманды: оРезультат.teams});
		})
		.catch(пПричина =>
		{
			if (typeof пПричина === 'string')
			{
				м_Журнал.Ой(`[Twitch] Не удалось получить команды канала. ${пПричина}`);
			}
			// Отмены обещания в этой цепочке пока нет.
			else
			{
				м_Отладка.ПойманоИсключение(пПричина);
			}
		});
	}

	function ПолучитьМетаданныеЗрителя()
	{
		let сИмя;
		м_Загрузчик.ЗагрузитьТекст(null, 'https://api.twitch.tv/kraken/user',
			ЗАГРУЖАТЬ_МЕТАДАННЫЕ_НЕ_ДОЛЬШЕ, 'метаданные зрителя',
			false, // Не светить мыло.
			ЗАГОЛОВКИ_ЗАПРОСА
		)
		.then(сРезультат =>
		{
			let оРезультат;
			try
			{
				оРезультат = JSON.parse(сРезультат);
			}
			catch (пИсключение)
			{
				throw String(пИсключение);
			}
			Проверить(ЭтоНепустаяСтрока(оРезультат._id));
			Проверить(ЭтоНепустаяСтрока(оРезультат.name));
			_сИдЗрителя = оРезультат._id;
			сИмя = оРезультат.display_name || оРезультат.name;
			return м_Загрузчик.ЗагрузитьТекст(null, 'https://api.twitch.tv/api/viewer/token.json',
				ЗАГРУЖАТЬ_МЕТАДАННЫЕ_НЕ_ДОЛЬШЕ, 'токен зрителя',
				false,
				{'Client-ID': ИДЕНТИФИКАТОР_КЛИЕНТА}
			);
		})
		.then(сРезультат =>
		{
			let оРезультат;
			try
			{
				оРезультат = JSON.parse(сРезультат);
			}
			catch (пИсключение)
			{
				throw String(пИсключение);
			}
			Проверить(ЭтоНепустаяСтрока(оРезультат.token));
			_сТокенЗрителя = оРезультат.token;
			м_События.ОбработатьСобытие('twitch-полученыметаданныезрителя', {сИмя});
			ПолучитьИлиИзменитьПодпискуЗрителяНаКанал();
		})
		.catch(ДобавитьОбработчикИсключений(пПричина =>
		{
			if (typeof пПричина === 'string')
			{
				// Считаем, что зритель не авторизован на сайте Twitch.tv.
				м_Журнал.Ой(`[Twitch] Не удалось получить метаданные зрителя. ${пПричина}`);
				_сИдЗрителя = _сТокенЗрителя = '';
				м_События.ОбработатьСобытие('twitch-полученыметаданныезрителя', {сИмя: ''});
			}
			// Отмены обещания в этой цепочке пока нет.
			else
			{
				м_Отладка.ПойманоИсключение(пПричина);
			}
		}));
	}

	function ОбновитьМетаданныеТрансляции(чЧерез)
	{
		Проверить(_сИдКанала);
		м_Журнал.Вот(`[Twitch] Загрузка метаданных трансляции начнется через ${м_Журнал.F0(чЧерез)}мс`);
		Ждать(_ооОбновлениеМетаданных, чЧерез)
		.then(() =>
		{
			return м_Загрузчик.ЗагрузитьТекст(_ооОбновлениеМетаданных,
				`https://api.twitch.tv/kraken/streams/${_сИдКанала}`,
				ЗАГРУЖАТЬ_МЕТАДАННЫЕ_НЕ_ДОЛЬШЕ, 'метаданные трансляции', true, ЗАГОЛОВКИ_ЗАПРОСА
			);
		})
		.then(сРезультат =>
		{
			let оРезультат;
			try
			{
				оРезультат = JSON.parse(сРезультат);
			}
			catch (пИсключение)
			{
				throw String(пИсключение);
			}
			// Данные отсутствуют если трансляция скрыта или только началась.
			if (!ЭтоОбъект(оРезультат) || !ЭтоОбъект(оРезультат.stream))
			{
				throw 'В загруженном JSON нет метаданных';
			}
			const чДлительностьТрансляции = Date.now() - Date.parse(оРезультат.stream.created_at); // ISO 8601
			Проверить(
				String(оРезультат.stream.channel._id) === _сИдКанала
				&& оРезультат.stream.hasOwnProperty('_id')
				&& ЭтоНепустаяСтрока(оРезультат.stream.stream_type)
				&& Number.isFinite(оРезультат.stream.viewers)
				&& Number.isFinite(чДлительностьТрансляции)
			);
			// Менять здесь: https://passport.twitch.tv/logins/new
			if (_сКодКанала !== оРезультат.stream.channel.name)
			{
				м_Журнал.Ой(`[Twitch] Изменился код канала с ${_сКодКанала} на ${оРезультат.stream.channel.name}`);
				_сКодКанала = оРезультат.stream.channel.name;
			}
			// live - прямая трансляция, watch_party - повтор трансляции.
			const лЗапись = оРезультат.stream.stream_type !== 'live';
			const оМетаданные =
			{
				сНазваниеТрансляции: оРезультат.stream.channel.status || Текст('J0103'),
				сНазваниеИгры: лЗапись ? null : оРезультат.stream.game || Текст('J0104'),
				сАдресИгры: ПолучитьАдресКаталогаИгры(оРезультат.stream.game),
				кЗрителей: оРезультат.stream.viewers,
				чДлительностьТрансляции
			};
			// Теоретически возможна ситуация, когда сервер начал другую трансляцию, а старая еще не досмотрена
			// (часть находится в буфере проигрывателя). Поэтому не перезаписываем _сИдТрансляции.
			if (_сИдТрансляции === '')
			{
				м_Журнал.Окак(`[Twitch] Идентификатор трансляции: ${оРезультат.stream._id}`);
				_сИдТрансляции = String(оРезультат.stream._id);
				оМетаданные.лЗапись = лЗапись;
				оМетаданные.сАдресЗаписи = '';
				if (!лЗапись)
				{
					ПолучитьАдресЗаписиТрансляции(чДлительностьТрансляции);
				}
			}
			м_События.ОбработатьСобытие('twitch-полученыметаданныетрансляции', оМетаданные);
			ОбновитьМетаданныеТрансляции(ИНТЕРВАЛ_ОБНОВЛЕНИЯ_МЕТАДАННЫХ_ТРАНСЛЯЦИИ);
		})
		.catch(ДобавитьОбработчикИсключений(пПричина =>
		{
			// Не удалось загрузить или разобрать файл?
			if (typeof пПричина === 'string')
			{
				м_Журнал.Ой(`[Twitch] Не удалось загрузить метаданные трансляции. ${пПричина}`);
				ОбновитьМетаданныеТрансляции(ИНТЕРВАЛ_ОБНОВЛЕНИЯ_МЕТАДАННЫХ_ТРАНСЛЯЦИИ / 2);
			}
			// Загрузка отменена?
			else if (пПричина === ОтменаОбещания.ОБЕЩАНИЕ_ОТМЕНЕНО)
			{
				м_Журнал.Вот('[Twitch] Отменено обновление метаданных трансляции');
			}
			// Проверить() или незапланированное исключение.
			else
			{
				м_Отладка.ПойманоИсключение(пПричина);
			}
		}));
	}

	function ПолучитьАдресЗаписиТрансляции(чДлительностьТрансляции)
	{
		Проверить(_сИдКанала && _сИдТрансляции);
		// _ооОбновлениеМетаданных использовать нельзя, потому что ОтменаОбещания может отменить только одну цепочку обещаний.
		const сИдТрансляции = _сИдТрансляции;
		// Запись доступна только через несколько минут после начала трансляции.
		// Возможна отрицательная чДлительностьТрансляции, если время на компьютере пользователя установлено неправильно.
		const чЖдать = Math.max(ЗАДЕРЖКА_ОБНОВЛЕНИЯ_МЕТАДАННЫХ_ЗАПИСИ - Math.max(чДлительностьТрансляции, 0), 0);
		м_Журнал.Вот(`[Twitch] Получение записи трансляции начнется через ${м_Журнал.F0(чЖдать)}мс`);
		Ждать(null, чЖдать)
		.then(() =>
		{
			if (сИдТрансляции !== _сИдТрансляции)
			{
				throw 'Трансляция завершена';
			}
			// По broadcast_id фильровать не умеет.
			return м_Загрузчик.ЗагрузитьТекст(null,
				`https://api.twitch.tv/kraken/channels/${_сИдКанала}/videos?broadcast_type=archive&limit=3`,
				ЗАГРУЖАТЬ_МЕТАДАННЫЕ_НЕ_ДОЛЬШЕ, 'запись трансляции', true, ЗАГОЛОВКИ_ЗАПРОСА
			);
		})
		.then(сРезультат =>
		{
			if (сИдТрансляции !== _сИдТрансляции)
			{
				throw 'Трансляция завершена';
			}
			let оРезультат;
			try
			{
				оРезультат = JSON.parse(сРезультат);
			}
			catch (пИсключение)
			{
				throw String(пИсключение);
			}
			for (let оЗапись of оРезультат.videos)
			{
				if (String(оЗапись.broadcast_id) === сИдТрансляции)
				{
					Проверить(оЗапись.broadcast_type === 'archive');
					Проверить(String(оЗапись.channel._id) === _сИдКанала);
					м_События.ОбработатьСобытие('twitch-полученыметаданныетрансляции',
					{
						лЗапись: false,
						сАдресЗаписи: оЗапись.url
					});
					break;
				}
			}
		})
		.catch(пПричина =>
		{
			if (typeof пПричина === 'string')
			{
				м_Журнал.Ой(`[Twitch] Не удалось загрузить запись трансляции. ${пПричина}`);
			}
			else
			{
				м_Отладка.ПойманоИсключение(пПричина);
			}
		});
	}

	function НачатьСборМетаданныхТрансляции()
	{
		_сИдТрансляции = '';
		_ооОбновлениеМетаданных.НачалоВыполнения();
		ОбновитьМетаданныеТрансляции(0);
	}

	function ЗавершитьСборМетаданныхТрансляции(лТрансляцияЗавершена)
	{
		// Не менять _сИдТрансляции после постановки на паузу, чтобы не прерывать работу
		// ПолучитьАдресЗаписиТрансляции(), а также чтобы была возможность создать клип.
		if (лТрансляцияЗавершена)
		{
			_сИдТрансляции = '';
		}
		м_Журнал.Вот('[Twitch] Отменяю обновление метаданных трансляции');
		_ооОбновлениеМетаданных.Отменить();
	}

	function СоздатьКлип()
	// TODO Проверять авторизацию, например _сИдЗрителя. Пока она обновляется только во время загрузки
	// страницы, а также использует недокументированые возможности. Вреда может быть больше, чем пользы.
	{
		const чПозиция = Math.round(м_Проигрыватель.ПолучитьПозициюВоспроизведенияТрансляции() - 3);
		if (_сИдТрансляции !== '' && чПозиция > 0)
		{
			м_Журнал.Окак(`[Twitch] Создаю клип ИдЗрителя=${_сИдЗрителя} ИдТрансляции=${_сИдТрансляции} Позиция=${чПозиция}`);
			document.getElementById('создатьклип-канал').value = _сКодКанала;
			document.getElementById('создатьклип-трансляция').value = _сИдТрансляции;
			document.getElementById('создатьклип-позиция').value = чПозиция;
			try
			{
				// Firefox 56: Если расширению не разрешено открывать всплывающие окна (например, создание клипа запущено
				// нажатием комбинации клавиш на клавиатуре), то будет кинуто XUL-исключение (и показано уведомление).
				document.getElementById('создатьклип-форма').submit();
			}
			catch (и) {}
		}
		else
		{
			м_Журнал.Ой(`[Twitch] Недостаточно данных для создания клипа ИдЗрителя=${_сИдЗрителя} ИдТрансляции=${_сИдТрансляции} Позиция=${чПозиция}`);
		}
	}

	function ПолучитьАбсолютныйАдресСпискаСегментов(сАбсолютныйАдресСпискаСегментов)
	{
		return сАбсолютныйАдресСпискаСегментов;
	}

	Проверить(ЭтоНепустаяСтрока(_сКодКанала));

	return {
		ПолучитьАбсолютныйАдресСпискаВариантов, ПолучитьАбсолютныйАдресСпискаСегментов,
		ПолучитьАдресУбогогоПроигрывателя, ПолучитьАдресПанелиЧата, ЭтоАдресПанелиЧата,
		НачатьСборМетаданныхТрансляции, ЗавершитьСборМетаданныхТрансляции,
		ИзменитьПодпискуЗрителяНаКанал,
		СоздатьКлип
	};
}

function ПроизвольныйСписокВариантов(_сАбсолютныйАдресСпискаВариантов)
{
	function ПолучитьАдресСледующегоСписка(сАбсолютныйАдресСписка)
	{
		return сАбсолютныйАдресСписка.replace(
			/^(file:\/\/\/.*)(\d+)(\.m3u8)$/,
			(сСтрока, сЧасть1, сЧасть2, сЧасть3) => сЧасть1 + (Number.parseInt(сЧасть2, 10) + 1) + сЧасть3
		);
	}

	function ПолучитьАбсолютныйАдресСпискаВариантов()
	{
		_сАбсолютныйАдресСпискаВариантов = ПолучитьАдресСледующегоСписка(_сАбсолютныйАдресСпискаВариантов);
		return Promise.resolve(_сАбсолютныйАдресСпискаВариантов);
	}

	function ПолучитьАбсолютныйАдресСпискаСегментов(сАбсолютныйАдресСпискаСегментов)
	{
		return ПолучитьАдресСледующегоСписка(сАбсолютныйАдресСпискаСегментов);
	}

	function НетАдреса()
	{
		return 'about:blank';
	}

	function ЭтоАдресПанелиЧата()
	{
		return false;
	}

	return {
		ПолучитьАбсолютныйАдресСпискаВариантов, ПолучитьАбсолютныйАдресСпискаСегментов,
		ПолучитьАдресУбогогоПроигрывателя: НетАдреса, ПолучитьАдресПанелиЧата: НетАдреса, ЭтоАдресПанелиЧата,
		НачатьСборМетаданныхТрансляции: ЗАГЛУШКА, ЗавершитьСборМетаданныхТрансляции: ЗАГЛУШКА,
		СоздатьКлип: ЗАГЛУШКА
	};
}

//
// Запускалка.
//

function ЗавершитьРаботу(лБыстро)
{
	try
	{
		г_лРаботаЗавершена = true;
		м_Журнал.Окак('[Запускалка] Завершаю работу');
		// Если разбор страницы не завершен, не вставлять оставшиеся <script>.
		// Содержимое страницы будет заменено на форму показа сообщения или отчета.
		window.stop();
		// Запретить изменение настроек во время выполнения ЗавершитьРаботу(), чтобы не перезаписывать
		// их после вызова м_Настройки.Сбросить() и чтобы не сохранять всякую фигню в случае ошибок.
		м_Настройки.Остановить();
		if (!лБыстро)
		{
			м_Статистика.ЗакрытьОкно();
			м_Отладка.Остановить();
			м_Проигрыватель.Остановить();
			м_Помойка.Сжечь();
		}
		м_Twitch.ЗавершитьСборМетаданныхТрансляции(true);
		м_Список.Остановить();
		м_Преобразователь.Остановить();
		// Как правило, браузер не завершает перезагрузку страницы до окончания загрузки файлов.
		г_моОчередь.Очистить();
		м_Журнал.Окак('[Запускалка] Работа завершена');
	}
	catch (и) {}
}

ДобавитьОбработчикИсключений(() =>
{
	function ВыделитьКанал(оАдрес)
	{
		// Канала с названием channel не существует.
		const сКанал = РазобратьПараметры(оАдрес).get('channel') || 'channel';
		м_Журнал.Вот(`[Запускалка] Канал ${сКанал}`);
		// Вместо кода канала пользователь мог вставить название канала.
		return {сКодКанала: сКанал.toLowerCase(), сАбсолютныйАдресСпискаВариантов: ''};
	}

	function ЭтотКаналУжеОткрыт(сКодКанала)
	{
		Проверить(ЭтоНепустаяСтрока(сКодКанала));
		for (let оОкноРасширения of chrome.extension.getViews({type: 'tab'}))
		{
			// HACK Edge 16: Иногда вместо окна расширения getViews() возвращает окно фрейма с чатом. В этом случае
			// доступ к свойствам location кидает исключение Error: Permission denied. Можно читать document.URL.
			try
			{
				if (оОкноРасширения === window || оОкноРасширения.closed
				|| ВыделитьКанал(оОкноРасширения.location).сКодКанала !== сКодКанала)
				{
					continue;
				}
			}
			catch (пИсключение)
			{
				м_Журнал.Ой(`[Запускалка] Недоступно окно расширения: ${пИсключение}`);
				continue;
			}
			оОкноРасширения.chrome.tabs.getCurrent(ДобавитьОбработчикИсключений(оВкладка =>
			{
				if (оОкноРасширения.chrome.runtime.lastError)
				{
					м_Журнал.Ой(`[Запускалка] Недоступна вкладка расширения: ${оОкноРасширения.chrome.runtime.lastError.message}`);
				}
				else
				{
					chrome.tabs.update(оВкладка.id, {active: true});
					chrome.windows.update(оВкладка.windowId, {focused: true});
				}
				if (window.history.length > 1)
				{
					// Не делать window.history.back(). Можно вернуться на стандартный проигрыватель
					// и получить одновременное воспроизведение одного канала в двух вкладках. 
					м_Отладка.ЗавершитьРаботуИПоказатьСообщение('J0211');
				}
				else
				{
					// Firefox 59: window.close() отказывается закрывать текущую вкладку.
					chrome.tabs.getCurrent(ДобавитьОбработчикИсключений(оВкладка =>
					{
						Проверить(!chrome.runtime.lastError);
						chrome.tabs.remove(оВкладка.id);
					}));
				}
			}));
			return true;
		}
		return false;
	}

	function ЖдатьЗагрузкуСтраницы()
	{
		return new Promise((фВыполнить, фОтказаться) =>
		{
			if (document.readyState === 'complete')
			{
				м_Журнал.Ой('[Запускалка] document.readyState=complete');
				фВыполнить();
			}
			else
			{
				м_Журнал.Вот(`[Запускалка] document.readyState=${document.readyState}`);
				window.addEventListener('load', function ОбработатьЗагрузкуСтраницы()
				{
					try
					{
						window.removeEventListener('load', ОбработатьЗагрузкуСтраницы);
						Проверить(document.readyState === 'complete');
						м_Журнал.Вот('[Запускалка] window.onload');
						фВыполнить();
					}
					catch (пИсключение)
					{
						фОтказаться(пИсключение);
					}
				});
			}
		});
	}

	function ПолучитьТекущуюВкладку()
	{
		return new Promise((фВыполнить, фОтказаться) =>
		{
			chrome.tabs.getCurrent(оВкладка =>
			{
				try
				{
					Проверить(!chrome.runtime.lastError);
					Проверить(Number.isInteger(оВкладка.id) && оВкладка.id >= 0);
					г_чИдВкладки = оВкладка.id;
					фВыполнить();
				}
				catch (пИсключение)
				{
					фОтказаться(пИсключение);
				}
			});
		});
	}

	function ОбработатьВыгрузкуСтраницы(оСобытие)
	{
		м_Журнал.Окак('[Запускалка] window.beforeunload');
		ЗавершитьРаботу(true);
	}

	function НачатьРаботу()
	{
		м_Журнал.Вот(`[Запускалка] Начало работы ${performance.now().toFixed()}мс`);
		Проверить(!г_лРаботаЗавершена);
		window.addEventListener('beforeunload', ОбработатьВыгрузкуСтраницы);
		м_Отладка.Запустить();
		м_Управление.Запустить();
		if (м_Проигрыватель.Запустить())
		{
			м_Список.Запустить();
		}
		else
		{
			м_Управление.ПереключитьПросмотрТрансляции();
		}
		if (м_Настройки.Получить('лПоказатьСтатистику'))
		{
			м_Статистика.ОткрытьОкно();
		}
	}

	/*if (window.top !== window)
	{
		return;
	}

	if (navigator.userAgent.indexOf('Gecko/') !== -1 || navigator.userAgent.indexOf('Edge/') !== -1)
	{
		м_Отладка.ЗавершитьРаботуИПоказатьСообщение('J0204');
	}*/

	м_i18n.TranslateDocument(document);
		
	const оКанал = ВыделитьКанал(window.location);
	if (оКанал.сКодКанала)
	{
		if (ЭтотКаналУжеОткрыт(оКанал.сКодКанала))
		{
			return;
		}
		м_Twitch = Twitch(оКанал.сКодКанала);
	}
	else
	{
		м_Twitch = ПроизвольныйСписокВариантов(оКанал.сАбсолютныйАдресСпискаВариантов);
	}

	// HACK Firefox 48: Если не ждать события load, то индикатор загрузки на вкладке
	// будет крутиться очень долго (реакция на изменение HTMLVideoElement.src).
	// Также ждем загрузку остальных js-модулей.
	// Страница использует только локальные файлы, поэтому ожидание не займет много времени.
	Promise.all(
	[
		м_Настройки.Восстановить(),
		м_Оформление.ЗапуститьАсинхронно(),
		ЖдатьЗагрузкуСтраницы(),
		ПолучитьТекущуюВкладку()
	])
	.then(НачатьРаботу)
	.catch(м_Отладка.ПойманоИсключение);
})();

function fitVideo() {
	const video = document.getElementById('глаз'),
		wHeight = window.innerHeight,
		wWidth = window.innerWidth
	let vWidth = video.videoWidth,
		vHeight = video.videoHeight

	let sw = false
	if (vHeight > wHeight) { 
		vHeight = wHeight
		sw = true
	}
	if (vWidth > wWidth) {
		vWidth = wWidth
		sw = true
	}
	if (sw) video.style.objectFit = 'fill'

	video.style.width = vWidth + 'px'
	video.style.height = vHeight + 'px'
}
})(window);