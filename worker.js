



'use strict';

// Firefox, Chrome: subarray() немного медленнее чем new Uint8Array().
// TODO Добавить AVC3 если попадется трансляция с несколькими SPS.
// TODO Перевести часть Проверить() в Браковать().

const ВЕРСИЯ_РАСШИРЕНИЯ = '2018.4.6';
const ВЕРСИЯ_БРАУЗЕРА = Number.parseInt(/Chrome\/(\d+)/.exec(navigator.userAgent)[1], 10); // replace for prepack

function Проверить(пУсловие)
{
	if (!пУсловие)
	{
		throw new Error('Проверка не пройдена');
	}
}

function Браковать(пУсловие)
{
	if (!пУсловие)
	{
		throw new Error('БРАКОВАТЬ');
	}
}

function ЗавершитьРаботуИПоказатьСообщение(сКодСообщения)
{
	postMessage([4, сКодСообщения]);
	throw undefined;
}

function ЗавершитьРаботуИОтправитьОтчет(сПричинаЗавершенияРаботы, буфОтправить)
{
	if (typeof буфОтправить === 'object' && буфОтправить !== null && буфОтправить.byteLength)
	{
		postMessage([3, сПричинаЗавершенияРаботы, буфОтправить], [буфОтправить]);
	}
	else
	{
		postMessage([3, сПричинаЗавершенияРаботы, null]);
	}
}

function ВыброситьВПомойку(мбБарахло)
{
	if (мбБарахло && мбБарахло.buffer.byteLength)
	{
		postMessage([5, мбБарахло.buffer], [мбБарахло.buffer]);
	}
}


Uint8Array.prototype.Копировать = function(target, source, begin, end)
{
	this.set(new Uint8Array(source.buffer, begin, Math.floor(end) - Math.floor(begin)), target);
};

if (ВЕРСИЯ_БРАУЗЕРА < 58)
{
	Uint8Array.prototype.copyWithin = function(target, begin, end)
	// HACK Chrome 57-: copyWithin() охуенно медленный https://bugs.chromium.org/p/v8/issues/detail?id=5929
	// Отрицательные begin и end не поддерживаются.
	// Исходный и конечный блоки не должны выходить за пределы массива.
	// target, begin и end не должны превышать 0x7fffffff.
	{
		target |= 0;
		begin  |= 0;
		end    |= 0;
		var c = (end - begin)|0;
		if ((c|0) > 90)
		{
			this.set(new Uint8Array(this.buffer, begin, c), target);
		}
		else
		{
			while ((begin|0) < (end|0))
			{
				this[target] = this[begin];
				target = (target + 1)|0;
				begin  = (begin  + 1)|0;
			}
		}
	};
}

if (ВЕРСИЯ_БРАУЗЕРА < 59)
{
	Uint8Array.prototype.slice = function(begin, end)
	// Chrome 44-: slice() не поддерживается.
	// HACK Chrome 58-: slice() медленный на больших блоках https://bugs.chromium.org/p/v8/issues/detail?id=5929
	// Отрицательные begin и end не поддерживаются.
	// begin и end не должны выходить за пределы массива.
	// begin и end не должны превышать 0x7fffffff.
	{
		begin |= 0;
		end   |= 0;
		if (arguments.length === 0 || (begin === 0 && end === this.length))
		{
			return new Uint8Array(this);
		}
		Проверить(begin <= end && begin >= 0 && end <= this.length);
		var c = (end - begin)|0;
		if ((c|0) > 100)
		{
			return new Uint8Array(new Uint8Array(this.buffer, begin, c));
		}
		var a = new Uint8Array(c);
		var target = 0;
		while ((begin|0) < (end|0))
		{
			a[target] = this[begin];
			target = (target + 1)|0;
			begin  = (begin  + 1)|0;
		}
		return a;
	};
}


// HACK Firefox 49, Chrome 53: Эмулятор DataView примерно в 10 раз быстрее нативного.
// https://bugs.chromium.org/p/chromium/issues/detail?id=225811
// Кроме того, он удобнее, потому что все данные у меня храняться в Uint8Array.

Uint8Array.prototype.ПрочестьБЦ64 = function(у)
{
	у |= 0;
	return (((this[у        ] << 24) | (this[(у + 1)|0] << 16) | (this[(у + 2)|0] << 8) | this[(у + 3)|0]) >>> 0) * 4294967296
	     + (((this[(у + 4)|0] << 24) | (this[(у + 5)|0] << 16) | (this[(у + 6)|0] << 8) | this[(у + 7)|0]) >>> 0);
};

Uint8Array.prototype.ПрочестьЗЦ32 = function(у)
{
	у |= 0;
	return (this[у] << 24) | (this[(у + 1)|0] << 16) | (this[(у + 2)|0] << 8) | this[(у + 3)|0];
};

Uint8Array.prototype.ПрочестьБЦ32 = function(у)
{
	у |= 0;
	return ((this[у] << 24) | (this[(у + 1)|0] << 16) | (this[(у + 2)|0] << 8) | this[(у + 3)|0]) >>> 0;
};

Uint8Array.prototype.ПрочестьЗЦ16 = function(у)
{
	у |= 0;
	return ((this[у] << 24) >> 16) | this[(у + 1)|0];
};

Uint8Array.prototype.ПрочестьБЦ16 = function(у)
{
	у |= 0;
	return (this[у] << 8) | this[(у + 1)|0];
};

Uint8Array.prototype.ЗаписатьЗЦ64 = Uint8Array.prototype.ЗаписатьБЦ64 = function(у, чЗначение)
{
	у |= 0;
	var ч = Math.trunc(чЗначение);
	if (ч < Number.MIN_SAFE_INTEGER || ч > Number.MAX_SAFE_INTEGER)
	{
		throw new Error(чЗначение);
	}
	var ч32 = (ч / 4294967296)|0;
	this[у        ] = ч32 >> 24;
	this[(у + 1)|0] = ч32 >> 16;
	this[(у + 2)|0] = ч32 >> 8;
	this[(у + 3)|0] = ч32;
	ч32 = ч|0;
	this[(у + 4)|0] = ч32 >> 24;
	this[(у + 5)|0] = ч32 >> 16;
	this[(у + 6)|0] = ч32 >> 8;
	this[(у + 7)|0] = ч32;
};

Uint8Array.prototype.ЗаписатьЗЦ32 = Uint8Array.prototype.ЗаписатьБЦ32 = function(у, чЗначение)
{
	у |= 0;
	чЗначение |= 0;
	this[у        ] = чЗначение >> 24;
	this[(у + 1)|0] = чЗначение >> 16;
	this[(у + 2)|0] = чЗначение >> 8;
	this[(у + 3)|0] = чЗначение;
};

Uint8Array.prototype.ЗаписатьЗЦ16 = Uint8Array.prototype.ЗаписатьБЦ16 = function(у, чЗначение)
{
	у |= 0;
	чЗначение |= 0;
	this[у        ] = чЗначение >> 8;
	this[(у + 1)|0] = чЗначение;
};


function ОкруглитьРазмерКучиAsmJS(кбРазмер)
{
	// В http://asmjs.org/spec/latest/#linking-0 минимальный размер 2^12.
	// В Firefox 49 минимальный размер 2^16 (размер страницы WASM).
	if (кбРазмер <= (1 << 16))
	{
		return 1 << 16;
	}
	if (кбРазмер >= (1 << 24))
	{
		return ((кбРазмер + 0x00ffffff) & 0xff000000) >>> 0;
	}
	return 1 << (32 - Math.clz32(кбРазмер - 1));
}

// HACK Chrome 53: Если AsmJS() вызвана (link) больше 4 раз, то оптимизация SearchStartCodePrefix() отключается.
// Чтобы этого избежать, не добавляем 'use asm'. Скорость SearchStartCodePrefix() не падает, потому что в Chrome
// нет полноценного AOT-компилятора asm.js.
	// ITU-T H.264:2014 Annex B
	// Ищет start code prefix: минимум два нулевых байта, за ними единица.
	// Возвращает указатель на начало префикса. Первые 2 байта префикса содержат размер префикса.
	// Состав префикса в зависимости от его длины:
	//   =3 - start_code_prefix_one_3bytes
	//   =4 - zero_byte + start_code_prefix_one_3bytes
	//   >4 - leading_zero_8bits или trailing_zero_8bits + zero_byte + start_code_prefix_one_3bytes
	// Если префикс не найден, возвращает b.
	// Если ошибка в параметрах, возвращает -1.
	// Если данные повреждены, возвращает -2.
	// a и b не должны выходить за пределы массива.
	// a и b не должны превышать 0x7fffffff.
	// HACK Функция выглядит странно, потому что оптимизирована под оба режима: с 'use asm' и без него.
	// Firefox 49 x86, Chrome 53 x64: без 'use asm' функция работает примерно на 20% быстрее,
	// но это разница может меняться в разных версиях браузеров.

		// Сюда можно было вынести проверки 3-го и 4-го байтов на равенство 1, но это
		// ухудшает оптимизацию функции в Chrome 53, поэтому проверки оставлены в нижнем цикле.
		// TODO При необходимости увеличить размер до 3-х байт.
		// Twitch: Иногда в filler data встречаются последовательности нулевых байтов произвольной длины.
				// Они не мешают просмотру, но нарушают несколько правил стандарта H.264.
function AsmJS(stdlib, foreign, heap) {
	"use asm";

	var arr = new stdlib.Uint8Array(heap);

	function SearchStartCodePrefix(a, b){
		a = a|0;
		b = b|0;

		var b3 = 0, c = 0, ad = 0;

		if (((a|0) < 0) | ((a|0) > (b|0)))
		{
			return -1|0;
		}

		b3 = (b - 3)|0;
		for (;;)
		{
			if ((a|0) > (b3|0))
			{
				return b|0;
			}
			c = arr[a >> 0]|0;
			a = (a + 1)|0;
			if ((c|0) == 0)
			{
				c = arr[a >> 0]|0;
				a = (a + 1)|0;
				if ((c|0) == 0)
				{
					c = arr[a >> 0]|0;
					a = (a + 1)|0;
					if ((c|0) <= 1)
					{
						break;
					}
				}
			}
		}

		ad = (a - 3)|0;
		a = (a - 1)|0;
		do
		{
			c = arr[a >> 0]|0;
			a = (a + 1)|0;
			if ((c|0) == 1)
			{
				a = (a - ad)|0;
				
				if ((a|0) > 0xffff)
				{
					return -1|0;
				}
				arr[ad >> 0] = a;
				arr[(ad + 1) >> 0] = a >> 8;
				return ad|0;
			}
			if ((c|0) != 0)
			{
				
				return -2|0;
			}
		}
		while ((a|0) < (b|0))
		// trailing_zero_8bits
		return b|0;
	}

	return {SearchStartCodePrefix: SearchStartCodePrefix};
}

//
// ПотокБитов
//

function ПотокБитов(мбБуфер, уНачало, уКонец)
{
	Проверить(Number.isInteger(уНачало) && Number.isInteger(уКонец) && уНачало >= 0 && уКонец <= мбБуфер.length && уКонец >= уНачало);
	this._мбБуфер = мбБуфер;
	this._уСледующийБайт = уНачало;
	this._чСледующийБит = 7;
	this.кБитОсталось = (уКонец - уНачало) * 8;
}

ПотокБитов.prototype.ПропуститьБиты = function(кБиты)
{
	Проверить(Number.isInteger(кБиты));
	Проверить((this.кБитОсталось -= кБиты) >= 0);
	if (кБиты === 1)
	{
		if (--this._чСледующийБит < 0)
		{
			this._чСледующийБит = 7;
			++this._уСледующийБайт;
		}
	}
	else
	{
		var ч = this._чСледующийБит - кБиты;
		if (ч >= 0)
		{
			this._чСледующийБит = ч;
		}
		else
		{
			ч = -ч - 1;
			this._чСледующийБит = 7 - (ч & 7);
			this._уСледующийБайт += (ч >>> 3) + 1;
		}
	}
};

ПотокБитов.prototype.ПрочестьБиты = function(кБиты)
{
	Проверить(Number.isInteger(кБиты));
	Проверить((this.кБитОсталось -= кБиты) >= 0);
	if (кБиты === 1)
	{
		чРезультат = (this._мбБуфер[this._уСледующийБайт] >>> this._чСледующийБит) & 1;
		if (--this._чСледующийБит < 0)
		{
			this._чСледующийБит = 7;
			++this._уСледующийБайт;
		}
	}
	else
	{
		Проверить(кБиты >= 1 && кБиты <= 32);
		var чРезультат = 0;
		var чСледующийБитРезультата = кБиты - 1;
		var чМаска = (1 << (this._чСледующийБит + 1)) - 1;
		do
		{
			var чБиты = this._мбБуфер[this._уСледующийБайт] & чМаска;
			чРезультат |= this._чСледующийБит < чСледующийБитРезультата
				? чБиты << (чСледующийБитРезультата - this._чСледующийБит)
				: чБиты >>> (this._чСледующийБит - чСледующийБитРезультата);
			var кБитДобавлено = Math.min(чСледующийБитРезультата, this._чСледующийБит) + 1;
			if ((this._чСледующийБит -= кБитДобавлено) < 0)
			{
				this._чСледующийБит = 7;
				++this._уСледующийБайт;
				чМаска = 0xFF;
			}
		}
		while ((чСледующийБитРезультата -= кБитДобавлено) >= 0);
	}
	return чРезультат >>> 0;
};

ПотокБитов.prototype.ПрочестьБеззнаковыйЭКГ = function()
// Читает беззнаковый экспоненциальный код Голомба.
// ITU-T H.264:2014 9.1 Parsing process for Exp-Golomb codes
{
	for (var кНачальныеНули = 0; this.ПрочестьБиты(1) === 0; ++кНачальныеНули) {}
	Проверить(кНачальныеНули <= 31);
	return кНачальныеНули === 0 ? 0 : ((1 << кНачальныеНули) >>> 0) - 1 + this.ПрочестьБиты(кНачальныеНули);
};

ПотокБитов.prototype.ПрочестьЗнаковыйЭКГ = function()
// Читает знаковый экспоненциальный код Голомба.
// ITU-T H.264:2014 9.1.1 Mapping process for signed Exp-Golomb codes
{
	var ч = this.ПрочестьБеззнаковыйЭКГ();
	return (ч & 1) !== 0 ? Math.ceil(ч / 2) : -(ч / 2);
};

ПотокБитов.prototype.ПропуститьЭКГ = function()
// Пропускает беззнаковый и знаковый экспоненциальный код Голомба.
{
	for (var кНачальныеНули = 0; this.ПрочестьБиты(1) === 0; ++кНачальныеНули) {}
	if (кНачальныеНули !== 0)
	{
		this.ПропуститьБиты(кНачальныеНули);
	}
};


//
// IsoBaseMedia ISO 14496-12:2012
//

function IsoBaseMedia(мбБуфер, уНачало)
{
	Проверить(Number.isInteger(уНачало) && уНачало >= 0 && уНачало <= мбБуфер.length);
	this.мбБуфер = мбБуфер;
	this.уНачало = уНачало;
	this.уКонец  = уНачало;
}

IsoBaseMedia.prototype.Завершить = function()
{
	Проверить(Number.isInteger(this.уКонец) && this.уКонец >= this.уНачало && this.уКонец <= this.мбБуфер.length);
	return this.мбБуфер.subarray(this.уНачало, this.уКонец);
};

IsoBaseMedia.prototype.AddBox = function(сТип, пСодержимое)
{
	return this.AddFullBox(сТип, -1, -1, пСодержимое);
};

IsoBaseMedia.prototype.AddFullBox = function(сТип, чВерсия, чФлаги, пСодержимое)
// uint32_t РазмерЭтойСтруктурыИСодержимого
// char     Тип[4]
// uint32_t ВерсияИФлаги
{
	Проверить(сТип.length === 4 && Number.isFinite(чВерсия) && Number.isFinite(чФлаги));

	Проверить(this.уКонец >= this.уНачало);
	var уНачало = this.уКонец;

	Проверить(this.мбБуфер.length - this.уКонец >= 8);
	this.мбБуфер[уНачало + 4] = сТип.charCodeAt(0);
	this.мбБуфер[уНачало + 5] = сТип.charCodeAt(1);
	this.мбБуфер[уНачало + 6] = сТип.charCodeAt(2);
	this.мбБуфер[уНачало + 7] = сТип.charCodeAt(3);
	this.уКонец += 8;
	
	if (чВерсия !== -1)
	{
		Проверить(чВерсия >= 0 && чВерсия <= 0xFF && чФлаги >= 0 && чФлаги <= 0xFFFFFF);
		Проверить(this.мбБуфер.length - this.уКонец >= 4);
		this.мбБуфер.ЗаписатьБЦ32(уНачало + 8, (чВерсия << 24) | чФлаги);
		this.уКонец += 4;
	}
	
	if (typeof пСодержимое === 'number')
	{
		// Размер содержимого в байтах.
		Проверить(Number.isInteger(пСодержимое) && пСодержимое >= 0);
		this.уКонец += пСодержимое;
		Проверить(this.уКонец <= this.мбБуфер.length);
	}
	else if (typeof пСодержимое === 'function')
	{
		// Функция заполняет содержимое и изменяет this.уКонец.
		var у = this.уКонец;
		пСодержимое();
		Проверить(Number.isInteger(this.уКонец) && this.уКонец >= у && this.уКонец <= this.мбБуфер.length);
	}
	else
	{
		// Копировать содержимое из пСодержимое.
		this.Копировать(this.уКонец, пСодержимое);
	}

	this.мбБуфер.ЗаписатьБЦ32(уНачало, this.уКонец - уНачало);
};

IsoBaseMedia.prototype.Копировать = function(уКуда, мОткуда, уНачало, уКонец)
{
	Проверить(Number.isInteger(уКуда) && уКуда >= this.уКонец);
	if (arguments.length === 2)
	{
		// set() кинет исключение при выходе за пределы массива.
		this.мбБуфер.set(мОткуда, уКуда);
		this.уКонец = уКуда + мОткуда.length;
	}
	else
	{
		Проверить(Number.isInteger(уНачало) && Number.isInteger(уКонец));
		this.мбБуфер.Копировать(уКуда, мОткуда, уНачало, уКонец);
		this.уКонец = уКуда + уКонец - уНачало;
	}
};

//
// ID3 v2.4.0 http://id3.org/Developer%20Information
//

function ID3(мбБуфер, уНачало, уКонец)
{
	const РАЗМЕР_ЗАГОЛОВКА_ТЕГА = 10;
	const РАЗМЕР_ЗАГОЛОВКА_ПОЛЯ = 10;

	Проверить(мбБуфер.BYTES_PER_ELEMENT === 1 && Number.isInteger(уНачало) && Number.isInteger(уКонец) && уНачало >= 0 && уНачало <= уКонец);

	this._мб = мбБуфер;
	var кбРазмер = уКонец - уНачало;
	if (кбРазмер > РАЗМЕР_ЗАГОЛОВКА_ТЕГА + РАЗМЕР_ЗАГОЛОВКА_ПОЛЯ
	&& this._мб[уНачало    ] === 0x49 // tag identifier[0] == 'I'
	&& this._мб[уНачало + 1] === 0x44 // tag identifier[1] == 'D'
	&& this._мб[уНачало + 2] === 0x33 // tag identifier[2] == '3'
	&& this._мб[уНачало + 3] === 4    // major version == 4
	&& this._мб[уНачало + 5] === 0    // unsynchronisation == 0, extended header == 0, experimental indicator == 0, footer present == 0, undefined flags == 0
	&& this._ParseSynchsafeInteger(уНачало + 6) === кбРазмер - РАЗМЕР_ЗАГОЛОВКА_ТЕГА) // tag size
	{
		this._уТег  = уНачало  + РАЗМЕР_ЗАГОЛОВКА_ТЕГА;
		this._кбТег = кбРазмер - РАЗМЕР_ЗАГОЛОВКА_ТЕГА;
	}
	else
	{
		this._уТег  = -1;
		this._кбТег = -1;
	}
	this._уПоле  = -1;
	this._кбПоле = -1;
}

ID3._oUtf8Decoder = null; // static

ID3.prototype.ПолучитьСледующееПоле = function()
{
	const РАЗМЕР_ЗАГОЛОВКА_ПОЛЯ = 10;

	if (this._кбТег > РАЗМЕР_ЗАГОЛОВКА_ПОЛЯ)
	{
		var ч1 = this._мб[this._уТег    ]; // frame identifier
		var ч2 = this._мб[this._уТег + 1];
		var ч3 = this._мб[this._уТег + 2];
		var ч4 = this._мб[this._уТег + 3];
		if ((ч1 >= 0x30 && ч1 <= 0x39) || (ч1 >= 0x41 && ч1 <= 0x5A)
		&&  (ч2 >= 0x30 && ч2 <= 0x39) || (ч2 >= 0x41 && ч2 <= 0x5A)
		&&  (ч3 >= 0x30 && ч3 <= 0x39) || (ч3 >= 0x41 && ч3 <= 0x5A)
		&&  (ч4 >= 0x30 && ч4 <= 0x39) || (ч4 >= 0x41 && ч4 <= 0x5A))
		{
			var кбПоле = this._ParseSynchsafeInteger(this._уТег + 4); // frame size
			if (кбПоле >= 1 && кбПоле <= this._кбТег - РАЗМЕР_ЗАГОЛОВКА_ПОЛЯ)
			{
				if (this._мб[this._уТег + 9] === 0) // grouping identity == 0, compression == 0, encryption == 0, unsynchronisation == 0, data length indicator == 0, undefined flags == 0
				{
					this._уПоле  = this._уТег + РАЗМЕР_ЗАГОЛОВКА_ПОЛЯ;
					this._кбПоле = кбПоле;
					this._уТег  += РАЗМЕР_ЗАГОЛОВКА_ПОЛЯ + кбПоле;
					this._кбТег -= РАЗМЕР_ЗАГОЛОВКА_ПОЛЯ + кбПоле;
					return String.fromCharCode(ч1, ч2, ч3, ч4);
				}
			}
		}
	}
	this._уПоле  = -1;
	this._кбПоле = -1;
	return null;
};

ID3.prototype.ПолучитьПервоеТекстовоеЗначение = function()
{
	if (this._кбПоле < 2 /* encoding description + 0x00 */ || this._мб[this._уПоле] !== 3 /* utf-8 */)
	{
		return null;
	}
	if (ID3._oUtf8Decoder === null)
	{
		ID3._oUtf8Decoder = new TextDecoder('utf-8', {fatal: true});
	}
	try
	{
		var сЗначения = ID3._oUtf8Decoder.decode(new Uint8Array(this._мб.buffer, this._уПоле + 1, this._кбПоле - 1));
	}
	catch (и)
	{
		return null;
	}
	var чКонец1гоЗначения = сЗначения.indexOf('\0');
	if (чКонец1гоЗначения === -1)
	{
		return null;
	}
	return сЗначения.slice(0, чКонец1гоЗначения);
};

ID3.prototype._ParseSynchsafeInteger = function(уАдрес)
{
	var чРезультат = -1;
	var чБайт = this._мб[уАдрес];
	if (чБайт < 0x80)
	{
		var ч4Байта = чБайт << (24 - 3);
		чБайт = this._мб[уАдрес + 1];
		if (чБайт < 0x80)
		{
			ч4Байта |= чБайт << (16 - 2);
			чБайт = this._мб[уАдрес + 2];
			if (чБайт < 0x80)
			{
				ч4Байта |= чБайт << (8 - 1);
				чБайт = this._мб[уАдрес + 3];
				if (чБайт < 0x80)
				{
					чРезультат = ч4Байта | чБайт;
				}
			}
		}
	}
	return чРезультат;
};

//
// Срез
//

function Срез(кбСтруктураСемпла, уНачалоПотока, уКонецПотока, уНачалоСемплов, уКонецСемплов, чВДНачала)
// чВДНачала может быть дробным.
{
	Проверить(Number.isInteger(кбСтруктураСемпла) && кбСтруктураСемпла >= 0);
	Проверить(Number.isInteger(уНачалоПотока)  && Number.isInteger(уКонецПотока)  && уНачалоПотока  >= 0 && уНачалоПотока  <= уКонецПотока);
	Проверить(Number.isInteger(уНачалоСемплов) && Number.isInteger(уКонецСемплов) && уНачалоСемплов >= 0 && уНачалоСемплов <= уКонецСемплов);
	Проверить((кбСтруктураСемпла === 0 && уНачалоСемплов === 0 && уКонецСемплов === 0) || (уКонецСемплов - уНачалоСемплов) % кбСтруктураСемпла === 0);
	Проверить(чВДНачала >= -1);
	this.кбСтруктураСемпла = кбСтруктураСемпла;
	this.уНачалоПотока     = уНачалоПотока;
	this.уКонецПотока      = уКонецПотока;
	this.уНачалоСемплов    = уНачалоСемплов;
	this.уКонецСемплов     = уКонецСемплов;
	this.чВДНачала         = чВДНачала;
}

Срез.prototype.Пусто = function()
{
	Проверить(Number.isInteger(this.уНачалоПотока) && Number.isInteger(this.уКонецПотока) && this.уНачалоПотока >= 0 && this.уНачалоПотока <= this.уКонецПотока);
	return this.уКонецПотока === this.уНачалоПотока;
};

Срез.prototype.ПолучитьРазмерПотока = function()
{
	Проверить(Number.isInteger(this.уНачалоПотока) && Number.isInteger(this.уКонецПотока) && this.уНачалоПотока >= 0 && this.уНачалоПотока <= this.уКонецПотока);
	return this.уКонецПотока - this.уНачалоПотока;
};

Срез.prototype.ПолучитьРазмерСемплов = function()
{
	Проверить(Number.isInteger(this.уНачалоСемплов) && Number.isInteger(this.уКонецСемплов) && this.уНачалоСемплов >= 0 && this.уНачалоСемплов <= this.уКонецСемплов);
	Проверить((this.уКонецСемплов - this.уНачалоСемплов) % this.кбСтруктураСемпла === 0);
	return this.уКонецСемплов - this.уНачалоСемплов;
};

Срез.prototype.ПолучитьКоличествоСемплов = function()
{
	return this.ПолучитьРазмерСемплов() / this.кбСтруктураСемпла;
};

Срез.prototype.СложитьБеззнаковыйПараметр = function(чСмещениеПараметра, уДоСемпла, мбСемплы)
{
	Проверить(Number.isInteger(чСмещениеПараметра) && чСмещениеПараметра >= 0 && чСмещениеПараметра <= this.кбСтруктураСемпла - 4);
	Проверить(Number.isInteger(this.уНачалоСемплов) && Number.isInteger(this.уКонецСемплов) && this.уНачалоСемплов >= 0 && this.уНачалоСемплов <= this.уКонецСемплов);
	Проверить(Number.isInteger(уДоСемпла) && уДоСемпла >= this.уНачалоСемплов && уДоСемпла <= this.уКонецСемплов);
	Проверить((this.уКонецСемплов - this.уНачалоСемплов) % this.кбСтруктураСемпла === 0 && (уДоСемпла - this.уНачалоСемплов) % this.кбСтруктураСемпла === 0);
	var чПараметр = 0;
	for (var у = this.уНачалоСемплов; у !== уДоСемпла; у += this.кбСтруктураСемпла)
	{
		чПараметр += мбСемплы.ПрочестьБЦ32(у + чСмещениеПараметра);
	}
	return чПараметр;
};

Срез.prototype.Свернуть = function()
{
	Проверить(Number.isInteger(this.уНачалоПотока)  && this.уНачалоПотока  >= 0);
	Проверить(Number.isInteger(this.уНачалоСемплов) && this.уНачалоСемплов >= 0);
	this.уКонецПотока  = this.уНачалоПотока;
	this.уКонецСемплов = this.уНачалоСемплов;
	this.чВДНачала     = -1;
};

//
// СрезОбработки
//

function СрезОбработки(кбСтруктураСемпла, уНачалоПотока, уКонецПотока, уНачалоСемплов, уКонецСемплов, чВДНачала)
{
	Срез.apply(this, arguments);
	this.nContinuityCounter = -1;
	this.pPesPacketEnd      = -1;
}

СрезОбработки.prototype = Object.create(Срез.prototype);
СрезОбработки.prototype.constructor = СрезОбработки;

//
//

const м_Журнал = (function()
{
	var _мсВажность = [];
	var _мсЗаписи   = [];

	function Добавить(сВажность, сЗапись)
	{
		_мсВажность.push(сВажность);
		_мсЗаписи.push(`[Worker] ${сЗапись}`);
	}

	function Вот(сЗапись)
	{
		Добавить('Вот', сЗапись);
	}

	function Окак(сЗапись)
	{
		Добавить('Окак', сЗапись);
	}

	function Ой(сЗапись)
	{
		Добавить('Ой', сЗапись);
	}

	function Отправить()
	{
		if (_мсВажность.length !== 0)
		{
			postMessage([2, _мсВажность, _мсЗаписи]);
			_мсВажность.length = 0;
			_мсЗаписи.length   = 0;
		}
	}

	return {Вот, Окак, Ой, Отправить};
})();

const м_Балкон = (function()
{
	// TODO Можно заменить на массив и хранить все что выбрасывается, например в ВыделитьМассив().
	var _мбБарахло = null;

	function Положить(мбБарахло)
	{
		Проверить(!_мбБарахло);
		_мбБарахло = мбБарахло;
	}

	function Найти(кбРазмер)
	{
		var мбНайдено = null;
		if (_мбБарахло)
		{
			if (_мбБарахло.length >= кбРазмер)
			{
				м_Журнал.Вот(`Найдено барахло на ${_мбБарахло.length - кбРазмер} больше запрашиваемого ${кбРазмер}`);
				мбНайдено = _мбБарахло;
				_мбБарахло = null;
			}
			else
			{
				// Например различается количество или размер задержанных видеосемплов.
				м_Журнал.Окак(`Найдено барахло на ${кбРазмер - _мбБарахло.length} меньше запрашиваемого ${кбРазмер}`);
			}
		}
		return мбНайдено;
	}

	function Освободить()
	{
		if (_мбБарахло)
		{
			ВыброситьВПомойку(_мбБарахло);
			_мбБарахло = null;
		}
	}

	return {Положить, Найти, Освободить};
})();

(function()
{
	/***
	ПАРАМЕТРЫ ПОСЛЕДОВАТЕЛЬНОСТИ

	НУЖНЫ ВСЕМ СЕГМЕНТАМ
	лЕстьВидео
	лЕстьЗвук
	чЧастотаДискретизации

	НУЖНЫ ТОЛЬКО ПЕРВОМУ СЕГМЕНТУ
	abSequenceParameterSet
	abPictureParameterSet
	abSequenceParameterSetExt
	чШиринаКартинки
	чВысотаКартинки
	nProfileIndication
	nConstraintSetFlag
	nLevelIndication
	nChromaFormatIndication
	nBitDepthLumaMinus8
	nBitDepthChromaMinus8
	nMaxNumberReferenceFrames
	чДиапазон
	лЧересстрочное
	чЧастотаКадров
	aDecoderSpecificInfo
	nAudioObjectType
	чКоличествоКаналов
	***/

	const РАЗМЕР_ТРАНСПОРТНОГО_ПАКЕТА          = 188;
	const TS_TIMESCALE                         = 90000;
	const ДЛИНА_АУДИОСЕМПЛА                    = 1024;
	const ЧАСТОТА_ДЕСКРИТЕЗАЦИИ                = [96000, 88200, 64000, 48000, 44100, 32000, 24000, 22050, 16000, 12000, 11025, 8000, 7350];

	const НОМЕР_ВИДЕО_ДОРОЖКИ                  = 1;
	const НОМЕР_АУДИО_ДОРОЖКИ                  = 2;
	const РАЗМЕР_СТРУКТУРЫ_АУДИОСЕМПЛА         = 1 * 4; // sample_size
	const РАЗМЕР_СТРУКТУРЫ_ВИДЕОСЕМПЛА         = 4 * 4;
	const ДЛИТЕЛЬНОСТЬ_ВИДЕОСЕМПЛА             = 0;     // sample_duration
	const РАЗМЕР_ВИДЕОСЕМПЛА                   = 4;     // sample_size
	const ФЛАГИ_ВИДЕОСЕМПЛА                    = 8;     // sample_flags
	const ВП_ВИДЕОСЕМПЛА                       = 12;    // sample_composition_time_offset
	const ДЛИТЕЛЬНОСТЬ_ПРЕДЫДУЩЕГО_ВИДЕОСЕМПЛА = ДЛИТЕЛЬНОСТЬ_ВИДЕОСЕМПЛА - РАЗМЕР_СТРУКТУРЫ_ВИДЕОСЕМПЛА;

	//
	// Расчет размера буферов.
	//
	// Максимальная частота для чересстрочного видео в два раза меньше указанного.
	const МАКС_ЧАСТОТА_КАДРОВ               = 250;
	// Twitch: Как правило 2, очень редко 7.
	const МАКС_КОЛИЧЕСТВО_NAL_UNITS_В_КАДРЕ = 20;
	// Уменьшить количество изменений размера буфера. Частое выделение больших блоков нагибает процессор и повышает фрагментацию памяти.
	const ОПЕРЕЖАЮЩЕЕ_УВЕЛИЧЕНИЕ_ВИДЕО      = 1.3;
	const ОПЕРЕЖАЮЩЕЕ_УВЕЛИЧЕНИЕ_АУДИО      = 1.3;
	const ОПЕРЕЖАЮЩЕЕ_УВЕЛИЧЕНИЕ_СЕМПЛОВ    = 1.5;
	const ОПЕРЕЖАЮЩЕЕ_УВЕЛИЧЕНИЕ_МЕТАДАННЫХ = 2.0;

	// Исходный сегмент для преобразования.
	// Можно изменять только пДанные с типом ArrayBuffer.
	var _оИсходныйСегмент             = null;

	var _мбВидеоПоток                 = null;
	var _мбАудиоПоток                 = null;
	var _мбМетаданные                 = null;
	var _мбВидеоСемплы                = null;
	var _мбАудиоСемплы                = null;

	var _лРазрыв                      = true;
	var _оПараметры                   = null;
	const _срОбрабатываемоеВидео      = new СрезОбработки(РАЗМЕР_СТРУКТУРЫ_ВИДЕОСЕМПЛА, 0, 0, 0, 0, -1);
	const _срОбрабатываемоеАудио      = new СрезОбработки(РАЗМЕР_СТРУКТУРЫ_АУДИОСЕМПЛА, 0, 0, 0, 0, -1);
	const _срОбрабатываемыеМетаданные = new СрезОбработки(0, 0, 0, 0, 0, 0);
	const _срПустойАудиоСрез          = new Срез(РАЗМЕР_СТРУКТУРЫ_АУДИОСЕМПЛА, 0, 0, 0, 0, -1);

	var _лЗадержанРазрыв              = false;
	var _оЗадержанныеПараметры        = null;
	const _срЗадержанноеВидео         = new Срез(РАЗМЕР_СТРУКТУРЫ_ВИДЕОСЕМПЛА, 0, 0, 0, 0, -1);
	const _срЗадержанноеАудио         = new Срез(РАЗМЕР_СТРУКТУРЫ_АУДИОСЕМПЛА, 0, 0, 0, 0, -1);

	var _уПотокПоследнегоКадра;       // Обрабатываемое видео.
	var _уСемплПоследнегоКадра;       // Обрабатываемое видео.
	var _уПотокПоследнегоКлючКадра;   // Обрабатываемое видео.
	var _уСемплПоследнегоКлючКадра;   // Обрабатываемое видео.
	
	var _чВДПоследнегоВидеоСемпла;    // Обработанное или задержанное видео.
	var _чВДКонцаАудиоСегмента;       // Обработанное или задержанное аудио.
	var _nPatVersion;
	var _nPmtVersion;

	//
	// Статистика сегмента. Очищается перед разбором очередного сегмента.
	//
	var _чПреобразованЗа = NaN;
	var _лЗабраковано;
	var _лПотериВидео;
	var _лПотериЗвука;
	var _чМинДлительностьВидеоСемпла;
	var _чМаксДлительностьВидеоСемпла;
	var _чСредняяДлительностьВидеоСемпла;
	var _чБитрейтЗвука;
	var _чВремяКодирования;
	var _чПозицияКодирования;
	var _чНомерОтправляемогоСегмента;

	function ОчиститьСтатистику()
	{
		_лЗабраковано                    = false;
		_лПотериВидео                    = false;
		_лПотериЗвука                    = false;
		_чМинДлительностьВидеоСемпла     = +Infinity;
		_чМаксДлительностьВидеоСемпла    = -Infinity;
		_чСредняяДлительностьВидеоСемпла = NaN;
		_чБитрейтЗвука                   = NaN;
		_чВремяКодирования               = NaN;
		_чПозицияКодирования             = NaN;
		_чНомерОтправляемогоСегмента     = 0;
	}

	function ОсвободитьПамять()
	{
		ВыброситьВПомойку(_мбВидеоПоток ); _мбВидеоПоток  = null;
		ВыброситьВПомойку(_мбАудиоПоток ); _мбАудиоПоток  = null;
		ВыброситьВПомойку(_мбМетаданные ); _мбМетаданные  = null;
		ВыброситьВПомойку(_мбВидеоСемплы); _мбВидеоСемплы = null;
		ВыброситьВПомойку(_мбАудиоСемплы); _мбАудиоСемплы = null;

		_оПараметры = null;
		_оЗадержанныеПараметры = null;

		м_Балкон.Освободить();
	}

	function ВыделитьМассив(мбМассив, кбЗаполнен, кбДолжноБытьСвободно, чДобавить, bAsmJS)
	// кбДолжноБытьСвободно может быть дробным.
	{
		var кбРазмер = Math.ceil(кбЗаполнен + кбДолжноБытьСвободно);
		if (мбМассив && мбМассив.length >= кбРазмер)
		{
			return мбМассив;
		}
		кбРазмер = Math.ceil(кбРазмер * чДобавить);
		if (bAsmJS)
		{
			кбРазмер = ОкруглитьРазмерКучиAsmJS(кбРазмер);
		}
		м_Журнал[мбМассив ? 'Окак' : 'Вот'](`Увеличиваю массив с ${мбМассив ? мбМассив.length : 0} до ${кбРазмер}`);
		var мбНовыйМассив = new Uint8Array(кбРазмер);
		if (кбЗаполнен !== 0)
		{
			мбНовыйМассив.Копировать(0, мбМассив, 0, кбЗаполнен);
		}
		ВыброситьВПомойку(мбМассив);
		return мбНовыйМассив;
	}

	function ВыделитьПамять(кбРазмерСегмента, чДлительностьСегмента)
	{
		Проверить(_срЗадержанноеВидео.уНачалоПотока  === 0 && _срЗадержанноеАудио.уНачалоПотока  === 0);
		Проверить(_срЗадержанноеВидео.уНачалоСемплов === 0 && _срЗадержанноеАудио.уНачалоСемплов === 0);

		// Реальная длительность может быть выше, например если отброшена дробная часть.
		чДлительностьСегмента += 2;

		var кКадров = Math.ceil(МАКС_ЧАСТОТА_КАДРОВ * чДлительностьСегмента);
		// Оставляем свободное место перед обрабатываемым потоком, потому что во время декодирования каждый 3-байтовый
		// start code prefix станет 4-байтовой длиной, что приведет к небольшому увеличению размера.
		var кбРезерв = кКадров * МАКС_КОЛИЧЕСТВО_NAL_UNITS_В_КАДРЕ;
		var кбВидеоПоток  = кбРазмерСегмента + кбРезерв;
		var кбАудиоПоток  = кбРазмерСегмента;
		var кбВидеоСемплы = РАЗМЕР_СТРУКТУРЫ_ВИДЕОСЕМПЛА * кКадров;
		var кбАудиоСемплы = РАЗМЕР_СТРУКТУРЫ_АУДИОСЕМПЛА * ЧАСТОТА_ДЕСКРИТЕЗАЦИИ[0] / ДЛИНА_АУДИОСЕМПЛА * чДлительностьСегмента;

		_мбВидеоПоток  = ВыделитьМассив(_мбВидеоПоток,  _срЗадержанноеВидео.уКонецПотока,  кбВидеоПоток,  ОПЕРЕЖАЮЩЕЕ_УВЕЛИЧЕНИЕ_ВИДЕО,   false);
		_мбАудиоПоток  = ВыделитьМассив(_мбАудиоПоток,  _срЗадержанноеАудио.уКонецПотока,  кбАудиоПоток,  ОПЕРЕЖАЮЩЕЕ_УВЕЛИЧЕНИЕ_АУДИО,   false);
		_мбВидеоСемплы = ВыделитьМассив(_мбВидеоСемплы, _срЗадержанноеВидео.уКонецСемплов, кбВидеоСемплы, ОПЕРЕЖАЮЩЕЕ_УВЕЛИЧЕНИЕ_СЕМПЛОВ, false);
		_мбАудиоСемплы = ВыделитьМассив(_мбАудиоСемплы, _срЗадержанноеАудио.уКонецСемплов, кбАудиоСемплы, ОПЕРЕЖАЮЩЕЕ_УВЕЛИЧЕНИЕ_СЕМПЛОВ, false);

		// Создан новый массив?
		if (typeof _мбВидеоПоток.НайтиПрефикс === 'undefined')
		{
			_мбВидеоПоток.НайтиПрефикс = AsmJS(self, null, _мбВидеоПоток.buffer).SearchStartCodePrefix;
		}

		_срОбрабатываемоеВидео.уНачалоПотока  = _срЗадержанноеВидео.уКонецПотока + кбРезерв;
		_срОбрабатываемоеВидео.уНачалоСемплов = _срЗадержанноеВидео.уКонецСемплов;
		_срОбрабатываемоеВидео.Свернуть();

		_срОбрабатываемоеАудио.уНачалоПотока  = _срЗадержанноеАудио.уКонецПотока;
		_срОбрабатываемоеАудио.уНачалоСемплов = _срЗадержанноеАудио.уКонецСемплов;
		_срОбрабатываемоеАудио.Свернуть();

		_срОбрабатываемыеМетаданные.уКонецПотока = _срОбрабатываемыеМетаданные.уНачалоПотока;
	}

	function РазобратьТранспортныйПоток(мбТранспортныйПоток)
	{
		Проверить(_срОбрабатываемоеВидео.уКонецПотока === _срОбрабатываемоеВидео.уНачалоПотока && _срОбрабатываемоеВидео.уКонецСемплов === _срОбрабатываемоеВидео.уНачалоСемплов && _срОбрабатываемоеВидео.чВДНачала === -1);
		Проверить(_срОбрабатываемоеАудио.уКонецПотока === _срОбрабатываемоеАудио.уНачалоПотока && _срОбрабатываемоеАудио.уКонецСемплов === _срОбрабатываемоеАудио.уНачалоСемплов && _срОбрабатываемоеАудио.чВДНачала === -1);
		Проверить(_срОбрабатываемыеМетаданные.чВДНачала !== -1); // Не извлекать из транспортного потока DTS и PTS.
		Браковать(мбТранспортныйПоток.length !== 0 && мбТранспортныйПоток.length % РАЗМЕР_ТРАНСПОРТНОГО_ПАКЕТА === 0);

		var cPat = 0, nProgramNumber = -1, nPmtPid = -1;
		var cPmt = 0, nVideoPid = -1, nAudioPid = -1, nMetadataPid = -1;
		var чВДПоследнегоВидеоСемпла = -1;
		var сМетаданные = '';
		var кИзмененийВД = 0; // Статистика.

		_срОбрабатываемоеВидео.pPesPacketEnd = _срОбрабатываемоеАудио.pPesPacketEnd = _срОбрабатываемыеМетаданные.pPesPacketEnd = -1;

		if (_лРазрыв)
		{
			_срОбрабатываемоеВидео.nContinuityCounter = _срОбрабатываемоеАудио.nContinuityCounter = _срОбрабатываемыеМетаданные.nContinuityCounter = -1;
			_nPatVersion = _nPmtVersion = -1;
		}

		for (var уКонецТранспортногоПотока = мбТранспортныйПоток.length,
			уТранспортныйПакет = 0;
			уТранспортныйПакет !== уКонецТранспортногоПотока;
			уТранспортныйПакет += РАЗМЕР_ТРАНСПОРТНОГО_ПАКЕТА)
		{
			var чЗаголовокТранспортногоПакета = мбТранспортныйПоток.ПрочестьБЦ32(уТранспортныйПакет);
			Браковать((чЗаголовокТранспортногоПакета & 0xFF8000C0) === 0x47000000); // sync_byte == 0x47, transport_error_indicator == 0, transport_scrambling_control == 0
			var nPid = (чЗаголовокТранспортногоПакета & 0x001FFF00) >> 8; // pid
			var pPayload = уТранспортныйПакет + 4;

			if ((чЗаголовокТранспортногоПакета & 0x00000020) !== 0) // adaptation_field
			{
				var cbAdaptationField = мбТранспортныйПоток[pPayload]; // adaptation_field_length
				Проверить(cbAdaptationField <= РАЗМЕР_ТРАНСПОРТНОГО_ПАКЕТА - 5);
				Проверить(cbAdaptationField === 0 || (мбТранспортныйПоток[pPayload + 1] & 0x80) === 0); // discontinuity_indicator
				pPayload += 1 + cbAdaptationField;
			}

			switch (nPid)
			{
			case nVideoPid:
				if ((чЗаголовокТранспортногоПакета & 0x00400000) !== 0) // payload_unit_start_indicator
				{
					Проверить((мбТранспортныйПоток.ПрочестьБЦ32(pPayload) & 0xFFFFFFF0) === 0x000001E0); // packet_start_code_prefix, stream_id == video
				}
				var мбПоток = _мбВидеоПоток;
				var срОбработать = _срОбрабатываемоеВидео;
				break;

			case nAudioPid:
				if ((чЗаголовокТранспортногоПакета & 0x00400000) !== 0) // payload_unit_start_indicator
				{
					Проверить((мбТранспортныйПоток.ПрочестьБЦ32(pPayload) & 0xFFFFFFE0) === 0x000001C0); // packet_start_code_prefix, stream_id == audio
				}
				var мбПоток = _мбАудиоПоток;
				var срОбработать = _срОбрабатываемоеАудио;
				break;

			case nMetadataPid:
				if ((чЗаголовокТранспортногоПакета & 0x00400000) !== 0) // payload_unit_start_indicator
				{
					Проверить(мбТранспортныйПоток.ПрочестьБЦ32(pPayload) === 0x000001BD); // packet_start_code_prefix, stream_id == private_stream_1
					var кбРазмер = мбТранспортныйПоток.ПрочестьБЦ16(pPayload + 4); // pes_packet_length
					Проверить(кбРазмер !== 0); // pes_packet_length может быть нулевым только в видеопотоке.
					сМетаданные += кбРазмер + ' ';
					_мбМетаданные = ВыделитьМассив(_мбМетаданные, 0, кбРазмер, ОПЕРЕЖАЮЩЕЕ_УВЕЛИЧЕНИЕ_МЕТАДАННЫХ, false);
					// Twitch: Перед основным PES-пакетом с метаданными может идти рекламный, который разбирать не нужно.
					_срОбрабатываемыеМетаданные.уКонецПотока = _срОбрабатываемыеМетаданные.уНачалоПотока;
					_срОбрабатываемыеМетаданные.pPesPacketEnd = -1;
				}
				var мбПоток = _мбМетаданные;
				var срОбработать = _срОбрабатываемыеМетаданные;
				break;

			case 0:
				++cPat;
				Проверить((чЗаголовокТранспортногоПакета & 0x00400010) === 0x00400010); // payload_unit_start_indicator | payload
				var о = ParseProgramAssociationTable(мбТранспортныйПоток, pPayload, уТранспортныйПакет + РАЗМЕР_ТРАНСПОРТНОГО_ПАКЕТА);
				if (_nPatVersion === -1)
				{
					_nPatVersion = о.nPatVersion;
				}
				else
				{
					Проверить(_nPatVersion === о.nPatVersion);
				}
				if (cPat === 1)
				{
					nProgramNumber = о.nProgramNumber; nPmtPid = о.nPmtPid;
				}
				else
				{
					// TODO Разбирать только первую таблицу в сегменте, у остальных только проверять версию?
					Проверить(nProgramNumber === о.nProgramNumber && nPmtPid === о.nPmtPid);
				}
				continue;

			case nPmtPid:
				++cPmt;
				Проверить((чЗаголовокТранспортногоПакета & 0x00400010) === 0x00400010); // payload_unit_start_indicator | payload
				var о = ParseProgramMapTable(мбТранспортныйПоток, pPayload, уТранспортныйПакет + РАЗМЕР_ТРАНСПОРТНОГО_ПАКЕТА, nProgramNumber);
				if (_nPmtVersion === -1)
				{
					_nPmtVersion = о.nPmtVersion;
				}
				else
				{
					Проверить(_nPmtVersion === о.nPmtVersion);
				}
				if (cPmt === 1)
				{
					nVideoPid = о.nVideoPid; nAudioPid = о.nAudioPid; nMetadataPid = о.nMetadataPid;
				}
				else
				{
					// TODO Разбирать только первую таблицу в сегменте, у остальных только проверять версию?
					Проверить(nVideoPid === о.nVideoPid && nAudioPid === о.nAudioPid && nMetadataPid === о.nMetadataPid);
				}
				continue;

			default:
				// Таких пакетов очень мало.
				continue;
			}

			if (срОбработать.nContinuityCounter !== (чЗаголовокТранспортногоПакета & 0x0000000F) && срОбработать.nContinuityCounter !== -1) // continuity_counter
			{
				м_Журнал.Ой(`continuity_counter равен ${чЗаголовокТранспортногоПакета & 0x0000000F} вместо ${срОбработать.nContinuityCounter} PID=${nPid}`);
				// Первый транспортный пакет с этим PID в сегменте?
				// TODO Добавлять разрыв если пакет первый? Браковать сегмент в остальных случаях.
				// TODO По стандарту возможна одна копия пакета с тем же continuity_counter.
				// TODO Перенести сюда проверку discontinuity_indicator.
				Проверить(срОбработать.уКонецПотока === срОбработать.уНачалоПотока);
			}
			срОбработать.nContinuityCounter = (чЗаголовокТранспортногоПакета + 1) & 0x0000000F;

			switch (чЗаголовокТранспортногоПакета & 0x00400010)
			{
			case 0x00000010: // payload
				// PES-пакет должен целиком находится в одном сегменте. Проверка учитывает, что "внутри"
				// PES-пакета могут находится транспортные пакеты с другим PID, например PAT и PMT.
				Проверить(срОбработать.уКонецПотока !== срОбработать.уНачалоПотока);
				break;

			case 0x00400010: // payload_unit_start_indicator | payload
				// Проверка длины последнего PES-пакета находится сразу после цикла ниже.
				Проверить(срОбработать.pPesPacketEnd === срОбработать.уКонецПотока || срОбработать.pPesPacketEnd === -1);
				var cbPesPacket = мбТранспортныйПоток.ПрочестьБЦ16(pPayload + 4); // PES_packet_length
				var cbPesHeader = мбТранспортныйПоток[pPayload + 8]; // pes_header_data_length
				if (cbPesPacket !== 0)
				{
					срОбработать.pPesPacketEnd = срОбработать.уКонецПотока + cbPesPacket - 3 - cbPesHeader;
				}
				else
				{
					// ITU-T H.222.0:2012 2.4.3.7 Semantic definition of fields in PES packet:
					// A value of 0 indicates that the PES packet length is neither specified nor bounded and is allowed only in PES
					// packets whose payload consists of bytes from a video elementary stream contained in transport stream packets.
					Проверить(nPid === nVideoPid);
					срОбработать.pPesPacketEnd = -1;
				}

				if (nPid === nVideoPid || срОбработать.чВДНачала === -1)
				{
					switch (мбТранспортныйПоток.ПрочестьБЦ16(pPayload + 6) & 0xF0C0)
					{
					case 0x8080: // marker bits == 2, pes_scrambling_control == 0, pts_dts_flags == pts
						Проверить(cbPesHeader >= 5);
						var nPts = DecodeTimestamp(мбТранспортныйПоток, pPayload + 9, 0x21);
						var nDts = nPts;
						break;

					case 0x80C0: // marker bits == 2, pes_scrambling_control == 0, pts_dts_flags == pts + dts
						Проверить(cbPesHeader >= 10);
						var nPts = DecodeTimestamp(мбТранспортныйПоток, pPayload + 9, 0x31);
						var nDts = DecodeTimestamp(мбТранспортныйПоток, pPayload + 14, 0x11);
						break;

					default:
						Проверить(false);
					}
					if (срОбработать.чВДНачала === -1)
					{
						срОбработать.чВДНачала = nDts;
					}
					if (nPid === nVideoPid)
					{
						// Если DTS не изменился, то это продолжение предыдущего PES-пакета. Так делают когда размер не умещается в 16 бит pes_packet_length.
						// Twitch: pes_packet_length в видеопотоке равен 0, PES-пакеты на части не разбиваются.
						if (nDts === чВДПоследнегоВидеоСемпла && cbPesPacket !== 0)
						{
							Проверить((мбТранспортныйПоток[pPayload + 6] & 0x04) === 0); // data_alignment_indicator
						}
						else
						{
							if (чВДПоследнегоВидеоСемпла !== -1)
							{
								var чДлительностьВидеоСемпла = nDts - чВДПоследнегоВидеоСемпла;
								// Иногда по ошибке DTS разных семплов равны. Стандарт запрещает нулевую длительность семплов и наличие нескольких
								// access unit в одном семпле. В последнем случае Chrome 63 без аппаратного декодирования показывает артефакты (видимо
								// декодируется только последний access unit). Теоретически могут возникнуть проблемы, если в одном семпле объединены
								// ключевые и обычные кадры. Решение простое: добавить 1 к DTS.
								if (чДлительностьВидеоСемпла <= 0)
								{
									if (чДлительностьВидеоСемпла > -10)
									{
										чДлительностьВидеоСемпла = 1;
										nDts = чВДПоследнегоВидеоСемпла + чДлительностьВидеоСемпла;
										++кИзмененийВД;
									}
									else
									{
										Проверить(чВДПоследнегоВидеоСемпла > 0x200000000 - TS_TIMESCALE * 60);
										// Время трансляции превысило 33 бита.
										// TODO Добавлять 0x200000000 к ВД.
										Браковать(false);
									}
								}
								Проверить(чДлительностьВидеоСемпла < TS_TIMESCALE * 60 * 10);
								_чМинДлительностьВидеоСемпла  = Math.min(_чМинДлительностьВидеоСемпла,  чДлительностьВидеоСемпла);
								_чМаксДлительностьВидеоСемпла = Math.max(_чМаксДлительностьВидеоСемпла, чДлительностьВидеоСемпла);
								_мбВидеоСемплы.ЗаписатьБЦ32(_срОбрабатываемоеВидео.уКонецСемплов + ДЛИТЕЛЬНОСТЬ_ПРЕДЫДУЩЕГО_ВИДЕОСЕМПЛА, чДлительностьВидеоСемпла);
								// В РазобратьВидеоПоток() указатель будет заменен на размер.
								_мбВидеоСемплы.ЗаписатьБЦ32(_срОбрабатываемоеВидео.уКонецСемплов + РАЗМЕР_ВИДЕОСЕМПЛА, _срОбрабатываемоеВидео.уКонецПотока);
							}
							_мбВидеоСемплы.ЗаписатьЗЦ32(_срОбрабатываемоеВидео.уКонецСемплов + ВП_ВИДЕОСЕМПЛА, nPts - nDts);
							_срОбрабатываемоеВидео.уКонецСемплов += РАЗМЕР_СТРУКТУРЫ_ВИДЕОСЕМПЛА;
							чВДПоследнегоВидеоСемпла = nDts;
						}
					}
					else
					{
						// ITU-T H.222.0:2012 2.4.3.7 Semantic definition of fields in PES packet:
						// The presentation time shall be equal to the decoding time for audio access units.
						Проверить(nPts === nDts);
					}
				}
				pPayload += 9 + cbPesHeader;
				break;

			default:
				Проверить(false);
			}

			var cbPayload = уТранспортныйПакет + РАЗМЕР_ТРАНСПОРТНОГО_ПАКЕТА - pPayload;
			Проверить(cbPayload > 0); // Ошибка в adaptation_field_length или pes_header_data_length?
			// Большую часть времени функция выполняет это копирование.
			мбПоток.Копировать(срОбработать.уКонецПотока, мбТранспортныйПоток, pPayload, pPayload + cbPayload);
			срОбработать.уКонецПотока += cbPayload;
		}

		Проверить(_срОбрабатываемоеВидео     .pPesPacketEnd === _срОбрабатываемоеВидео     .уКонецПотока || _срОбрабатываемоеВидео     .pPesPacketEnd === -1);
		Проверить(_срОбрабатываемоеАудио     .pPesPacketEnd === _срОбрабатываемоеАудио     .уКонецПотока || _срОбрабатываемоеАудио     .pPesPacketEnd === -1);
		Проверить(_срОбрабатываемыеМетаданные.pPesPacketEnd === _срОбрабатываемыеМетаданные.уКонецПотока || _срОбрабатываемыеМетаданные.pPesPacketEnd === -1);

		if (cPat !== 1 || cPmt !== 1)
		{
			м_Журнал.Ой(`Количество таблиц в сегменте: PAT=${cPat} PMT=${cPmt}`);
		}

		// Twitch: Бывают сегменты только с PAT, PMT и ID3.
		_лПотериВидео = _срОбрабатываемоеВидео.Пусто();
		_лПотериЗвука = _срОбрабатываемоеАудио.Пусто();
		if (_лПотериВидео || _лПотериЗвука)
		{
			м_Журнал.Ой(`Сегмент не годится для воспроизведения: нет видео ${_лПотериВидео}, нет звука ${_лПотериЗвука}`);
			return false;
		}

		if (кИзмененийВД !== 0)
		{
			м_Журнал.Ой(`Количество видеосемплов с увеличенным ВД: ${кИзмененийВД}`);
		}

		var кВидеоСемплов = _срОбрабатываемоеВидео.ПолучитьКоличествоСемплов();
		_чСредняяДлительностьВидеоСемпла = (чВДПоследнегоВидеоСемпла - _срОбрабатываемоеВидео.чВДНачала) / (кВидеоСемплов - 1);
		// Длительность последнего видеосемпла последовательности.
		чДлительностьВидеоСемпла = Number.isFinite(_чМинДлительностьВидеоСемпла) ? _чМинДлительностьВидеоСемпла : TS_TIMESCALE / МАКС_ЧАСТОТА_КАДРОВ;
		_мбВидеоСемплы.ЗаписатьБЦ32(_срОбрабатываемоеВидео.уКонецСемплов + ДЛИТЕЛЬНОСТЬ_ПРЕДЫДУЩЕГО_ВИДЕОСЕМПЛА, чДлительностьВидеоСемпла);

		м_Журнал.Вот(`ТранспортныхПакетов=${мбТранспортныйПоток.length / РАЗМЕР_ТРАНСПОРТНОГО_ПАКЕТА}`
			+ ` ВДПервогоВидеоСемпла=${_срОбрабатываемоеВидео.чВДНачала}`
			+ ` ВДПоследнегоВидеоСемпла=${чВДПоследнегоВидеоСемпла}`
			+ ` ВДПервогоАудиоСемпла=${_срОбрабатываемоеАудио.чВДНачала}`
			+ ` ВидеоСемплов=${кВидеоСемплов}`
			+ ` ДлительностьВидеоСегмента>${((чВДПоследнегоВидеоСемпла - _срОбрабатываемоеВидео.чВДНачала) / (TS_TIMESCALE / 1000)).toFixed(2)}мс`
			+ ` СредняяДлительностьВидеоСемпла=${(_чСредняяДлительностьВидеоСемпла / (TS_TIMESCALE / 1000)).toFixed(2)}мс(${(TS_TIMESCALE / _чСредняяДлительностьВидеоСемпла).toFixed(2)}к/с)`
			+ ` МаксДлительностьВидеоСемпла=${(      _чМаксДлительностьВидеоСемпла / (TS_TIMESCALE / 1000)).toFixed(2)}мс(${(TS_TIMESCALE /    _чМаксДлительностьВидеоСемпла).toFixed(2)}к/с)`
			+ ` МинДлительностьВидеоСемпла=${(        _чМинДлительностьВидеоСемпла / (TS_TIMESCALE / 1000)).toFixed(2)}мс(${(TS_TIMESCALE /     _чМинДлительностьВидеоСемпла).toFixed(2)}к/с)`
			+ ` Метаданные=${сМетаданные}`
		);

		if (!_лРазрыв)
		{
			var чОтклонениеВД = _срОбрабатываемоеАудио.чВДНачала - _чВДКонцаАудиоСегмента;
			if (Math.abs(чОтклонениеВД) > 2)
			{
				м_Журнал.Ой(`Отклонение ВД аудиосегмента ${чОтклонениеВД}`);
			}
			if (чОтклонениеВД > TS_TIMESCALE / 1000 * 100)
			{
				_лПотериЗвука = true;
			}
			// Браузеры добавляют и воспроизводят такие сегменты, но с рассинхронизацией видео и звука.
			// Возможно, рассинхронизация сохранится до HTMLVideoElement.load(). Но это уже не мои проблемы.
			// TODO Время трансляции превысило 33 бита.
			Проверить(чОтклонениеВД > -TS_TIMESCALE * _оИсходныйСегмент.чДлительность * 2);
		}

		if (!_лРазрыв && !_срЗадержанноеВидео.Пусто())
		{
			// Длительность последнего видеосемпла задержанного сегмента.
			чДлительностьВидеоСемпла = _срОбрабатываемоеВидео.чВДНачала - _чВДПоследнегоВидеоСемпла;
			м_Журнал.Вот(`Длительность последнего задержанного видеосемпла ${(чДлительностьВидеоСемпла / (TS_TIMESCALE / 1000)).toFixed(2)}мс`);
			// TODO Время трансляции превысило 33 бита.
			Проверить(чДлительностьВидеоСемпла > 0);
			_мбВидеоСемплы.ЗаписатьБЦ32(_срЗадержанноеВидео.уКонецСемплов + ДЛИТЕЛЬНОСТЬ_ПРЕДЫДУЩЕГО_ВИДЕОСЕМПЛА, чДлительностьВидеоСемпла);
			// Добавляем последний видеосемпл задержанного сегмента к статистике.
			_чСредняяДлительностьВидеоСемпла = (чВДПоследнегоВидеоСемпла - _чВДПоследнегоВидеоСемпла) / кВидеоСемплов;
			_чМинДлительностьВидеоСемпла  = Math.min(_чМинДлительностьВидеоСемпла,  чДлительностьВидеоСемпла);
			_чМаксДлительностьВидеоСемпла = Math.max(_чМаксДлительностьВидеоСемпла, чДлительностьВидеоСемпла);
		}

		_чВДПоследнегоВидеоСемпла = чВДПоследнегоВидеоСемпла;
		_чПозицияКодирования = Math.min(_срОбрабатываемоеВидео.чВДНачала, _срОбрабатываемоеАудио.чВДНачала) / TS_TIMESCALE;
		return true;
	}

	function DecodeTimestamp(мбТранспортныйПоток, уАдрес, nMarkerBits)
	// Timestamp занимает 33 бита. Спасибо что не 54.
	{
		var ч1 = мбТранспортныйПоток[уАдрес]|0;
		var ч2 = мбТранспортныйПоток.ПрочестьБЦ32(уАдрес + 1)|0;
		Проверить((ч1 & 0xF1) === (nMarkerBits|0) && (ч2 & 0x00010001) === 0x00010001);
		return +((ч1 & 0x0E) * (1 << 29) + (((ч2 >> 2) & 0x3FFF8000) | ((ч2 >> 1) & 0x00007FFF)));
	}

	function ParseProgramAssociationTable(мбТранспортныйПоток, уНачало, уКонец)
	// ITU-T H.222.0:2012 2.4.4.1 Pointer
	// ITU-T H.222.0:2012 2.4.4.3 Program association table
	{
		Проверить(уНачало < уКонец);
		уНачало += 1 + мбТранспортныйПоток[уНачало]; // pointer_field
		Проверить(уКонец - уНачало >= 16); // Ошибка в pointer_field?
		Проверить(мбТранспортныйПоток[уНачало] === 0); // table_id == program_association_section
		Проверить((мбТранспортныйПоток.ПрочестьБЦ16(уНачало + 1) & 0xCFFF) === 0x800D); // section_syntax_indicator == 1, '0' == 0, section_length == 13
		Проверить((мбТранспортныйПоток[уНачало + 5] & 1) === 1); // current_next_indicator == 1
		var nPatVersion = мбТранспортныйПоток[уНачало + 5] & 0x3E;
		Проверить(мбТранспортныйПоток[уНачало + 6] === 0); // section_number == 0
		Проверить(мбТранспортныйПоток[уНачало + 7] === 0); // last_section_number == 0
		var nProgramNumber = мбТранспортныйПоток.ПрочестьБЦ16(уНачало + 8); // program_number
		Проверить(nProgramNumber !== 0);
		var nPmtPid = мбТранспортныйПоток.ПрочестьБЦ16(уНачало + 10) & 0x1FFF; // program_map_pid
		Проверить(nPmtPid >= 0x0010 && nPmtPid <= 0x1FFE);

		if (_лРазрыв)
		{
			м_Журнал.Вот(`PatVersion=${nPatVersion} ProgramNumber=${nProgramNumber} PmtPid=${nPmtPid}`);
		}

		return {nPatVersion, nProgramNumber, nPmtPid};
	}

	function ParseProgramMapTable(мбТранспортныйПоток, уНачало, уКонец, nProgramNumber)
	// ITU-T H.222.0:2012 2.4.4.1 Pointer
	// ITU-T H.222.0:2012 2.4.4.8 Program map table
	{
		Проверить(уНачало < уКонец);
		уНачало += 1 + мбТранспортныйПоток[уНачало]; // pointer_field
		Проверить(уКонец - уНачало >= 12); // Ошибка в pointer_field?
		Проверить(мбТранспортныйПоток[уНачало] === 2); // table_id == ts_program_map_section
		var уКонецСекции = мбТранспортныйПоток.ПрочестьБЦ16(уНачало + 1); // section_length
		Проверить((уКонецСекции & 0xC000) === 0x8000); // section_syntax_indicator == 1, '0' == 0
		уКонецСекции = уНачало + 3 + (уКонецСекции & 0x0FFF) - 4; // offsetof(program_number) + section_length - sizeof(crc_32)
		Проверить(уКонецСекции >= уНачало + 12 && уКонецСекции + 4 <= уКонец); // Ошибка в section_length?
		Проверить(мбТранспортныйПоток.ПрочестьБЦ16(уНачало + 3) === nProgramNumber); // program_number
		Проверить((мбТранспортныйПоток[уНачало + 5] & 1) === 1); // current_next_indicator == 1
		var nPmtVersion = мбТранспортныйПоток[уНачало + 5] & 0x3E;
		Проверить(мбТранспортныйПоток[уНачало + 6] === 0); // section_number == 0
		Проверить(мбТранспортныйПоток[уНачало + 7] === 0); // last_section_number == 0
		уНачало += 12 + (мбТранспортныйПоток.ПрочестьБЦ16(уНачало + 10) & 0x0FFF); // program_info_length
		var nVideoPid = -1, nAudioPid = -1, nMetadataPid = -1;
		for (; уНачало !== уКонецСекции; уНачало = pDescriptor + nEsInfoLength)
		{
			var pDescriptor = уНачало + 5;
			Проверить(pDescriptor <= уКонецСекции); // Ошибка в program_info_length или es_info_length?
			var nElementaryPid = мбТранспортныйПоток.ПрочестьБЦ16(уНачало + 1) & 0x1FFF; // elementary_pid
			Проверить(nElementaryPid >= 0x0010 && nElementaryPid <= 0x1FFE);
			var nEsInfoLength = мбТранспортныйПоток.ПрочестьБЦ16(уНачало + 3) & 0x0FFF; // es_info_length
			Проверить(pDescriptor + nEsInfoLength <= уКонецСекции);
			switch (мбТранспортныйПоток[уНачало]) // stream_type
			{
			case 0x1B: // AVC
				if (nVideoPid === -1)
				{
					nVideoPid = nElementaryPid;
				}
				else
				{
					м_Журнал.Ой(`Найден дополнительный видеопоток PID=${nElementaryPid}`);
				}
				break;

			case 0x0F: // ADTS
				if (nAudioPid === -1)
				{
					nAudioPid = nElementaryPid;
				}
				else
				{
					м_Журнал.Ой(`Найден дополнительный аудиопоток PID=${nElementaryPid}`);
				}
				break;

			case 0x15: // metadata
				// ITU-T H.222.0:2012 2.6.60 Metadata descriptor
				if (nEsInfoLength === 15
				&& мбТранспортныйПоток[pDescriptor     ] === 38   // descriptor_tag == metadata_descriptor
				&& мбТранспортныйПоток[pDescriptor +  1] === 13   // descriptor_length
				&& мбТранспортныйПоток[pDescriptor +  2] === 0xFF // metadata_application_format
				&& мбТранспортныйПоток[pDescriptor +  3] === 0xFF // metadata_application_format
				&& мбТранспортныйПоток[pDescriptor +  4] === 0x49 // metadata_application_format_identifier[0] == 'I'
				&& мбТранспортныйПоток[pDescriptor +  5] === 0x44 // metadata_application_format_identifier[1] == 'D'
				&& мбТранспортныйПоток[pDescriptor +  6] === 0x33 // metadata_application_format_identifier[2] == '3'
				&& мбТранспортныйПоток[pDescriptor +  7] === 0x20 // metadata_application_format_identifier[3] == ' '
				&& мбТранспортныйПоток[pDescriptor +  8] === 0xFF // metadata_format
				&& мбТранспортныйПоток[pDescriptor +  9] === 0x49 // metadata_format_identifier[0] == 'I'
				&& мбТранспортныйПоток[pDescriptor + 10] === 0x44 // metadata_format_identifier[1] == 'D'
				&& мбТранспортныйПоток[pDescriptor + 11] === 0x33 // metadata_format_identifier[2] == '3'
				&& мбТранспортныйПоток[pDescriptor + 12] === 0x20 // metadata_format_identifier[3] == ' '
				&& мбТранспортныйПоток[pDescriptor + 13] === 0)   // metadata_service_id
				{
					if (nMetadataPid === -1)
					{
						nMetadataPid = nElementaryPid;
					}
					else
					{
						м_Журнал.Ой(`Найдены дополнительные метаданные PID=${nElementaryPid}`);
					}
				}
				break;
			}
		}

		if (_лРазрыв)
		{
			м_Журнал.Вот(`PmtVersion=${nPmtVersion} VideoPid=${nVideoPid} AudioPid=${nAudioPid} MetadataPid=${nMetadataPid}`);
		}

		if (nVideoPid === -1 || nAudioPid === -1)
		{
			ЗавершитьРаботуИПоказатьСообщение('J0207');
		}

		return {nPmtVersion, nVideoPid, nAudioPid, nMetadataPid};
	}

	function РазобратьМетаданные()
	{
		if (!_срОбрабатываемыеМетаданные.Пусто())
		{
			var oID3 = new ID3(_мбМетаданные, _срОбрабатываемыеМетаданные.уНачалоПотока, _срОбрабатываемыеМетаданные.уКонецПотока);
			for (var сИдентификаторПоля; сИдентификаторПоля = oID3.ПолучитьСледующееПоле();)
			{
				if (сИдентификаторПоля === 'TDEN')
				{
					var сВремя = oID3.ПолучитьПервоеТекстовоеЗначение();
					Проверить(сВремя !== null);
					// HACK ISO 8601 без часового пояса. Chrome 52 использует UTC, Firefox 48 - местное время.
					_чВремяКодирования = Date.parse(сВремя.length === 19 ? сВремя + 'Z' : сВремя);
					Проверить(!Number.isNaN(_чВремяКодирования));
					break;
				}
			}
		}
	}

	function РазобратьВидеоПоток()
	{
		const ФЛАГИ_ОБЫЧНОГО_КАДРА  = 0x00010000; // sample_is_non_sync_sample
		const ФЛАГИ_КЛЮЧЕВОГО_КАДРА = 0x00000000;

		Проверить(_срОбрабатываемоеВидео.уКонецПотока  !== _срОбрабатываемоеВидео.уНачалоПотока);
		Проверить(_срОбрабатываемоеВидео.уКонецСемплов !== _срОбрабатываемоеВидео.уНачалоСемплов);

		_уПотокПоследнегоКлючКадра = _уСемплПоследнегоКлючКадра = -1;
		_уСемплПоследнегоКадра = _срОбрабатываемоеВидео.уНачалоСемплов - РАЗМЕР_СТРУКТУРЫ_ВИДЕОСЕМПЛА;
		var уДекодированныйПоток = _срЗадержанноеВидео.уКонецПотока;
		var cNalUnits = 0, кКлючКадров = 0, кСемпловБезVCL = 0, cAccessUnits = 0, уСемплПервогоКлючКадра = -1; // Статистика.

		var уНачалоСледующегоСемпла = -1, чФлагиВидеосемпла;
		var pNalUnitEnd = _мбВидеоПоток.НайтиПрефикс(_срОбрабатываемоеВидео.уНачалоПотока, _срОбрабатываемоеВидео.уКонецПотока);
		Проверить(pNalUnitEnd !== -1);
		Браковать(pNalUnitEnd !== -2);
		Проверить(pNalUnitEnd === _срОбрабатываемоеВидео.уНачалоПотока);
		for (;;)
		{
			const кбРазмерПрефикса = pNalUnitEnd === _срОбрабатываемоеВидео.уКонецПотока ? 0 : _мбВидеоПоток[pNalUnitEnd] | (_мбВидеоПоток[pNalUnitEnd + 1] << 8);
			// Сегмент должен начинаться с первого nal unit в access unit.
			// ITU-T H.264:2014 B.1.1 Byte stream NAL unit syntax
			// У первого nal unit в access unit в префиксе должен быть zero_byte.
			Проверить(кбРазмерПрефикса !== 3 || уНачалоСледующегоСемпла !== -1);
			// nal unit может быть размазан по двум PES-пакетам. При определении, какому PES-пакету (а значит
			// и видеосемплу) пренадлежит nal unit, leading_zero_8bits и trailing_zero_8bits не учитываются.
			const лНачалоСемпла = pNalUnitEnd + кбРазмерПрефикса - Math.min(4, кбРазмерПрефикса) >= уНачалоСледующегоСемпла;

			// Окончание видеосемпла?
			if (лНачалоСемпла && уНачалоСледующегоСемпла !== -1)
			{
				// report://04654360436705_15093211313
				// Начало видеосемпла 0 длительностью 1мс
				// random_access_indicator = true
				// NAL units: 9, 7 (копия из видеосемпла 1), 8 (копия из видеосемпла 1), 6
				// Начало видеосемпла 1 длительностью 32мс
				// random_access_indicator = true
				// NAL units: 9, 7, 8, 5
				// Начало видеосемпла 2 длительностью 33мс
				// random_access_indicator = false
				// NAL units: 9, 1
				if (чФлагиВидеосемпла === -1)
				{
					// TODO На примере выше у семпла должны быть ФЛАГИ_КЛЮЧЕВОГО_КАДРА? Я не использую random_access_indicator.
					чФлагиВидеосемпла = ФЛАГИ_ОБЫЧНОГО_КАДРА;
					++кСемпловБезVCL;
				}
				Проверить(уДекодированныйПоток > _уПотокПоследнегоКадра);
				_мбВидеоСемплы.ЗаписатьБЦ32(_уСемплПоследнегоКадра + РАЗМЕР_ВИДЕОСЕМПЛА, уДекодированныйПоток - _уПотокПоследнегоКадра);
				_мбВидеоСемплы.ЗаписатьБЦ32(_уСемплПоследнегоКадра + ФЛАГИ_ВИДЕОСЕМПЛА, чФлагиВидеосемпла);
			}

			// Весь видеопоток разобран?
			if (pNalUnitEnd === _срОбрабатываемоеВидео.уКонецПотока)
			{
				Проверить(_уСемплПоследнегоКадра + РАЗМЕР_СТРУКТУРЫ_ВИДЕОСЕМПЛА === _срОбрабатываемоеВидео.уКонецСемплов);
				break;
			}

			const pNalUnitBegin = pNalUnitEnd + кбРазмерПрефикса;
			pNalUnitEnd = _мбВидеоПоток.НайтиПрефикс(pNalUnitBegin, _срОбрабатываемоеВидео.уКонецПотока);
			Проверить(pNalUnitEnd !== -1);
			Браковать(pNalUnitEnd !== -2);

			if (лНачалоСемпла)
			{
				_уСемплПоследнегоКадра += РАЗМЕР_СТРУКТУРЫ_ВИДЕОСЕМПЛА;
				Проверить(_уСемплПоследнегоКадра < _срОбрабатываемоеВидео.уКонецСемплов);
				уНачалоСледующегоСемпла = _уСемплПоследнегоКадра + РАЗМЕР_СТРУКТУРЫ_ВИДЕОСЕМПЛА === _срОбрабатываемоеВидео.уКонецСемплов
					? _срОбрабатываемоеВидео.уКонецПотока
					: _мбВидеоСемплы.ПрочестьБЦ32(_уСемплПоследнегоКадра + РАЗМЕР_СТРУКТУРЫ_ВИДЕОСЕМПЛА + РАЗМЕР_ВИДЕОСЕМПЛА);
				_уПотокПоследнегоКадра = уДекодированныйПоток;
				чФлагиВидеосемпла = -1;
				if (cAccessUnits === 1)
				{
					cAccessUnits = 0;
				}
			}

			// report://04345327250280_15079306647
			// Куча пустышек, которые не влияют на воспроизведение.
			if (pNalUnitBegin === pNalUnitEnd)
			{
				// Не сохранять в видеопотоке.
				continue;
			}
			++cNalUnits;


			const nNalRefIdc = _мбВидеоПоток[pNalUnitBegin] & 0xE0; // nal_ref_idc
			Браковать(nNalRefIdc < 0x80); // forbidden_zero_bit == 0

			// ISO 14496-15:2013 5.2 Table 2 NAL unit types in elementary streams
			switch (_мбВидеоПоток[pNalUnitBegin] & 0x1F) // nal_unit_type
			{
			case 1: // coded slice of a non-idr picture
			case 2:	// coded slice data partition a
			case 3:	// coded slice data partition b
			case 4:	// coded slice data partition c
				Проверить(чФлагиВидеосемпла !== ФЛАГИ_КЛЮЧЕВОГО_КАДРА);
				чФлагиВидеосемпла = ФЛАГИ_ОБЫЧНОГО_КАДРА;
				break;

			case 5: // coded slice of an idr picture
				// ISO 14496-15:2013 4.8 Sync sample (IDR)
				// HLS допускает отсутствие ключевого кадра в сегменте.
				// TODO Ключевой кадр также можно определить по random_access_indicator, но я не доверяю ПО, создающему транспортный поток.
				Проверить(nNalRefIdc !== 0);
				// Кадр может быть разбит на несколько slices.
				if (чФлагиВидеосемпла !== ФЛАГИ_КЛЮЧЕВОГО_КАДРА)
				{
					Проверить(чФлагиВидеосемпла !== ФЛАГИ_ОБЫЧНОГО_КАДРА);
					чФлагиВидеосемпла = ФЛАГИ_КЛЮЧЕВОГО_КАДРА;
					_уПотокПоследнегоКлючКадра = _уПотокПоследнегоКадра;
					_уСемплПоследнегоКлючКадра = _уСемплПоследнегоКадра;
					if (уСемплПервогоКлючКадра === -1)
					{
						уСемплПервогоКлючКадра = _уСемплПоследнегоКадра;
					}
					++кКлючКадров;
				}
				break;

			case 6: // supplemental enhancement information
				Проверить(nNalRefIdc === 0);
				break;

			case 7: // sequence parameter set
				// HLS допускает отсутствие SPS и PPS в сегменте.
				// Стандарт допускает наличие нескольких SPS с разными параметрами и одинаковым seq_parameter_set_id.
				// PS4: SPS и PPS есть в ключевых кадрах, а также в первом кадре сегмента, даже если он не является ключевым.
				// PS4: Иногда в одном acces unit вместо одной пары SPS + PPS идут подряд несколько пар. В них SPS отличаются
				// размером, значением constraint_set1_flag, значением level_idc, наличием vui_parameters, ...
				// Мы поддерживаем только один SPS, поэтому запоминаем последний.
				Проверить(nNalRefIdc !== 0);
				if (_лРазрыв && (_уСемплПоследнегоКлючКадра === -1 || typeof _оПараметры.abSequenceParameterSet === 'undefined'))
				{
					// Делаем копию.
					_оПараметры.abSequenceParameterSet = _мбВидеоПоток.slice(pNalUnitBegin, pNalUnitEnd);
				}
				// Не сохранять в видеопотоке.
				continue;

			case 8: // picture parameter set
				Проверить(nNalRefIdc !== 0);
				if (_лРазрыв && (_уСемплПоследнегоКлючКадра === -1 || typeof _оПараметры.abPictureParameterSet === 'undefined'))
				{
					// Делаем копию.
					_оПараметры.abPictureParameterSet = _мбВидеоПоток.slice(pNalUnitBegin, pNalUnitEnd);
				}
				// Не сохранять в видеопотоке.
				continue;

			case 9: // access unit delimiter
				Проверить(nNalRefIdc === 0);
				++cAccessUnits;
				// Не сохранять в видеопотоке.
				continue;

			case 10: // end of sequence
				Проверить(nNalRefIdc === 0);
				// Не сохранять в видеопотоке.
				continue;

			case 11: // end of stream
				Проверить(nNalRefIdc === 0);
				Проверить(false); // UNDONE
				// Не сохранять в видеопотоке.
				continue;

			case 12: // filler data
				Проверить(nNalRefIdc === 0);
				// Не сохранять в видеопотоке.
				continue;

			case 13: // sequence parameter set extension
				Проверить(nNalRefIdc !== 0);
				if (_лРазрыв && (_уСемплПоследнегоКлючКадра === -1 || typeof _оПараметры.abSequenceParameterSetExt === 'undefined'))
				{
					// Делаем копию.
					_оПараметры.abSequenceParameterSetExt = _мбВидеоПоток.slice(pNalUnitBegin, pNalUnitEnd);
				}
				Проверить(false); // UNDONE
				// Не сохранять в видеопотоке.
				continue;
			}

			var cbNalUnit = pNalUnitEnd - pNalUnitBegin;
			_мбВидеоПоток.ЗаписатьБЦ32(уДекодированныйПоток, cbNalUnit);
			уДекодированныйПоток += 4;
			_мбВидеоПоток.copyWithin(уДекодированныйПоток, pNalUnitBegin, pNalUnitEnd);
			уДекодированныйПоток += cbNalUnit;
		}

		м_Журнал.Вот('NalUnits='       + cNalUnits
			+ ' КоличествоКлючКадров=' + кКлючКадров
			+ ' ПервыйКлючКадр='       + ((уСемплПервогоКлючКадра     - _срОбрабатываемоеВидео.уНачалоСемплов) / РАЗМЕР_СТРУКТУРЫ_ВИДЕОСЕМПЛА)
			+ ' ПоследнийКлючКадр='    + ((_уСемплПоследнегоКлючКадра - _срОбрабатываемоеВидео.уНачалоСемплов) / РАЗМЕР_СТРУКТУРЫ_ВИДЕОСЕМПЛА)
		);

		if (кСемпловБезVCL !== 0)
		{
			м_Журнал.Ой(`Видеосемплов без VCL NAL unit: ${кСемпловБезVCL}`);
		}

		if (cAccessUnits > 1)
		{
			м_Журнал.Ой('Несколько access unit в одном видеосемпле');
		}

		_срОбрабатываемоеВидео.уНачалоПотока = _срЗадержанноеВидео.уКонецПотока;
		_срОбрабатываемоеВидео.уКонецПотока = уДекодированныйПоток;

		if (_лРазрыв)
		{
			if (_уСемплПоследнегоКлючКадра === -1
			|| typeof _оПараметры.abSequenceParameterSet === 'undefined'
			|| typeof _оПараметры.abPictureParameterSet  === 'undefined')
			{
				м_Журнал.Ой(`Сегмент не годится для воспроизведения: не найден IDR ${_уСемплПоследнегоКлючКадра === -1}, не найден SPS ${typeof _оПараметры.abSequenceParameterSet === "undefined"}, не найден PPS ${typeof _оПараметры.abPictureParameterSet  === "undefined"}`);
				return false;
			}
			// Делаем копию.
			var мбКопия = _оПараметры.abSequenceParameterSet.slice();
			var о = RemoveEmulationPreventionBytesFromNalUnit(мбКопия, 0, мбКопия.length);
			ParseSequenceParameterSet(мбКопия, о.уНачалоRBSP, о.уКонецRBSP);
		}
		return true;
	}

	function ParseSequenceParameterSet(мбПоток, уНачало, уКонец)
	// Результат работы сохраняет в _оПараметры.
	// Не изменяет содержимое мбПоток.
	{
		var nProfileIndication = мбПоток[уНачало]; // profile_idc
		var nConstraintSetFlag = мбПоток[уНачало + 1]; // constraint_set_flag
		var nLevelIndication   = мбПоток[уНачало + 2]; // level_idc
		var оПотокБитов = new ПотокБитов(мбПоток, уНачало + 3, уКонец);
		var nSequenceParameterSetId = оПотокБитов.ПрочестьБеззнаковыйЭКГ(); // seq_parameter_set_id
		Проверить(nSequenceParameterSetId < 32);
		var nChromaFormatIndication  = 1;
		var nSeparateColourPlaneFlag = 0;
		var nBitDepthLumaMinus8      = 0;
		var nBitDepthChromaMinus8    = 0;
		switch (nProfileIndication)
		{
		case 183:
			nChromaFormatIndication = 0;
			break;
		case 100:
		case 110:
		case 122:
		case 244:
		case 44:
		case 83:
		case 86:
		case 118:
		case 128:
		case 138:
		case 139:
		case 134:
			nChromaFormatIndication = оПотокБитов.ПрочестьБеззнаковыйЭКГ(); // chroma_format_idc
			Проверить(nChromaFormatIndication <= 3); // 3 для H.264 и IBMFF
			if (nChromaFormatIndication === 3)
			{
				nSeparateColourPlaneFlag = оПотокБитов.ПрочестьБиты(1); // separate_colour_plane_flag
			}
			nBitDepthLumaMinus8 = оПотокБитов.ПрочестьБеззнаковыйЭКГ(); // bit_depth_luma_minus8
			Проверить(nBitDepthLumaMinus8 <= 6); // 6 для H.264, 7 для IBMFF
			nBitDepthChromaMinus8 = оПотокБитов.ПрочестьБеззнаковыйЭКГ(); // bit_depth_chroma_minus8
			Проверить(nBitDepthChromaMinus8 <= 6); // 6 для H.264, 7 для IBMFF
			оПотокБитов.ПропуститьБиты(1); // qpprime_y_zero_transform_bypass_flag
			if (оПотокБитов.ПрочестьБиты(1) !== 0) // seq_scaling_matrix_present_flag
			{
				for (var i = 0, ic = (nChromaFormatIndication !== 3 ? 8 : 12); i < ic; ++i)
				{
					if (оПотокБитов.ПрочестьБиты(1) !== 0) // seq_scaling_list_present_flag
					{
						var nLastScale = 8, nNextScale = 8;
						for (var j = 0, jc = (i < 6 ? 16 : 64); j < jc; ++j)
						{
							if (nNextScale !== 0)
							{
								nNextScale = (nLastScale + оПотокБитов.ПрочестьЗнаковыйЭКГ() + 256) % 256; // delta_scale
							}
							if (nNextScale !== 0)
							{
								nLastScale = nNextScale;
							}
						}
					}
				}
			}
		}
		оПотокБитов.ПропуститьЭКГ(); // log2_max_frame_num_minus4
		switch (оПотокБитов.ПрочестьБеззнаковыйЭКГ()) // pic_order_cnt_type
		{
		case 0:
			оПотокБитов.ПропуститьЭКГ(); // log2_max_pic_order_cnt_lsb_minus4
			break;
		case 1:
			оПотокБитов.ПропуститьБиты(1); // delta_pic_order_always_zero_flag
			оПотокБитов.ПропуститьЭКГ(); // offset_for_non_ref_pic
			оПотокБитов.ПропуститьЭКГ(); // offset_for_top_to_bottom_field
			for (var i = 0, ic = оПотокБитов.ПрочестьБеззнаковыйЭКГ(); i < ic; ++i) // num_ref_frames_in_pic_order_cnt_cycle
			{
				оПотокБитов.ПропуститьЭКГ(); // offset_for_ref_frame
			}
		}
		var nMaxNumberReferenceFrames = оПотокБитов.ПрочестьБеззнаковыйЭКГ(); // max_num_ref_frames
		оПотокБитов.ПропуститьБиты(1); // gaps_in_frame_num_value_allowed_flag
		var nPictureWidthInMacroblocks = оПотокБитов.ПрочестьБеззнаковыйЭКГ() + 1; // pic_width_in_mbs_minus1
		var nPictureHeightInMapUnits = оПотокБитов.ПрочестьБеззнаковыйЭКГ() + 1; // pic_height_in_map_units_minus1
		var nFrameMacroblocksOnlyFlag = оПотокБитов.ПрочестьБиты(1); // frame_mbs_only_flag
		if (nFrameMacroblocksOnlyFlag === 0)
		{
			оПотокБитов.ПропуститьБиты(1); // mb_adaptive_frame_field_flag 
		}
		оПотокБитов.ПропуститьБиты(1); // direct_8x8_inference_flag
		if (оПотокБитов.ПрочестьБиты(1) !== 0) // frame_cropping_flag
		{
			var nFrameCropLeftOffset   = оПотокБитов.ПрочестьБеззнаковыйЭКГ(); // frame_crop_left_offset
			var nFrameCropRightOffset  = оПотокБитов.ПрочестьБеззнаковыйЭКГ(); // frame_crop_right_offset
			var nFrameCropTopOffset    = оПотокБитов.ПрочестьБеззнаковыйЭКГ(); // frame_crop_top_offset
			var nFrameCropBottomOffset = оПотокБитов.ПрочестьБеззнаковыйЭКГ(); // frame_crop_bottom_offset
		}
		else
		{
			var nFrameCropLeftOffset   = 0;
			var nFrameCropRightOffset  = 0;
			var nFrameCropTopOffset    = 0;
			var nFrameCropBottomOffset = 0;
		}

		if (оПотокБитов.ПрочестьБиты(1) !== 0) // vui_parameters
		{
			if (оПотокБитов.ПрочестьБиты(1) !== 0) // aspect_ratio_info_present_flag
			{
				// 0 Unspecified
				// 1 1:1
				var nAspectRatioIndication = оПотокБитов.ПрочестьБиты(8); // aspect_ratio_idc
				if (nAspectRatioIndication === 255)
				{
					var nSarWidth  = оПотокБитов.ПрочестьБиты(16); // sar_width
					var nSarHeight = оПотокБитов.ПрочестьБиты(16); // sar_height
				}
			}
			if (оПотокБитов.ПрочестьБиты(1) !== 0) // overscan_info_present_flag
			{
				оПотокБитов.ПропуститьБиты(1); // overscan_appropriate_flag
			}
			if (оПотокБитов.ПрочестьБиты(1) !== 0) // video_signal_type_present_flag
			{
				// 0 Component
				// 1 PAL
				// 2 NTSC
				// 3 SECAM
				// 4 MAC
				// 5 Unspecified
				var nVideoFormat = оПотокБитов.ПрочестьБиты(3); // video_format
				var nVideoFullRangeFlag = оПотокБитов.ПрочестьБиты(1); // video_full_range_flag
				if (оПотокБитов.ПрочестьБиты(1) !== 0) // colour_description_present_flag
				{
					оПотокБитов.ПропуститьБиты(8 + 8 + 8); // colour_primaries + transfer_characteristics + matrix_coefficients
				}
			}
			if (оПотокБитов.ПрочестьБиты(1) !== 0) // chroma_loc_info_present_flag
			{
				оПотокБитов.ПропуститьЭКГ(); // chroma_sample_loc_type_top_field
				оПотокБитов.ПропуститьЭКГ(); // chroma_sample_loc_type_bottom_field
			}
			if (оПотокБитов.ПрочестьБиты(1) !== 0) // timing_info_present_flag
			{
				var nNumUnitsInTick = оПотокБитов.ПрочестьБиты(32); // num_units_in_tick
				var nTimeScale = оПотокБитов.ПрочестьБиты(32); // time_scale
				var nFixedFrameRateFlag = оПотокБитов.ПрочестьБиты(1); // fixed_frame_rate_flag
			}
		}

		var nCropUnitX = 1, nCropUnitY = 1;
		if (nSeparateColourPlaneFlag === 0 && nChromaFormatIndication !== 0) // ChromaArrayType !== 0
		{
			nCropUnitX = nChromaFormatIndication === 3 ? 1 : 2; // = nSubWidthC
			nCropUnitY = nChromaFormatIndication === 1 ? 2 : 1; // = nSubHeightC
		}
		if (nFrameMacroblocksOnlyFlag === 0)
		{
			nCropUnitY += nCropUnitY;
			nPictureHeightInMapUnits += nPictureHeightInMapUnits;
		}

		_оПараметры.чШиринаКартинки  = nPictureWidthInMacroblocks * 16 - nCropUnitX * nFrameCropRightOffset  - nCropUnitX * nFrameCropLeftOffset;
		_оПараметры.чВысотаКартинки  = nPictureHeightInMapUnits   * 16 - nCropUnitY * nFrameCropBottomOffset - nCropUnitY * nFrameCropTopOffset;
		_оПараметры.nProfileIndication = nProfileIndication;
		_оПараметры.nConstraintSetFlag = nConstraintSetFlag;
		_оПараметры.nLevelIndication = nLevelIndication;
		_оПараметры.nChromaFormatIndication = nChromaFormatIndication;
		_оПараметры.nBitDepthLumaMinus8 = nBitDepthLumaMinus8;
		_оПараметры.nBitDepthChromaMinus8 = nBitDepthChromaMinus8;
		_оПараметры.nMaxNumberReferenceFrames = nMaxNumberReferenceFrames;
		_оПараметры.чДиапазон = nVideoFullRangeFlag === undefined ? -1 : nVideoFullRangeFlag;
		_оПараметры.лЧересстрочное = nFrameMacroblocksOnlyFlag === 0;
		_оПараметры.чЧастотаКадров = nTimeScale === undefined ? 0 : (nTimeScale / nNumUnitsInTick / (nFixedFrameRateFlag === 0 ? -2 : 2));

		м_Журнал.Вот('ШиринаКартинки=' + _оПараметры.чШиринаКартинки
			+ ' ВысотаКартинки=' + _оПараметры.чВысотаКартинки
			+ ' ProfileIndication=' + nProfileIndication
			+ ' ConstraintSetFlag=0x' + nConstraintSetFlag.toString(16)
			+ ' LevelIndication=' + (nLevelIndication / 10).toFixed(1)
			+ ' MaxNumberReferenceFrames=' + nMaxNumberReferenceFrames
			+ ' SequenceParameterSetId=' + nSequenceParameterSetId
			+ ' AspectRatioIndication=' + nAspectRatioIndication
			+ ' SarWidth=' + nSarWidth
			+ ' SarHeight=' + nSarHeight
			+ ' VideoFormat=' + nVideoFormat
			+ ' VideoFullRangeFlag=' + nVideoFullRangeFlag
			+ ' TimeScale=' + nTimeScale
			+ ' NumUnitsInTick=' + nNumUnitsInTick
			+ ' FixedFrameRateFlag=' + nFixedFrameRateFlag
		);
		if (nFrameMacroblocksOnlyFlag === 0)
		{
			м_Журнал.Ой('Чересстрочное видео');
		}
	}

	function RemoveEmulationPreventionBytesFromNalUnit(мбПоток, уНачало, уКонец)
	// ITU-T H.264:2014 7.4.1 NAL unit semantics
	// Выкидывает все emulation prevention bytes из NAL unit.
	// уНачало - начало NAL unit, уКонец - конец NAL unit.
	// Возвращает {указатель на начало RBSP, указатель на конец RBSP}.
	// Допускается RBSP нулевого размера.
	// В NAL unit не должен встречаться start code prefix.
	{
		// Первый байт не кодируется.
		Проверить(уНачало < уКонец);
		var nNalUnitType = мбПоток[уНачало++] & 0x1F; // nal_unit_type
		// nal_unit_header_svc_extension, nal_unit_header_3davc_extension и nal_unit_header_mvc_extension не кодируются.
		if (nNalUnitType === 14 || nNalUnitType === 20 || nNalUnitType === 21)
		{
			Проверить(уНачало < уКонец);
			уНачало += nNalUnitType === 21 && (мбПоток[уНачало] & 0x80) !== 0 ? 2 : 3;
			Проверить(уНачало <= уКонец);
		}
		var уНачалоRBSP = уНачало;
		var уКонец2 = уКонец - 2;
		while (уНачало < уКонец2)
		{
			if (мбПоток[уНачало++] === 0 && мбПоток[уНачало++] === 0)
			{
				var чТретийБайт = мбПоток[уНачало++];
				// "Within the NAL unit, the following three-byte sequences shall not occur
				// at any byte-aligned position: 0x000000, 0x000001, 0x000002."
				Проверить(чТретийБайт >= 3);
				if (чТретийБайт === 3) // emulation_prevention_three_byte
				{
					var уДекодированныйПоток = уНачало - 1;
					// "Within the NAL unit, any four-byte sequence that starts with 0x000003 other than the following sequences
					// shall not occur at any byte-aligned position: 0x00000300, 0x00000301, 0x00000302, 0x00000303."
					Проверить(уНачало === уКонец || мбПоток[уНачало] <= 3);
					while (уНачало < уКонец2)
					{
						if ((мбПоток[уДекодированныйПоток++] = мбПоток[уНачало++]) === 0
						&&  (мбПоток[уДекодированныйПоток++] = мбПоток[уНачало++]) === 0)
						{
							чТретийБайт = мбПоток[уДекодированныйПоток++] = мбПоток[уНачало++];
							// "Within the NAL unit, the following three-byte sequences shall not occur
							// at any byte-aligned position: 0x000000, 0x000001, 0x000002."
							Проверить(чТретийБайт >= 3);
							if (чТретийБайт === 3) // emulation_prevention_three_byte
							{
								--уДекодированныйПоток;
								// "Within the NAL unit, any four-byte sequence that starts with 0x000003 other than the following sequences
								// shall not occur at any byte-aligned position: 0x00000300, 0x00000301, 0x00000302, 0x00000303."
								Проверить(уНачало === уКонец || мбПоток[уНачало] <= 3);
							}
						}
					}
					while (уНачало !== уКонец)
					{
						var чПоследнийБайт = мбПоток[уДекодированныйПоток++] = мбПоток[уНачало++];
					}
					// "The last byte of the NAL unit shall not be equal to 0x00."
					Проверить(чПоследнийБайт !== 0);
					return {
						уНачалоRBSP,
						уКонецRBSP: уДекодированныйПоток
					};
				}
			}
		}
		// "The last byte of the NAL unit shall not be equal to 0x00."
		Проверить(уНачало === уКонец || мбПоток[уКонец - 1] !== 0);
		// Ни одного байта не выкинуто.
		return {
			уНачалоRBSP,
			уКонецRBSP: уКонец
		};
	}


	function РазобратьАудиоПоток()
	// ISO 14496-3:2009 1.6 Interface to ISO/IEC 14496-1 (MPEG-4 Systems)
	// ISO 13818-7:2004 6.2 Audio Data Transport Stream, ADTS
	// Firefox 46: Жрет HE-AACv1 даже если в названии кодека AAC-LC.
	// Chrome: Начиная с версии 50 жрет HE-AACv1 и HE-AACv2 даже если в названии кодека AAC-LC.
	{
		const ADTS_HEADER_SIZE = 7;

		Проверить(_срОбрабатываемоеАудио.уКонецПотока  !== _срОбрабатываемоеАудио.уНачалоПотока);
		Проверить(_срОбрабатываемоеАудио.уКонецСемплов === _срОбрабатываемоеАудио.уНачалоСемплов);

		if (_лРазрыв)
		{
			Проверить(_срОбрабатываемоеАудио.ПолучитьРазмерПотока() > ADTS_HEADER_SIZE);
			ParseAdtsFixedHeader(_мбАудиоПоток.ПрочестьБЦ32(_срОбрабатываемоеАудио.уНачалоПотока));
		}

		var pAdtsFrame = _срОбрабатываемоеАудио.уНачалоПотока;
		var уДекодированныйПоток = _срОбрабатываемоеАудио.уНачалоПотока;
		var уСемпл = _срОбрабатываемоеАудио.уНачалоСемплов;
		var уКонец = _срОбрабатываемоеАудио.уКонецПотока - ADTS_HEADER_SIZE;
		while (pAdtsFrame < уКонец)
		{
			Проверить(_мбАудиоПоток[pAdtsFrame] === 0xFF && _мбАудиоПоток[pAdtsFrame + 1] === 0xF1); // syncword = 0xFFF, id = 0, layer = 0, protection_absent = 1
			Проверить((_мбАудиоПоток[pAdtsFrame + 6] & 0x03) === 0); // number_of_raw_data_blocks_in_frame == 0
			var cbAdtsFrame = (_мбАудиоПоток.ПрочестьБЦ32(pAdtsFrame + 3) >> 13) & 0x00001FFF; // aac_frame_length
			var pNextAdtsFrame = pAdtsFrame + cbAdtsFrame;
			Проверить(cbAdtsFrame > ADTS_HEADER_SIZE && pNextAdtsFrame <= _срОбрабатываемоеАудио.уКонецПотока);
			_мбАудиоПоток.copyWithin(уДекодированныйПоток, pAdtsFrame + ADTS_HEADER_SIZE, pNextAdtsFrame);
			cbAdtsFrame -= ADTS_HEADER_SIZE;
			уДекодированныйПоток += cbAdtsFrame;
			_мбАудиоСемплы.ЗаписатьБЦ32(уСемпл, cbAdtsFrame); // sample_size
			уСемпл += РАЗМЕР_СТРУКТУРЫ_АУДИОСЕМПЛА;
			pAdtsFrame = pNextAdtsFrame;
		}
		Проверить(pAdtsFrame === _срОбрабатываемоеАудио.уКонецПотока);
		_срОбрабатываемоеАудио.уКонецПотока = уДекодированныйПоток;
		_срОбрабатываемоеАудио.уКонецСемплов = уСемпл;

		var кАудиоСемплов = _срОбрабатываемоеАудио.ПолучитьКоличествоСемплов();
		var чДлительностьАудиоСемпла = ДЛИНА_АУДИОСЕМПЛА / _оПараметры.чЧастотаДискретизации;
		var чДлительностьАудиоСегмента = кАудиоСемплов * чДлительностьАудиоСемпла;
		_чВДКонцаАудиоСегмента = _срОбрабатываемоеАудио.чВДНачала + Math.round(чДлительностьАудиоСегмента * TS_TIMESCALE);
		_чБитрейтЗвука = _срОбрабатываемоеАудио.ПолучитьРазмерПотока() * 8 / 1000 / чДлительностьАудиоСегмента;

		м_Журнал.Вот(`АудиоСемплов=${кАудиоСемплов}`
			+ ` ВДКонцаАудиоСегмента=${_чВДКонцаАудиоСегмента}`
			+ ` ДлительностьАудиоСемпла=${(чДлительностьАудиоСемпла * 1000).toFixed(2)}мс`
			+ ` ДлительностьАудиоСегмента=${(чДлительностьАудиоСегмента * 1000).toFixed(2)}мс`
			+ ` СмещениеНачалаАудиоСегмента=${((_срОбрабатываемоеАудио.чВДНачала - _срОбрабатываемоеВидео.чВДНачала) / (TS_TIMESCALE / 1000)).toFixed(2)}мс`
			+ ` ПредполагаемоеСмещениеКонцаАудиоСегмента=${((_чВДКонцаАудиоСегмента - _чВДПоследнегоВидеоСемпла - _чСредняяДлительностьВидеоСемпла) / (TS_TIMESCALE / 1000)).toFixed(2)}мс`
		);
		return true;
	}

	function ParseAdtsFixedHeader(nAdtsFixedHeader)
	{
		Проверить((nAdtsFixedHeader & 0xFFFF0000) === (0xFFF10000 | 0)); // syncword = 0xFFF, id = 0, layer = 0, protection_absent = 1
		_оПараметры.aDecoderSpecificInfo = [0, 0]; // audiospecificconfig, gaspecificconfig
		_оПараметры.nAudioObjectType = ((nAdtsFixedHeader >> 14) & 3) + 1; // profile_objecttype
		_оПараметры.aDecoderSpecificInfo[0] = _оПараметры.nAudioObjectType << 3; // audioobjecttype
		// ISO 14496-3:2009 Table 1.18 Sampling Frequency Index
		var чИндексЧастотыДискретизации = (nAdtsFixedHeader >> 10) & 0x0F; // sampling_frequency_index
		_оПараметры.чЧастотаДискретизации = ЧАСТОТА_ДЕСКРИТЕЗАЦИИ[чИндексЧастотыДискретизации];
		Проверить(_оПараметры.чЧастотаДискретизации !== undefined);
		_оПараметры.aDecoderSpecificInfo[0] |= чИндексЧастотыДискретизации >> 1; // samplingfrequencyindex
		_оПараметры.aDecoderSpecificInfo[1] = (чИндексЧастотыДискретизации << 7) & 0x80; // samplingfrequencyindex
		// ISO 14496-3:2009 Table 1.19 Channel Configuration
		_оПараметры.чКоличествоКаналов = (nAdtsFixedHeader >> 6) & 7; // channel_configuration
		// Если channel_configuration = 0, то нужно найти program_config_element и добавить его в aDecoderSpecificInfo.
		// Chrome 44 такой aDecoderSpecificInfo пока не поддерживает https://bugs.chromium.org/p/chromium/issues/detail?id=241171
		Проверить(_оПараметры.чКоличествоКаналов !== 0);
		_оПараметры.aDecoderSpecificInfo[1] |= _оПараметры.чКоличествоКаналов << 3; // channelconfiguration
		// framelengthflag = 0 (1024 samples)
		// dependsoncorecoder = 0
		// extensionflag = 0
		м_Журнал[_оПараметры.nAudioObjectType !== 2 || _оПараметры.чЧастотаДискретизации < 44100 || _оПараметры.чКоличествоКаналов > 2 ? 'Ой' : 'Вот']
			(`AudioObjectType=${_оПараметры.nAudioObjectType} ЧастотаДискретизации=${_оПараметры.чЧастотаДискретизации} КоличествоКаналов=${_оПараметры.чКоличествоКаналов}`);
	}

	function ПолучитьНазваниеВидеоКодека(оПараметры)
	// https://tools.ietf.org/html/rfc6381
	// Первая часть возвращаемой строки совпадает с типом AVCSampleEntry.
	{
		return 'avc1.'
			+ ('0' + оПараметры.nProfileIndication.toString(16)).slice(-2)
			+ ('0' + оПараметры.nConstraintSetFlag.toString(16)).slice(-2)
			+ ('0' + оПараметры.nLevelIndication  .toString(16)).slice(-2);
	}

	function ПолучитьНазваниеАудиоКодека(оПараметры)
	// https://tools.ietf.org/html/rfc6381
	// Первая часть возвращаемой строки совпадает с типом MP4AudioSampleEntry.
	{
		return `mp4a.40.${оПараметры.nAudioObjectType}`;
	}

	function СоздатьСегментИнициализации(оПараметры, оРезультат)
	// Добавляет мбСегментИнициализации и сКодеки в оРезультат.
	{
		const лЕстьВидео = true, лЕстьЗвук = true; // TODO Брать из оПараметры.

		var кбРазмер = 1111
			+ оПараметры.abSequenceParameterSet.length
			+ оПараметры.abPictureParameterSet.length
			+ (оПараметры.abSequenceParameterSetExt ? оПараметры.abSequenceParameterSetExt.length : 0)
			+ оПараметры.aDecoderSpecificInfo.length;
		var мбБуфер = new Uint8Array(кбРазмер);
		var оСегмент = new IsoBaseMedia(мбБуфер, 0);

		// ISO 14496-12:2012 Annex E File format brands
		// ISO 14496-15:2013 5.4.1 AVC File type and identification
		оСегмент.AddBox('ftyp',
		[
			0x69, 0x73, 0x6F, 0x36,                      // major_brand = 'iso6'
			0, 0, 0, 0,                                  // minor_version = 0
			0x61, 0x76, 0x63, 0x31                       // compatible_brands = 'avc1'
		]);

		оСегмент.AddBox('moov', function()
		{
			оСегмент.AddFullBox('mvhd', 1, 0,            // Версия 1 для обхода исправленной в Chrome 55 ошибки https://bugs.chromium.org/p/chromium/issues/detail?id=649882
			[
				0, 0, 0, 0, 0, 0, 0, 0,                  // creation_time = 0
				0, 0, 0, 0, 0, 0, 0, 0,                  // modification_time = 0
				0, 0, 0, 1,                              // timescale = 1
				                                         // В моем случае не используется.
				0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF, // duration = cannot be determined
				0, 1, 0, 0,                              // rate = 1.0
				                                         // Firefox 48, Chrome 53: Не используется.
				1, 0,                                    // volume = full
				                                         // Firefox 48, Chrome 53: Не используется.
				0, 0, 0, 0, 0, 0, 0, 0, 0, 0,            // reserved = 0
				0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,      // matrix
				0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0,      // matrix
				0, 0, 0, 0, 0, 0, 0, 0, 0x40, 0, 0, 0,   // matrix
				0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,      // pre_defined
				0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,      // pre_defined
				0xFF, 0xFF, 0xFF, 0xFF                   // next_track_id = unknown
			]);

			оСегмент.AddBox('mvex', function()
			{
				if (лЕстьВидео)
				{
					оСегмент.AddFullBox('trex', 0, 0, 20);
					оСегмент.мбБуфер.ЗаписатьБЦ32(оСегмент.уКонец - 20, НОМЕР_ВИДЕО_ДОРОЖКИ); // track_id
					оСегмент.мбБуфер.ЗаписатьБЦ32(оСегмент.уКонец - 16, 1);                   // default_sample_description_index
					// default_sample_duration = 0
					// default_sample_size = 0
					// default_sample_flags = !sample_is_non_sync_sample
				}

				if (лЕстьЗвук)
				{
					оСегмент.AddFullBox('trex', 0, 0, 20);
					оСегмент.мбБуфер.ЗаписатьБЦ32(оСегмент.уКонец - 20, НОМЕР_АУДИО_ДОРОЖКИ); // track_id
					оСегмент.мбБуфер.ЗаписатьБЦ32(оСегмент.уКонец - 16, 1);                   // default_sample_description_index
					оСегмент.мбБуфер.ЗаписатьБЦ32(оСегмент.уКонец - 12, ДЛИНА_АУДИОСЕМПЛА);   // default_sample_duration
					// default_sample_size = 0
					// default_sample_flags = !sample_is_non_sync_sample
				}
			});

			if (лЕстьВидео)
			{
				ДобавитьДорожку(оПараметры, true, оСегмент);
			}

			if (лЕстьЗвук)
			{
				ДобавитьДорожку(оПараметры, false, оСегмент);
			}
		});

		оРезультат.мбСегментИнициализации = оСегмент.Завершить();

		оРезультат.сКодеки = 'video/mp4; codecs="'
			+ (лЕстьВидео ? ПолучитьНазваниеВидеоКодека(оПараметры) : '')
			+ (лЕстьВидео && лЕстьЗвук ? ', '                       : '')
			+ (лЕстьЗвук  ? ПолучитьНазваниеАудиоКодека(оПараметры) : '')
			+ '"';
	}

	function ДобавитьДорожку(оПараметры, лВидео, оСегмент)
	{
		оСегмент.AddBox('trak', function()
		{
			оСегмент.AddFullBox('tkhd', 0, 3, 80);                                              // track_in_movie | track_enabled
			// creation_time = 0
			// modification_time = 0
			// reserved = 0
			оСегмент.мбБуфер.ЗаписатьБЦ32(оСегмент.уКонец - 64, 0xFFFFFFFF);                    // duration = cannot be determined
			// reserved = 0
			// layer = 0
			// alternate_group = 0
			// volume = 0
			// reserved = 0
			оСегмент.мбБуфер[оСегмент.уКонец - 43] = 1;                                         // matrix
			оСегмент.мбБуфер[оСегмент.уКонец - 27] = 1;                                         // matrix
			оСегмент.мбБуфер[оСегмент.уКонец - 12] = 0x40;                                      // matrix
			// width = 0
			// height = 0
			if (лВидео)
			{
				оСегмент.мбБуфер.ЗаписатьБЦ32(оСегмент.уКонец - 72, НОМЕР_ВИДЕО_ДОРОЖКИ);       // track_id
				оСегмент.мбБуфер.ЗаписатьБЦ16(оСегмент.уКонец - 8, оПараметры.чШиринаКартинки); // width
				оСегмент.мбБуфер.ЗаписатьБЦ16(оСегмент.уКонец - 4, оПараметры.чВысотаКартинки); // height
			}
			else
			{
				оСегмент.мбБуфер.ЗаписатьБЦ32(оСегмент.уКонец - 72, НОМЕР_АУДИО_ДОРОЖКИ);       // track_id
				оСегмент.мбБуфер.ЗаписатьБЦ16(оСегмент.уКонец - 48, 0x0100);                    // volume = full
				                                                                                // Firefox 48, Chrome 53: Не используется.
			}

			оСегмент.AddBox('mdia', function()
			{
				оСегмент.AddFullBox('mdhd', 0, 0, 20);
				// creation_time = 0
				// modification_time = 0
				оСегмент.мбБуфер.ЗаписатьБЦ32(оСегмент.уКонец - 12, лВидео ? TS_TIMESCALE : оПараметры.чЧастотаДискретизации); // timescale
				оСегмент.мбБуфер[оСегмент.уКонец - 8] = 0xFF; // duration = cannot be determined
				оСегмент.мбБуфер[оСегмент.уКонец - 7] = 0xFF; // duration = cannot be determined
				оСегмент.мбБуфер[оСегмент.уКонец - 6] = 0xFF; // duration = cannot be determined
				оСегмент.мбБуфер[оСегмент.уКонец - 5] = 0xFF; // duration = cannot be determined
				оСегмент.мбБуфер[оСегмент.уКонец - 4] = 0x55; // language = 'und'
				оСегмент.мбБуфер[оСегмент.уКонец - 3] = 0xC4; // language = 'und'
				// pre_defined = 0

				оСегмент.AddFullBox('hdlr', 0, 0,
					лВидео ? [
						0, 0, 0, 0,                                                         // pre_defined
						0x76, 0x69, 0x64, 0x65,                                             // handler_type = 'vide'
						0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,                                 // reserved = 0
						0x43, 0x6F, 0x6F, 0x6C, 0x43, 0x6D, 0x64, 0x56, 0x69, 0x64, 0x35, 0 // name = 'CoolCmdVid5'
					] : [
						0, 0, 0, 0,                                                         // pre_defined
						0x73, 0x6F, 0x75, 0x6E,                                             // handler_type = 'soun'
						0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,                                 // reserved = 0
						0x43, 0x6F, 0x6F, 0x6C, 0x43, 0x6D, 0x64, 0x41, 0x75, 0x64, 0x35, 0 // name = 'CoolCmdAud5'
					]
				);

				оСегмент.AddBox('minf', function()
				{
					if (лВидео)
					{
						оСегмент.AddFullBox('vmhd', 0, 1, 8);
						// graphicsmode = 0
						// opcolor = {0, 0, 0}
					}
					else
					{
						оСегмент.AddFullBox('smhd', 0, 0, 4);
						// balance = 0
						// reserved = 0
					}

					оСегмент.AddBox('dinf', function()
					{
						оСегмент.AddFullBox('dref', 0, 0, function()
						{
							оСегмент.мбБуфер.ЗаписатьБЦ32(оСегмент.уКонец, 1); // entry_count
							оСегмент.уКонец += 4;
							оСегмент.AddFullBox('url ', 0, 1, 0);
						});
					});

					оСегмент.AddBox('stbl', function()
					{
						//
						// ISO 14496-12:2012 SampleDescriptionBox
						//
						оСегмент.AddFullBox('stsd', 0, 0, function()
						{
							оСегмент.мбБуфер.ЗаписатьБЦ32(оСегмент.уКонец, 1); // entry_count
							оСегмент.уКонец += 4;

							if (лВидео)
							{
								//
								// ISO 14496-15:2013 AVCSampleEntry
								//
								оСегмент.AddBox('avc1', function()
								{
									//
									// ISO 14496-12:2012 SampleEntry
									//
									// reserved = 0
									оСегмент.мбБуфер.ЗаписатьБЦ16(оСегмент.уКонец + 6, 1);                                            // data_reference_index
									//
									// ISO 14496-12:2012 VisualSampleEntry
									//
									// pre_defined = 0
									// reserved = 0
									// pre_defined = 0
									оСегмент.мбБуфер.ЗаписатьБЦ16(оСегмент.уКонец + 24, оПараметры.чШиринаКартинки);                  // width
									оСегмент.мбБуфер.ЗаписатьБЦ16(оСегмент.уКонец + 26, оПараметры.чВысотаКартинки);                  // height
									оСегмент.мбБуфер.ЗаписатьБЦ32(оСегмент.уКонец + 28, 0x00480000);                                  // horizresolution = 72 dpi
									оСегмент.мбБуфер.ЗаписатьБЦ32(оСегмент.уКонец + 32, 0x00480000);                                  // vertresolution = 72 dpi
									// reserved = 0
									оСегмент.мбБуфер.ЗаписатьБЦ16(оСегмент.уКонец + 40, 1);                                           // frame_count
									// compressorname = 0
									оСегмент.мбБуфер.ЗаписатьБЦ16(оСегмент.уКонец + 74, 0x0018);                                      // depth = the video sequence is in colour with no alpha
									оСегмент.мбБуфер.ЗаписатьБЦ16(оСегмент.уКонец + 76, 0xFFFF);                                      // pre_defined
									оСегмент.уКонец += 78;
									//
									// ISO 14496-15:2013 AVCConfigurationBox
									//
									оСегмент.AddBox('avcC', function()
									{
										оСегмент.мбБуфер[оСегмент.уКонец    ] = 1;                                                    // configurationversion
										оСегмент.мбБуфер[оСегмент.уКонец + 1] = оПараметры.nProfileIndication;                        // avcprofileindication
										оСегмент.мбБуфер[оСегмент.уКонец + 2] = оПараметры.nConstraintSetFlag;                        // profile_compatibility
										оСегмент.мбБуфер[оСегмент.уКонец + 3] = оПараметры.nLevelIndication;                          // avclevelindication
										оСегмент.мбБуфер[оСегмент.уКонец + 4] = 0xFF;                                                 // lengthsizeminusone = 3
										оСегмент.мбБуфер[оСегмент.уКонец + 5] = 0xE1;                                                 // numofsequenceparametersets = 1
										оСегмент.мбБуфер.ЗаписатьБЦ16(оСегмент.уКонец + 6, оПараметры.abSequenceParameterSet.length); // sequenceparametersetlength
										оСегмент.Копировать(оСегмент.уКонец + 8, оПараметры.abSequenceParameterSet);                  // sequenceparametersetnalunit
										оСегмент.мбБуфер[оСегмент.уКонец] = 1;                                                        // numofpictureparametersets = 1
										оСегмент.мбБуфер.ЗаписатьБЦ16(оСегмент.уКонец + 1, оПараметры.abPictureParameterSet.length);  // pictureparametersetlength
										оСегмент.Копировать(оСегмент.уКонец + 3, оПараметры.abPictureParameterSet);                   // pictureparametersetnalunit
										switch (оПараметры.nProfileIndication)
										{
										case 100:
										case 110:
										case 122:
										case 144:
											оСегмент.мбБуфер[оСегмент.уКонец    ] = 0xFC | оПараметры.nChromaFormatIndication;        // chroma_format
											оСегмент.мбБуфер[оСегмент.уКонец + 1] = 0xF8 | оПараметры.nBitDepthLumaMinus8;            // bit_depth_luma_minus8
											оСегмент.мбБуфер[оСегмент.уКонец + 2] = 0xF8 | оПараметры.nBitDepthChromaMinus8;          // bit_depth_chroma_minus8
											if (typeof оПараметры.abSequenceParameterSetExt === 'undefined')
											{
												// numofsequenceparametersetext = 0
												оСегмент.уКонец += 4;
											}
											else
											{
												оСегмент.мбБуфер[оСегмент.уКонец + 3] = 1;                                                       // numofsequenceparametersetext
												оСегмент.мбБуфер.ЗаписатьБЦ16(оСегмент.уКонец + 4, оПараметры.abSequenceParameterSetExt.length); // sequenceparametersetextlength
												оСегмент.Копировать(оСегмент.уКонец + 6, оПараметры.abSequenceParameterSetExt);                  // sequenceparametersetextnalunit
											}
										}
									});
								});
							}
							else
							{
								//
								// ISO 14496-14:2003 MP4AudioSampleEntry
								//
								оСегмент.AddBox('mp4a', function()
								{
									//
									// ISO 14496-12:2012 SampleEntry
									//
									// reserved = 0
									оСегмент.мбБуфер.ЗаписатьБЦ16(оСегмент.уКонец + 6, 1);                                   // data_reference_index
									//
									// ISO 14496-12:2012 AudioSampleEntry
									//
									// reserved = 0
									// channelcount = 0
									оСегмент.мбБуфер.ЗаписатьБЦ16(оСегмент.уКонец + 18, 16);                                 // samplesize; Chrome 44 хочет 8, 16 или 32
									// pre_defined = 0
									// reserved = 0
									// samplerate = 0
									оСегмент.уКонец += 28;
									//
									// ISO 14496-14:2003 MP4AudioSampleEntry
									//
									оСегмент.AddFullBox('esds', 0, 0, function()
									{
										//
										// ISO 14496-1:2010 ES_Descriptor
										//
										оСегмент.мбБуфер[оСегмент.уКонец    ] = 3;                                           // tag = es_descrtag
										оСегмент.мбБуфер[оСегмент.уКонец + 1] = 23 + оПараметры.aDecoderSpecificInfo.length; // sizeofinstance <= 0x7F
										оСегмент.мбБуфер.ЗаписатьБЦ16(оСегмент.уКонец + 2, 1);                               // es_id
										// streamdependenceflag = 0
										// url_flag = 0
										// ocrstreamflag = 0
										// streampriority = 0
										//
										// ISO 14496-1:2010 DecoderConfigDescriptor
										//
										оСегмент.мбБуфер[оСегмент.уКонец + 5] = 4;                                           // tag = decoderconfigdescrtag
										оСегмент.мбБуфер[оСегмент.уКонец + 6] = 15 + оПараметры.aDecoderSpecificInfo.length; // sizeofinstance <= 0x7F
										оСегмент.мбБуфер[оСегмент.уКонец + 7] = 0x40;                                        // objecttypeindication = iso 14496-3 audio
										оСегмент.мбБуфер[оСегмент.уКонец + 8] = 0x15;                                        // streamtype = audiostream, upstream = 0, reserved = 1
										// buffersizedb = 0
										// maxbitrate = 0
										// avgbitrate = 0
										//
										// ISO 14496-3:2009 AudioSpecificConfig
										//
										оСегмент.мбБуфер[оСегмент.уКонец + 20] = 5;                                          // tag = decspecificinfotag
										оСегмент.мбБуфер[оСегмент.уКонец + 21] = оПараметры.aDecoderSpecificInfo.length;     // sizeofinstance <= 0x7F
										оСегмент.Копировать(оСегмент.уКонец + 22, оПараметры.aDecoderSpecificInfo);
										//
										// ISO 14496-1:2010 SLConfigDescriptor
										//
										оСегмент.мбБуфер[оСегмент.уКонец    ] = 6;                                           // tag = slconfigdescrtag
										оСегмент.мбБуфер[оСегмент.уКонец + 1] = 1;                                           // sizeofinstance <= 0x7F
										оСегмент.мбБуфер[оСегмент.уКонец + 2] = 2;                                           // predefined = reserved for use in mp4 files
										оСегмент.уКонец += 3;
									});
								});
							}
						});

						оСегмент.AddFullBox('stts', 0, 0, 4);
						// entry_count = 0

						оСегмент.AddFullBox('stsc', 0, 0, 4);
						// entry_count = 0

						оСегмент.AddFullBox('stco', 0, 0, 4);
						// entry_count = 0

						оСегмент.AddFullBox('stsz', 0, 0, 8);
						// sample_size = 0
						// sample_count = 0
					});
				});
			});
		});
	}

	function СоздатьМедиасегмент(оПараметры, срВидео, срАудио, оРезультат, лИскатьНаБалконе)
	// Добавляет мбМедиасегмент в оРезультат.
	{
		Проверить(!срВидео.Пусто() || !срАудио.Пусто());

		var кбРазмер = 160
			+ срВидео.ПолучитьРазмерПотока() + срВидео.ПолучитьРазмерСемплов()
			+ срАудио.ПолучитьРазмерПотока() + срАудио.ПолучитьРазмерСемплов();
		var мбБуфер;
		if (лИскатьНаБалконе)
		{
			мбБуфер = м_Балкон.Найти(кбРазмер);
		}
		if (!мбБуфер)
		{
			мбБуфер = new Uint8Array(кбРазмер);
		}
		var оСегмент = new IsoBaseMedia(мбБуфер, 0);
		var уСмещениеВидеоданных, уСмещениеАудиоданных;

		оСегмент.AddBox('moof', function()
		{
			оСегмент.AddFullBox('mfhd', 0, 0, 4);
			мбБуфер.ЗаписатьБЦ32(оСегмент.уКонец - 4, 0); // sequence_number

			if (!срВидео.Пусто())
			{
				оСегмент.AddBox('traf', function()
				{
					оСегмент.AddFullBox('tfhd', 0, 0x020000, 4); // default-base-is-moof
					мбБуфер.ЗаписатьБЦ32(оСегмент.уКонец - 4, НОМЕР_ВИДЕО_ДОРОЖКИ); // track_id

					// timestamp занимает 33 бита.
					оСегмент.AddFullBox('tfdt', 1, 0, 8); // unsigned 64-bit integer
					мбБуфер.ЗаписатьБЦ64(оСегмент.уКонец - 8, срВидео.чВДНачала); // basemediadecodetime

					оСегмент.AddFullBox('trun', 1, // signed sample_composition_time_offset
						0xF01, // sample-composition-time-offsets-present | sample-flags-present | sample-size-present | sample-duration-present | data-offset-present
						function()
						{
							мбБуфер.ЗаписатьБЦ32(оСегмент.уКонец, срВидео.ПолучитьКоличествоСемплов()); // sample_count
							уСмещениеВидеоданных = оСегмент.уКонец + 4; // data_offset
							оСегмент.Копировать(оСегмент.уКонец + 8, _мбВидеоСемплы, срВидео.уНачалоСемплов, срВидео.уКонецСемплов);
						}
					);
				});
			}

			if (!срАудио.Пусто())
			{
				оСегмент.AddBox('traf', function()
				{
					оСегмент.AddFullBox('tfhd', 0, 0x020000, 4); // default-base-is-moof
					мбБуфер.ЗаписатьБЦ32(оСегмент.уКонец - 4, НОМЕР_АУДИО_ДОРОЖКИ); // track_id

					// timestamp занимает 33 бита.
					оСегмент.AddFullBox('tfdt', 1, 0, 8); // unsigned 64-bit integer
					мбБуфер.ЗаписатьБЦ64(оСегмент.уКонец - 8, срАудио.чВДНачала / TS_TIMESCALE * оПараметры.чЧастотаДискретизации); // basemediadecodetime

					оСегмент.AddFullBox('trun', 1, // signed sample_composition_time_offset
						0x201, // sample-size-present | data-offset-present
						function()
						{
							мбБуфер.ЗаписатьБЦ32(оСегмент.уКонец, срАудио.ПолучитьКоличествоСемплов()); // sample_count
							уСмещениеАудиоданных = оСегмент.уКонец + 4; // data_offset
							оСегмент.Копировать(оСегмент.уКонец + 8, _мбАудиоСемплы, срАудио.уНачалоСемплов, срАудио.уКонецСемплов);
						}
					);
				});
			}
		});

		оСегмент.AddBox('mdat', function()
		{
			if (!срВидео.Пусто())
			{
				мбБуфер.ЗаписатьЗЦ32(уСмещениеВидеоданных, оСегмент.уКонец - оСегмент.уНачало);
				оСегмент.Копировать(оСегмент.уКонец, _мбВидеоПоток, срВидео.уНачалоПотока, срВидео.уКонецПотока);
			}
			
			if (!срАудио.Пусто())
			{
				мбБуфер.ЗаписатьЗЦ32(уСмещениеАудиоданных, оСегмент.уКонец - оСегмент.уНачало);
				оСегмент.Копировать(оСегмент.уКонец, _мбАудиоПоток, срАудио.уНачалоПотока, срАудио.уКонецПотока);
			}
		});

		оРезультат.мбМедиасегмент = оСегмент.Завершить();
	}

	function Отправить(лРазрыв, оПараметры, срВидео, срАудио, лОтправитьСтатистику, лИскатьНаБалконе)
	{
		if (лОтправитьСтатистику || !срВидео.Пусто() || !срАудио.Пусто())
		{
			var оДанные = Object.create(null);
			var мбуфОтдать;
			var чДлительностьСегмента = 0;
			var чНомерСегмента = _оИсходныйСегмент.чНомер + (_чНомерОтправляемогоСегмента += 0.1);
			if (лОтправитьСтатистику)
			{
				оДанные.чПреобразованЗа                 = _чПреобразованЗа;
				оДанные.лЗабраковано                    = _лЗабраковано;
				оДанные.лПотериВидео                    = _лПотериВидео;
				оДанные.лПотериЗвука                    = _лПотериЗвука;
				оДанные.чМинДлительностьВидеоСемпла     = _чМинДлительностьВидеоСемпла     / (TS_TIMESCALE / 1000);
				оДанные.чМаксДлительностьВидеоСемпла    = _чМаксДлительностьВидеоСемпла    / (TS_TIMESCALE / 1000);
				оДанные.чСредняяДлительностьВидеоСемпла = _чСредняяДлительностьВидеоСемпла / (TS_TIMESCALE / 1000);
				оДанные.чБитрейтЗвука                   = _чБитрейтЗвука;
				оДанные.чВремяКодирования               = _чВремяКодирования;
				оДанные.чПозицияКодирования             = _чПозицияКодирования;
			}
			if ((срВидео && !срВидео.Пусто()) || (срАудио && !срАудио.Пусто()))
			{
				СоздатьМедиасегмент(оПараметры, срВидео, срАудио, оДанные, лИскатьНаБалконе);
				мбуфОтдать = [оДанные.мбМедиасегмент.buffer];
				чДлительностьСегмента = ПолучитьДлительностьОтправляемогоСегмента(лРазрыв, оПараметры, срВидео, срАудио, чНомерСегмента, оДанные);
				if (лРазрыв)
				{
					СоздатьСегментИнициализации(оПараметры, оДанные);
					оДанные.чШиринаКартинки             = оПараметры.чШиринаКартинки;
					оДанные.чВысотаКартинки             = оПараметры.чВысотаКартинки;
					оДанные.nProfileIndication          = оПараметры.nProfileIndication;
					оДанные.nConstraintSetFlag          = оПараметры.nConstraintSetFlag;
					оДанные.nLevelIndication            = оПараметры.nLevelIndication;
					оДанные.nMaxNumberReferenceFrames   = оПараметры.nMaxNumberReferenceFrames;
					оДанные.чДиапазон                   = оПараметры.чДиапазон;
					оДанные.лЧересстрочное              = оПараметры.лЧересстрочное;
					оДанные.чЧастотаКадров              = оПараметры.чЧастотаКадров;
					оДанные.nAudioObjectType            = оПараметры.nAudioObjectType;
					оДанные.чЧастотаДискретизации       = оПараметры.чЧастотаДискретизации;
					оДанные.чКоличествоКаналов          = оПараметры.чКоличествоКаналов;
					мбуфОтдать.push(оДанные.мбСегментИнициализации.buffer);
				}
			}
		}
		// Отправить журнал перед данными, чтобы он попал в отчет даже
		// если у получателя во время работы с данными возникнет ошибка.
		м_Журнал.Отправить();
		if (оДанные)
		{
			postMessage(
				[
					1,
					{
						пДанные: оДанные,
						чДлительность: чДлительностьСегмента,
						лРазрыв: лРазрыв,
						чTwitchПрошлоВремени: лОтправитьСтатистику ? _оИсходныйСегмент.чTwitchПрошлоВремени : NaN,
						чНомер: чНомерСегмента
					}
				],
				мбуфОтдать
			);
		}
	}

	// Эмуляция буфера проигрывателя.
	var _чНачалоВидеоБуфера, _чКонецВидеоБуфера;
	var _чНачалоАудиоБуфера, _чКонецАудиоБуфера;

	function ПолучитьДлительностьОтправляемогоСегмента(лРазрыв, оПараметры, срВидео, срАудио, чНомерСегмента, оДанные)
	// Потеряные семплы добавляются к длительности.
	// Фактическая длительность в буфере проигрывателя будет отличаться потому что:
	// - Для расчета используется ВД вместо ВП. Для перехода на ВП нужно сортировать _мбВидеоСемплы.
	// - Если лРазрыв, то проигрыватель пропустит видео до первого ключевого кадра.
	// На данный момент длительность сегмента выполняет вспомогательную роль, поэтому высокая точность не требуется.
	{
		if (лРазрыв)
		{
			_чНачалоВидеоБуфера = _чКонецВидеоБуфера = _чНачалоАудиоБуфера = _чКонецАудиоБуфера = -1;
		}

		var сВажность = 'Вот';
		var чКонецВидеоСегмента = _чКонецВидеоБуфера, сВидео = '';
		if (!срВидео.Пусто())
		{
			var чНачалоВидеоСегмента = срВидео.чВДНачала / TS_TIMESCALE;
			Проверить(чНачалоВидеоСегмента >= _чКонецВидеоБуфера);
			if (_чНачалоВидеоБуфера === -1)
			{
				_чНачалоВидеоБуфера = чНачалоВидеоСегмента;
			}
			чКонецВидеоСегмента = (срВидео.чВДНачала + срВидео.СложитьБеззнаковыйПараметр(ДЛИТЕЛЬНОСТЬ_ВИДЕОСЕМПЛА, срВидео.уКонецСемплов, _мбВидеоСемплы)) / TS_TIMESCALE;
			Проверить(чКонецВидеоСегмента >= чНачалоВидеоСегмента);
			сВидео = ` Видео=${чНачалоВидеоСегмента.toFixed(3)}-${чКонецВидеоСегмента.toFixed(3)}`;

			var кВидеосемплов = срВидео.ПолучитьКоличествоСемплов();
			if (кВидеосемплов < 8)
			{
				сВажность = 'Ой';
				сВидео = ` Видеосемплов=${кВидеосемплов}${сВидео}`;
			}
		}
		
		var чКонецАудиоСегмента = _чКонецАудиоБуфера, сЗвук = '';
		if (!срАудио.Пусто())
		{
			var чНачалоАудиоСегмента = срАудио.чВДНачала / TS_TIMESCALE;
			if (_чНачалоАудиоБуфера === -1)
			{
				_чНачалоАудиоБуфера = чНачалоАудиоСегмента;
			}
			чКонецАудиоСегмента = чНачалоАудиоСегмента + срАудио.ПолучитьКоличествоСемплов() * ДЛИНА_АУДИОСЕМПЛА / оПараметры.чЧастотаДискретизации;
			Проверить(чКонецАудиоСегмента >= чНачалоАудиоСегмента);
			сЗвук = ` Звук=${чНачалоАудиоСегмента.toFixed(3)}-${чКонецАудиоСегмента.toFixed(3)}`;
		}

		var чКонецБуфераДо    = Math.max(_чНачалоВидеоБуфера, _чНачалоАудиоБуфера, Math.min(_чКонецВидеоБуфера,                       _чКонецАудиоБуфера                      ));
		var чКонецБуфераПосле = Math.max(_чНачалоВидеоБуфера, _чНачалоАудиоБуфера, Math.min(_чКонецВидеоБуфера = чКонецВидеоСегмента, _чКонецАудиоБуфера = чКонецАудиоСегмента));
		var чДлительностьСегмента = чКонецБуфераПосле - чКонецБуфераДо;
		
		м_Журнал[сВажность](`Отправляю сегмент ${чНомерСегмента} Разрыв=${лРазрыв}`
			+ ` Длительность=${чДлительностьСегмента.toFixed(3)}${сВидео}${сЗвук}`
			+ ` Размер=${(оДанные.мбМедиасегмент.length / 1024 / 1024).toFixed(2)}мб`);
		
		return чДлительностьСегмента;
	}

	function РазделитьИОтправитьОбработанныйСегмент()
	{
		// Разделять по ключевым кадрам?
		if (_оИсходныйСегмент.чОбработка)
		{
			var уРазделитьВидеоПоток  = _уПотокПоследнегоКлючКадра;
			var уРазделитьВидеоСемплы = _уСемплПоследнегоКлючКадра;
		}
		else
		{
			var уРазделитьВидеоПоток  = _уПотокПоследнегоКадра;
			var уРазделитьВидеоСемплы = _уСемплПоследнегоКадра;
		}

		// Последний кадр может быть ключевым.
		if (уРазделитьВидеоСемплы !== _уСемплПоследнегоКлючКадра)
		{
			// TODO Уточнить максимальный GOP M.
			var кКадров = Math.min(17, _срОбрабатываемоеВидео.ПолучитьКоличествоСемплов());
			if (кКадров > 1)
			{
				var уСемпл = уРазделитьВидеоСемплы;
				var уПоток = уРазделитьВидеоПоток;
				var чВД = 0;
				var чРазделитьВП = _мбВидеоСемплы.ПрочестьЗЦ32(уСемпл + ВП_ВИДЕОСЕМПЛА);
				while (--кКадров !== 0)
				{
					уСемпл -= РАЗМЕР_СТРУКТУРЫ_ВИДЕОСЕМПЛА;
					уПоток -= _мбВидеоСемплы.ПрочестьБЦ32(уСемпл + РАЗМЕР_ВИДЕОСЕМПЛА);
					чВД -= _мбВидеоСемплы.ПрочестьБЦ32(уСемпл + ДЛИТЕЛЬНОСТЬ_ВИДЕОСЕМПЛА);
					var чВП = чВД + _мбВидеоСемплы.ПрочестьЗЦ32(уСемпл + ВП_ВИДЕОСЕМПЛА);
					if (чВП > чРазделитьВП)
					{
						чРазделитьВП = чВП;
						уРазделитьВидеоСемплы = уСемпл;
						уРазделитьВидеоПоток  = уПоток;
					}
				}
			}
		}

		// Статистика, включая чTwitchПрошлоВремени, может быть отправлена не со своим, а с задержанным сегментом.
		// _чВремяКодирования и _чПозицияКодирования должны отправляться вместе с сегментом из своей последовательности.
		if (_лРазрыв)
		{
			Проверить(уРазделитьВидеоСемплы !== -1);
			// Задержать весь сегмент:
			// - Разделять по ключевым кадрам, единственный ключевой кадр в начале сегмента.
			// - Утеряны почти все кадры, оставшиеся задержать для расчета длительности последнего кадра.
			if (уРазделитьВидеоСемплы === _срОбрабатываемоеВидео.уНачалоСемплов)
			{
				Отправить(_лЗадержанРазрыв, _оЗадержанныеПараметры, _срЗадержанноеВидео, _срЗадержанноеАудио, false, true);
				Задержать(_лРазрыв, _оПараметры, _срОбрабатываемоеВидео, _срОбрабатываемоеАудио);
				Отправить(false, null, null, null, true, false);
			}
			// Отправить весь сегмент: НЕ_ЗАДЕРЖИВАТЬ_ВИДЕО.
			else if (уРазделитьВидеоСемплы === _срОбрабатываемоеВидео.уКонецСемплов)
			{
				Отправить(_лЗадержанРазрыв, _оЗадержанныеПараметры, _срЗадержанноеВидео, _срЗадержанноеАудио, false, false);
				Отправить(_лРазрыв, _оПараметры, _срОбрабатываемоеВидео, _срОбрабатываемоеАудио, true, true);
			}
			// Разделить видео по указанному семплу.
			else
			{
				Отправить(_лЗадержанРазрыв, _оЗадержанныеПараметры, _срЗадержанноеВидео, _срЗадержанноеАудио, false, false);
				var м = РазделитьОбработанныйСегмент(уРазделитьВидеоПоток, уРазделитьВидеоСемплы);
				Отправить(_лРазрыв, _оПараметры, м[0], м[2], true, true);
				Задержать(false, _оПараметры, м[1], м[3]);
			}
		}
		else
		{
			// Задержать весь сегмент: разделять по ключевым кадрам, ключевой кадр не найден.
			if (уРазделитьВидеоСемплы === -1)
			{
				ДобавитьКЗадержанному(_срОбрабатываемоеВидео, _срОбрабатываемоеАудио);
				Отправить(false, null, null, null, true, false);
				м_Журнал.Окак('Ключевой кадр не найден, сегмент задержан');
			}
			// Задержать весь сегмент:
			// - Разделять по ключевым кадрам, единственный ключевой кадр в начале сегмента.
			// - Утеряны почти все кадры, оставшиеся задержать для расчета длительности последнего кадра.
			else if (уРазделитьВидеоСемплы === _срОбрабатываемоеВидео.уНачалоСемплов)
			{
				Отправить(_лЗадержанРазрыв, _оЗадержанныеПараметры, _срЗадержанноеВидео, _срЗадержанноеАудио, true, true);
				Задержать(_лРазрыв, _оПараметры, _срОбрабатываемоеВидео, _срОбрабатываемоеАудио);
			}
			// Отправить весь сегмент: НЕ_ЗАДЕРЖИВАТЬ_ВИДЕО.
			else if (уРазделитьВидеоСемплы === _срОбрабатываемоеВидео.уКонецСемплов)
			{
				Проверить(_срЗадержанноеВидео.Пусто() && _срЗадержанноеАудио.Пусто());
				Отправить(_лРазрыв, _оПараметры, _срОбрабатываемоеВидео, _срОбрабатываемоеАудио, true, true);
			}
			// Разделить видео по указанному семплу.
			else
			{
				var м = РазделитьОбработанныйСегмент(уРазделитьВидеоПоток, уРазделитьВидеоСемплы);
				ДобавитьКЗадержанному(м[0], м[2]);
				Отправить(_лЗадержанРазрыв, _оЗадержанныеПараметры, _срЗадержанноеВидео, _срЗадержанноеАудио, true, true);
				Задержать(_лРазрыв, _оПараметры, м[1], м[3]);
			}
		}
	}

	function РазделитьОбработанныйСегмент(уРазделитьВидеоПоток, уРазделитьВидеоСемплы)
	// Может получиться сегмент с нулевым количеством аудиосемплов. Firefox и Chrome без проблем жрут такие сегменты.
	{
		// В каждой части должен быть минимум один кадр.
		Проверить(уРазделитьВидеоПоток  > _срОбрабатываемоеВидео.уНачалоПотока  && уРазделитьВидеоПоток  < _срОбрабатываемоеВидео.уКонецПотока);
		Проверить(уРазделитьВидеоСемплы > _срОбрабатываемоеВидео.уНачалоСемплов && уРазделитьВидеоСемплы < _срОбрабатываемоеВидео.уКонецСемплов);

		var чВД2йЧастиВидео = _срОбрабатываемоеВидео.чВДНачала + _срОбрабатываемоеВидео.СложитьБеззнаковыйПараметр(ДЛИТЕЛЬНОСТЬ_ВИДЕОСЕМПЛА, уРазделитьВидеоСемплы, _мбВидеоСемплы);

		var кАудиоСемплов = _срОбрабатываемоеАудио.ПолучитьКоличествоСемплов();
		var кСемплов1йЧастиАудио = кАудиоСемплов;
		_срПустойАудиоСрез.чВДНачала = _чВДКонцаАудиоСегмента;

		var кСемплов2йЧастиВидео = (_срОбрабатываемоеВидео.уКонецСемплов - уРазделитьВидеоСемплы) / РАЗМЕР_СТРУКТУРЫ_ВИДЕОСЕМПЛА;
		м_Журнал.Вот(`Сегмент разделен Видео=${_срОбрабатываемоеВидео.ПолучитьКоличествоСемплов() - кСемплов2йЧастиВидео}+${кСемплов2йЧастиВидео} Звук=${кСемплов1йЧастиАудио}+${кАудиоСемплов - кСемплов1йЧастиАудио}`);

		return [
			new Срез(РАЗМЕР_СТРУКТУРЫ_ВИДЕОСЕМПЛА,
				_срОбрабатываемоеВидео.уНачалоПотока,  уРазделитьВидеоПоток,
				_срОбрабатываемоеВидео.уНачалоСемплов, уРазделитьВидеоСемплы,
				_срОбрабатываемоеВидео.чВДНачала
			),
			new Срез(РАЗМЕР_СТРУКТУРЫ_ВИДЕОСЕМПЛА,
				уРазделитьВидеоПоток,  _срОбрабатываемоеВидео.уКонецПотока,
				уРазделитьВидеоСемплы, _срОбрабатываемоеВидео.уКонецСемплов,
				чВД2йЧастиВидео
			),
			_срОбрабатываемоеАудио,
			_срПустойАудиоСрез,
		];
	}

	function Задержать(лРазрыв, оПараметры, срВидео, срАудио)
	{
		_лЗадержанРазрыв = лРазрыв;
		_оЗадержанныеПараметры = оПараметры;

		Проверить(_срЗадержанноеВидео.уНачалоПотока === 0);
		_срЗадержанноеВидео.уКонецПотока = срВидео.ПолучитьРазмерПотока();
		_мбВидеоПоток.copyWithin(0, срВидео.уНачалоПотока, срВидео.уКонецПотока);

		Проверить(_срЗадержанноеВидео.уНачалоСемплов === 0);
		_срЗадержанноеВидео.уКонецСемплов = срВидео.ПолучитьРазмерСемплов();
		_мбВидеоСемплы.copyWithin(0, срВидео.уНачалоСемплов, срВидео.уКонецСемплов);
		_срЗадержанноеВидео.чВДНачала = срВидео.чВДНачала;

		Проверить(_срЗадержанноеАудио.уНачалоПотока === 0);
		_срЗадержанноеАудио.уКонецПотока = срАудио.ПолучитьРазмерПотока();
		_мбАудиоПоток.copyWithin(0, срАудио.уНачалоПотока, срАудио.уКонецПотока);

		Проверить(_срЗадержанноеАудио.уНачалоСемплов === 0);
		_срЗадержанноеАудио.уКонецСемплов = срАудио.ПолучитьРазмерСемплов();
		_мбАудиоСемплы.copyWithin(0, срАудио.уНачалоСемплов, срАудио.уКонецСемплов);
		_срЗадержанноеАудио.чВДНачала = срАудио.чВДНачала;
	}

	function ДобавитьКЗадержанному(срВидео, срАудио)
	{
		Проверить(!_лРазрыв);
		Проверить(_оЗадержанныеПараметры === _оПараметры);
		Проверить(_срЗадержанноеВидео.уКонецПотока === срВидео.уНачалоПотока && _срЗадержанноеВидео.уКонецСемплов === срВидео.уНачалоСемплов);
		Проверить(_срЗадержанноеАудио.уКонецПотока === срАудио.уНачалоПотока && _срЗадержанноеАудио.уКонецСемплов === срАудио.уНачалоСемплов);

		Проверить(!_срЗадержанноеВидео.Пусто());
		_срЗадержанноеВидео.уКонецПотока  = срВидео.уКонецПотока;
		_срЗадержанноеВидео.уКонецСемплов = срВидео.уКонецСемплов;

		if (_срЗадержанноеАудио.Пусто())
		{
			_срЗадержанноеАудио.чВДНачала = срАудио.чВДНачала;
		}
		_срЗадержанноеАудио.уКонецПотока  = срАудио.уКонецПотока;
		_срЗадержанноеАудио.уКонецСемплов = срАудио.уКонецСемплов;
	}

	function ОбработатьСообщение()
	{
		var чНачало = performance.now();
		_лРазрыв = _лРазрыв || _оИсходныйСегмент.лРазрыв;


		м_Журнал.Вот(`НАЧАЛО ПРЕОБРАЗОВАНИЯ СЕГМЕНТА ${_оИсходныйСегмент.чНомер} Размер=${(_оИсходныйСегмент.пДанные.byteLength / 1024 / 1024).toFixed(2)}мб Длительность=${_оИсходныйСегмент.чДлительность} Разрыв=${_лРазрыв} РазделятьПоКлючевымКадрам=${_оИсходныйСегмент.чОбработка}`);


		ОчиститьСтатистику();
		var лСегментПреобразован = false;
		// Это сегмент для преобразования, а не состояние трансляции?
		if (typeof _оИсходныйСегмент.пДанные !== 'number')
		{
			var мбТранспортныйПоток = new Uint8Array(_оИсходныйСегмент.пДанные);
			try
			{
				ВыделитьПамять(мбТранспортныйПоток.length, _оИсходныйСегмент.чДлительность);
				if (РазобратьТранспортныйПоток(мбТранспортныйПоток))
				{
					// РазобратьТранспортныйПоток() могла изменить _лРазрыв.
					if (_лРазрыв)
					{
						_оПараметры = Object.create(null);
					}
					РазобратьМетаданные();
					лСегментПреобразован = РазобратьВидеоПоток() && РазобратьАудиоПоток();
				}
			}
			catch (пИсключение)
			{
				if (пИсключение instanceof Error && пИсключение.message === 'БРАКОВАТЬ')
				{
					// Браковать сегменты приходится очень редко.
					м_Журнал.Ой(`Сегмент забракован: ${пИсключение.stack}`);
					ОчиститьСтатистику();
					_лЗабраковано = true;
				}
				else
				{
					throw пИсключение;
				}
			}
			// Транспортный поток больше не нужен ни для преобразования, ни для анализа ошибок.
			м_Балкон.Положить(мбТранспортныйПоток);
		}

		if (!лСегментПреобразован)
		{
			Отправить(_лЗадержанРазрыв, _оЗадержанныеПараметры, _срЗадержанноеВидео, _срЗадержанноеАудио, false, true);
			_срЗадержанноеВидео.Свернуть();
			_срЗадержанноеАудио.Свернуть();
			if (typeof _оИсходныйСегмент.пДанные !== 'number')
			{
				Отправить(false, null, null, null, true, false);
			}
			else
			{
				ОсвободитьПамять();
				postMessage([1, _оИсходныйСегмент]);
			}
			_лРазрыв = true;
		}
		else
		{
			РазделитьИОтправитьОбработанныйСегмент();
			_лРазрыв = false;
		}

		м_Балкон.Освободить();
		_чПреобразованЗа = performance.now() - чНачало;
	}

	self.onmessage = function(оСобытие)
	{
		// UNDONE report://03599505848251_14958570155
		const сВерсия = typeof оСобытие.data !== 'object' || оСобытие.data === null ? typeof оСобытие.data : оСобытие.data.сВерсия;
		if (сВерсия !== ВЕРСИЯ_РАСШИРЕНИЯ)
		{
			// Передача журнала может меняться от версии к версии, а обработчик события Worker.error в главном потоке есть всегда.
			throw new Error(`Версия ${сВерсия} !== ${ВЕРСИЯ_РАСШИРЕНИЯ}`);
		}
		try
		{
			_оИсходныйСегмент = оСобытие.data;
			ОбработатьСообщение();
		}
		catch (пИсключение)
		{
			self.onmessage = null;
			// Ошибка могла возникнуть из-за нехватки памяти.
			ОсвободитьПамять();
			м_Журнал.Отправить();
			ЗавершитьРаботуИОтправитьОтчет(
				пИсключение instanceof Error
					? `Поймано исключение в рабочем потоке: ${пИсключение.stack}`
					: `Поймано исключение в рабочем потоке: [typeof ${typeof пИсключение}] ${new Error(пИсключение).stack}`,
				оСобытие.data.пДанные
			);
		}
		finally
		{
			_оИсходныйСегмент = null;
		}
	};
})();
